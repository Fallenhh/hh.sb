diff --git a/dist/cjs/cli.js b/dist/cjs/cli.js
new file mode 100644
index 0000000000000000000000000000000000000000..e4f06eae310e27855f93766462cf927ae3c0ca0d
--- /dev/null
+++ b/dist/cjs/cli.js
@@ -0,0 +1,188 @@
+#!/usr/bin/env node
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodeurl = require("node:url");
+const _nodeutil = require("node:util");
+const _nodemodule = require("node:module");
+const _hono = require("hono");
+const _nodeserver = require("@hono/node-server");
+const _servestatic = require("@hono/node-server/serve-static");
+const _config = require("./lib/config.js");
+const _honodev = require("./lib/middleware/hono-dev.js");
+const _honoprd = require("./lib/middleware/hono-prd.js");
+const _build = require("./lib/builder/build.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const require1 = (0, _nodemodule.createRequire)(new URL('.', require("url").pathToFileURL(__filename).toString()));
+const { values, positionals } = (0, _nodeutil.parseArgs)({
+    args: process.argv.splice(2),
+    allowPositionals: true,
+    options: {
+        'with-ssr': {
+            type: 'boolean'
+        },
+        'with-vercel': {
+            type: 'boolean'
+        },
+        'with-vercel-static': {
+            type: 'boolean'
+        },
+        'with-cloudflare': {
+            type: 'boolean'
+        },
+        'with-deno': {
+            type: 'boolean'
+        },
+        version: {
+            type: 'boolean',
+            short: 'v'
+        },
+        help: {
+            type: 'boolean',
+            short: 'h'
+        }
+    }
+});
+const cmd = positionals[0];
+if (values.version) {
+    const { version } = require1('../package.json');
+    console.log(version);
+} else if (values.help) {
+    displayUsage();
+} else {
+    const ssr = !!values['with-ssr'];
+    switch(cmd){
+        case 'dev':
+            runDev({
+                ssr
+            });
+            break;
+        case 'build':
+            runBuild({
+                ssr
+            });
+            break;
+        case 'start':
+            runStart({
+                ssr
+            });
+            break;
+        default:
+            if (cmd) {
+                console.error('Unknown command:', cmd);
+            }
+            displayUsage();
+            break;
+    }
+}
+async function runDev(options) {
+    const app = new _hono.Hono();
+    app.use('*', (0, _honodev.honoMiddleware)(options));
+    const port = parseInt(process.env.PORT || '3000', 10);
+    startServer(app, port);
+}
+async function runBuild(options) {
+    await (0, _build.build)({
+        ssr: options.ssr,
+        vercel: values['with-vercel'] ?? !!process.env.VERCEL ? {
+            type: values['with-vercel-static'] ? 'static' : 'serverless'
+        } : undefined,
+        cloudflare: !!values['with-cloudflare'],
+        deno: !!values['with-deno']
+    });
+}
+async function runStart(options) {
+    const { distDir, publicDir, entriesJs } = await (0, _config.resolveConfig)({});
+    const entries = Promise.resolve((0, _nodeurl.pathToFileURL)(_nodepath.default.resolve(distDir, entriesJs)).toString()).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p)));
+    const app = new _hono.Hono();
+    app.use('*', (0, _honoprd.honoMiddleware)({
+        entries,
+        ...options
+    }));
+    app.use('*', (0, _servestatic.serveStatic)({
+        root: _nodepath.default.join(distDir, publicDir)
+    }));
+    const port = parseInt(process.env.PORT || '8080', 10);
+    startServer(app, port);
+}
+async function startServer(app, port) {
+    const server = (0, _nodeserver.serve)({
+        ...app,
+        port
+    }, ()=>{
+        console.log(`ready: Listening on http://localhost:${port}/`);
+    });
+    server.on('error', (err)=>{
+        if (err.code === 'EADDRINUSE') {
+            console.log(`warn: Port ${port} is in use, trying ${port + 1} instead.`);
+            startServer(app, port + 1);
+        } else {
+            console.error(`Failed to start server: ${err.message}`);
+        }
+    });
+}
+function displayUsage() {
+    console.log(`
+Usage: waku [options] <command>
+
+Commands:
+  dev         Start the development server
+  build       Build the application for production
+  start       Start the production server
+
+Options:
+  --with-ssr            Use opt-in SSR
+  --with-vercel         Output for Vercel on build
+  --with-cloudflare     Output for Cloudflare on build
+  --with-deno           Output for Deno on build
+  -v, --version         Display the version number
+  -h, --help            Display this help message
+`);
+}
diff --git a/dist/cjs/client.js b/dist/cjs/client.js
new file mode 100644
index 0000000000000000000000000000000000000000..2ff494c13670842802d80815506d9f9ff2a4fec2
--- /dev/null
+++ b/dist/cjs/client.js
@@ -0,0 +1,149 @@
+/// <reference types="react/canary" />
+'use client';
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    Children: function() {
+        return Children;
+    },
+    Root: function() {
+        return Root;
+    },
+    ServerRoot: function() {
+        return ServerRoot;
+    },
+    Slot: function() {
+        return Slot;
+    },
+    fetchRSC: function() {
+        return fetchRSC;
+    },
+    prefetchRSC: function() {
+        return prefetchRSC;
+    },
+    useRefetch: function() {
+        return useRefetch;
+    }
+});
+const _react = require("react");
+const _client = /*#__PURE__*/ _interop_require_default(require("react-server-dom-webpack/client"));
+const _utils = require("./lib/renderers/utils.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const { createFromFetch, encodeReply } = _client.default;
+const checkStatus = async (responsePromise)=>{
+    const response = await responsePromise;
+    if (!response.ok) {
+        const err = new Error(response.statusText);
+        err.statusCode = response.status;
+        throw err;
+    }
+    return response;
+};
+const mergeElements = (0, _react.cache)(async (a, b)=>{
+    const nextElements = {
+        ...await a,
+        ...await b
+    };
+    delete nextElements._value;
+    return nextElements;
+});
+const fetchRSC = (0, _react.cache)((input, searchParamsString, rerender, basePath = '/RSC/')=>{
+    const options = {
+        async callServer (actionId, args) {
+            const response = fetch(basePath + (0, _utils.encodeInput)(encodeURIComponent(actionId)), {
+                method: 'POST',
+                body: await encodeReply(args)
+            });
+            const data = createFromFetch(checkStatus(response), options);
+            (0, _react.startTransition)(()=>{
+                // FIXME this causes rerenders even if data is empty
+                rerender((prev)=>mergeElements(prev, data));
+            });
+            return (await data)._value;
+        }
+    };
+    const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
+    const url = basePath + (0, _utils.encodeInput)(input) + (searchParamsString ? '?' + searchParamsString : '');
+    const response = prefetched[url] || fetch(url);
+    delete prefetched[url];
+    const data = createFromFetch(checkStatus(response), options);
+    return data;
+});
+const prefetchRSC = (0, _react.cache)((input, searchParamsString, basePath = '/RSC/')=>{
+    const prefetched = globalThis.__WAKU_PREFETCHED__ ||= {};
+    const url = basePath + (0, _utils.encodeInput)(input) + (searchParamsString ? '?' + searchParamsString : '');
+    if (!(url in prefetched)) {
+        prefetched[url] = fetch(url);
+    }
+});
+const RefetchContext = (0, _react.createContext)(()=>{
+    throw new Error('Missing Root component');
+});
+const ElementsContext = (0, _react.createContext)(null);
+// HACK there should be a better way...
+const createRerender = (0, _react.cache)(()=>{
+    let rerender;
+    const stableRerender = (fn)=>{
+        rerender?.(fn);
+    };
+    const getRerender = ()=>stableRerender;
+    const setRerender = (newRerender)=>{
+        rerender = newRerender;
+    };
+    return [
+        getRerender,
+        setRerender
+    ];
+});
+const Root = ({ initialInput, initialSearchParamsString, children, basePath })=>{
+    const [getRerender, setRerender] = createRerender();
+    const [elements, setElements] = (0, _react.useState)(()=>fetchRSC(initialInput || '', initialSearchParamsString || '', getRerender(), basePath));
+    setRerender(setElements);
+    const refetch = (0, _react.useCallback)((input, searchParams)=>{
+        const data = fetchRSC(input, searchParams?.toString() || '', getRerender(), basePath);
+        setElements((prev)=>mergeElements(prev, data));
+    }, [
+        getRerender,
+        basePath
+    ]);
+    return (0, _react.createElement)(RefetchContext.Provider, {
+        value: refetch
+    }, (0, _react.createElement)(ElementsContext.Provider, {
+        value: elements
+    }, children));
+};
+const useRefetch = ()=>(0, _react.use)(RefetchContext);
+const ChildrenContext = (0, _react.createContext)(undefined);
+const ChildrenContextProvider = (0, _react.memo)(ChildrenContext.Provider);
+const Slot = ({ id, children, fallback })=>{
+    const elementsPromise = (0, _react.use)(ElementsContext);
+    if (!elementsPromise) {
+        throw new Error('Missing Root component');
+    }
+    const elements = (0, _react.use)(elementsPromise);
+    if (!(id in elements)) {
+        if (fallback) {
+            return fallback(children);
+        }
+        throw new Error('Not found: ' + id);
+    }
+    return (0, _react.createElement)(ChildrenContextProvider, {
+        value: children
+    }, elements[id]);
+};
+const Children = ()=>(0, _react.use)(ChildrenContext);
+const ServerRoot = ({ elements, children })=>(0, _react.createElement)(ElementsContext.Provider, {
+        value: elements
+    }, children);
diff --git a/dist/cjs/config.js b/dist/cjs/config.js
new file mode 100644
index 0000000000000000000000000000000000000000..b62a6d552c31f18232522abd4007b7f4258d2b26
--- /dev/null
+++ b/dist/cjs/config.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
diff --git a/dist/cjs/dev.js b/dist/cjs/dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..33e75c91fb16388773aaae5679307dc4339043cc
--- /dev/null
+++ b/dist/cjs/dev.js
@@ -0,0 +1,28 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    build: function() {
+        return _build.build;
+    },
+    connectMiddleware: function() {
+        return _connectdev.connectMiddleware;
+    },
+    honoMiddleware: function() {
+        return _honodev.honoMiddleware;
+    },
+    unstable_createHandler: function() {
+        return _handlerdev.createHandler;
+    }
+});
+const _honodev = require("./lib/middleware/hono-dev.js");
+const _connectdev = require("./lib/middleware/connect-dev.js");
+const _handlerdev = require("./lib/handlers/handler-dev.js");
+const _build = require("./lib/builder/build.js");
diff --git a/dist/cjs/lib/builder/build.js b/dist/cjs/lib/builder/build.js
new file mode 100644
index 0000000000000000000000000000000000000000..3b1afba08daf0bade7108ea1552a3093281c0145
--- /dev/null
+++ b/dist/cjs/lib/builder/build.js
@@ -0,0 +1,454 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "build", {
+    enumerable: true,
+    get: function() {
+        return build;
+    }
+});
+const _nodecrypto = require("node:crypto");
+const _nodestream = require("node:stream");
+const _promises = require("node:stream/promises");
+const _vite = require("vite");
+const _pluginreact = /*#__PURE__*/ _interop_require_default(require("@vitejs/plugin-react"));
+const _config = require("../config.js");
+const _path = require("../utils/path.js");
+const _nodefs = require("../utils/node-fs.js");
+const _utils = require("../renderers/utils.js");
+const _rscrenderer = require("../renderers/rsc-renderer.js");
+const _htmlrenderer = require("../renderers/html-renderer.js");
+const _vitepluginrscindex = require("../plugins/vite-plugin-rsc-index.js");
+const _vitepluginrscanalyze = require("../plugins/vite-plugin-rsc-analyze.js");
+const _vitepluginnonjsresolve = require("../plugins/vite-plugin-nonjs-resolve.js");
+const _vitepluginrsctransform = require("../plugins/vite-plugin-rsc-transform.js");
+const _patchreactrefresh = require("../plugins/patch-react-refresh.js");
+const _outputvercel = require("./output-vercel.js");
+const _outputcloudflare = require("./output-cloudflare.js");
+const _outputdeno = require("./output-deno.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+// TODO this file and functions in it are too long. will fix.
+// Upstream issue: https://github.com/rollup/rollup/issues/4699
+const onwarn = (warning, defaultHandler)=>{
+    if (warning.code === 'MODULE_LEVEL_DIRECTIVE' && /"use (client|server)"/.test(warning.message)) {
+        return;
+    } else if (warning.code === 'SOURCEMAP_ERROR' && warning.loc?.file?.endsWith('.tsx') && warning.loc?.column === 0 && warning.loc?.line === 1) {
+        return;
+    }
+    defaultHandler(warning);
+};
+const hash = (fname)=>new Promise((resolve)=>{
+        const sha256 = (0, _nodecrypto.createHash)('sha256');
+        sha256.on('readable', ()=>{
+            const data = sha256.read();
+            if (data) {
+                resolve(data.toString('hex').slice(0, 9));
+            }
+        });
+        (0, _nodefs.createReadStream)(fname).pipe(sha256);
+    });
+const analyzeEntries = async (entriesFile)=>{
+    const commonFileSet = new Set();
+    const clientFileSet = new Set();
+    const serverFileSet = new Set();
+    await (0, _vite.build)({
+        plugins: [
+            (0, _vitepluginrscanalyze.rscAnalyzePlugin)(commonFileSet, clientFileSet, serverFileSet)
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                externalConditions: [
+                    'react-server',
+                    'workerd'
+                ]
+            },
+            noExternal: /^(?!node:)/
+        },
+        build: {
+            write: false,
+            ssr: true,
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile
+                }
+            }
+        }
+    });
+    const commonEntryFiles = Object.fromEntries(await Promise.all(Array.from(commonFileSet).map(async (fname, i)=>[
+            `com${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const clientEntryFiles = Object.fromEntries(await Promise.all(Array.from(clientFileSet).map(async (fname, i)=>[
+            `rsc${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const serverEntryFiles = Object.fromEntries(Array.from(serverFileSet).map((fname, i)=>[
+            `rsf${i}`,
+            fname
+        ]));
+    return {
+        commonEntryFiles,
+        clientEntryFiles,
+        serverEntryFiles
+    };
+};
+const buildServerBundle = async (rootDir, config, entriesFile, distEntriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles)=>{
+    const serverBuildOutput = await (0, _vite.build)({
+        plugins: [
+            (0, _vitepluginnonjsresolve.nonjsResolvePlugin)(),
+            (0, _vitepluginrsctransform.rscTransformPlugin)({
+                isBuild: true,
+                assetsDir: config.assetsDir,
+                clientEntryFiles: {
+                    // FIXME this seems very ad-hoc
+                    [_htmlrenderer.WAKU_CLIENT_MODULE]: (0, _path.decodeFilePathFromAbsolute)((0, _path.joinPath)((0, _path.fileURLToFilePath)(require("url").pathToFileURL(__filename).toString()), '../../../client.js')),
+                    ...clientEntryFiles
+                },
+                serverEntryFiles
+            })
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                externalConditions: [
+                    'react-server',
+                    'workerd'
+                ]
+            },
+            noExternal: /^(?!node:)/
+        },
+        define: {
+            'process.env.NODE_ENV': JSON.stringify('production')
+        },
+        publicDir: false,
+        build: {
+            ssr: true,
+            ssrEmitAssets: true,
+            outDir: (0, _path.joinPath)(rootDir, config.distDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile,
+                    [_rscrenderer.RSDW_SERVER_MODULE]: _rscrenderer.RSDW_SERVER_MODULE_VALUE,
+                    [_htmlrenderer.WAKU_CLIENT_MODULE]: _htmlrenderer.WAKU_CLIENT_MODULE_VALUE,
+                    ...commonEntryFiles,
+                    ...clientEntryFiles,
+                    ...serverEntryFiles
+                },
+                output: {
+                    entryFileNames: (chunkInfo)=>{
+                        if ([
+                            _htmlrenderer.WAKU_CLIENT_MODULE
+                        ].includes(chunkInfo.name) || commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name] || serverEntryFiles[chunkInfo.name]) {
+                            return config.assetsDir + '/[name].js';
+                        }
+                        return '[name].js';
+                    }
+                }
+            }
+        }
+    });
+    if (!('output' in serverBuildOutput)) {
+        throw new Error('Unexpected vite server build output');
+    }
+    const psDir = (0, _path.joinPath)(config.publicDir, config.assetsDir);
+    const code = `
+export function loadModule(id) {
+  switch (id) {
+    case '${_rscrenderer.RSDW_SERVER_MODULE}':
+      return import('./${_rscrenderer.RSDW_SERVER_MODULE}.js');
+    case 'public/${_htmlrenderer.REACT_MODULE}':
+      return import('./${psDir}/${_htmlrenderer.REACT_MODULE}.js');
+    case 'public/${_htmlrenderer.RD_SERVER_MODULE}':
+      return import('./${psDir}/${_htmlrenderer.RD_SERVER_MODULE}.js');
+    case 'public/${_htmlrenderer.RSDW_CLIENT_MODULE}':
+      return import('./${psDir}/${_htmlrenderer.RSDW_CLIENT_MODULE}.js');
+    case 'public/${_htmlrenderer.WAKU_CLIENT_MODULE}':
+      return import('./${psDir}/${_htmlrenderer.WAKU_CLIENT_MODULE}.js');
+    case '${psDir}/${_htmlrenderer.WAKU_CLIENT_MODULE}.js':
+      return import('./${psDir}/${_htmlrenderer.WAKU_CLIENT_MODULE}.js');
+${Object.entries(serverEntryFiles || {}).map(([k])=>`
+    case '${config.assetsDir}/${k}.js':
+      return import('./${config.assetsDir}/${k}.js');`).join('')}
+${Object.entries(clientEntryFiles || {}).map(([k])=>`
+    case 'public/${config.assetsDir}/${k}.js':
+      return import('./${psDir}/${k}.js');`).join('')}
+    default:
+      throw new Error('Cannot find module: ' + id);
+  }
+}
+`;
+    await (0, _nodefs.appendFile)(distEntriesFile, code);
+    return serverBuildOutput;
+};
+const buildClientBundle = async (rootDir, config, commonEntryFiles, clientEntryFiles, serverBuildOutput)=>{
+    const mainJsFile = (0, _path.joinPath)(rootDir, config.srcDir, config.mainJs);
+    const cssAssets = serverBuildOutput.output.flatMap(({ type, fileName })=>type === 'asset' && fileName.endsWith('.css') ? [
+            fileName
+        ] : []);
+    const clientBuildOutput = await (0, _vite.build)({
+        base: config.basePath,
+        plugins: [
+            (0, _patchreactrefresh.patchReactRefresh)((0, _pluginreact.default)()),
+            (0, _vitepluginrscindex.rscIndexPlugin)({
+                ...config,
+                cssAssets
+            })
+        ],
+        build: {
+            outDir: (0, _path.joinPath)(rootDir, config.distDir, config.publicDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    main: mainJsFile,
+                    [_htmlrenderer.REACT_MODULE]: _htmlrenderer.REACT_MODULE_VALUE,
+                    [_htmlrenderer.RD_SERVER_MODULE]: _htmlrenderer.RD_SERVER_MODULE_VALUE,
+                    [_htmlrenderer.RSDW_CLIENT_MODULE]: _htmlrenderer.RSDW_CLIENT_MODULE_VALUE,
+                    [_htmlrenderer.WAKU_CLIENT_MODULE]: _htmlrenderer.WAKU_CLIENT_MODULE_VALUE,
+                    ...commonEntryFiles,
+                    ...clientEntryFiles
+                },
+                preserveEntrySignatures: 'exports-only',
+                output: {
+                    entryFileNames: (chunkInfo)=>{
+                        if ([
+                            _htmlrenderer.REACT_MODULE,
+                            _htmlrenderer.RD_SERVER_MODULE,
+                            _htmlrenderer.RSDW_CLIENT_MODULE,
+                            _htmlrenderer.WAKU_CLIENT_MODULE
+                        ].includes(chunkInfo.name) || commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name]) {
+                            return config.assetsDir + '/[name].js';
+                        }
+                        return config.assetsDir + '/[name]-[hash].js';
+                    }
+                }
+            }
+        }
+    });
+    if (!('output' in clientBuildOutput)) {
+        throw new Error('Unexpected vite client build output');
+    }
+    for (const cssAsset of cssAssets){
+        const from = (0, _path.joinPath)(rootDir, config.distDir, cssAsset);
+        const to = (0, _path.joinPath)(rootDir, config.distDir, config.publicDir, cssAsset);
+        await (0, _nodefs.rename)(from, to);
+    }
+    return clientBuildOutput;
+};
+const emitRscFiles = async (rootDir, config, distEntriesFile)=>{
+    const distEntries = await Promise.resolve((0, _path.filePathToFileURL)(distEntriesFile)).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p)));
+    const buildConfig = await (0, _rscrenderer.getBuildConfig)({
+        config,
+        entries: distEntries
+    });
+    const clientModuleMap = new Map();
+    const addClientModule = (input, id)=>{
+        let idSet = clientModuleMap.get(input);
+        if (!idSet) {
+            idSet = new Set();
+            clientModuleMap.set(input, idSet);
+        }
+        idSet.add(id);
+    };
+    const getClientModules = (input)=>{
+        const idSet = clientModuleMap.get(input);
+        return Array.from(idSet || []);
+    };
+    const rscFileSet = new Set(); // XXX could be implemented better
+    const staticInputSet = new Set();
+    await Promise.all(Array.from(buildConfig).map(async ({ entries, context })=>{
+        for (const { input, isStatic } of entries || []){
+            if (isStatic) {
+                staticInputSet.add(input);
+            }
+            const destRscFile = (0, _path.joinPath)(rootDir, config.distDir, config.publicDir, config.rscPath, (0, _utils.encodeInput)(// Should we do this here? Or waku/router or in entries.ts?
+            input.split('\\').join('/')));
+            if (!rscFileSet.has(destRscFile)) {
+                rscFileSet.add(destRscFile);
+                await (0, _nodefs.mkdir)((0, _path.joinPath)(destRscFile, '..'), {
+                    recursive: true
+                });
+                const readable = await (0, _rscrenderer.renderRsc)({
+                    input,
+                    searchParams: new URLSearchParams(),
+                    method: 'GET',
+                    config,
+                    context,
+                    moduleIdCallback: (id)=>addClientModule(input, id),
+                    isDev: false,
+                    entries: distEntries
+                });
+                await (0, _promises.pipeline)(_nodestream.Readable.fromWeb(readable), (0, _nodefs.createWriteStream)(destRscFile));
+            }
+        }
+    }));
+    const skipRenderRscCode = `
+const staticInputSet = new Set(${JSON.stringify(Array.from(staticInputSet))});
+export function skipRenderRsc(input) {
+  return staticInputSet.has(input);
+}
+`;
+    await (0, _nodefs.appendFile)(distEntriesFile, skipRenderRscCode);
+    return {
+        buildConfig,
+        getClientModules,
+        rscFiles: Array.from(rscFileSet)
+    };
+};
+const emitHtmlFiles = async (rootDir, config, distEntriesFile, buildConfig, getClientModules, ssr)=>{
+    const distEntries = await Promise.resolve((0, _path.filePathToFileURL)(distEntriesFile)).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p)));
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const publicIndexHtmlFile = (0, _path.joinPath)(rootDir, config.distDir, config.publicDir, config.indexHtml);
+    const publicIndexHtml = await (0, _nodefs.readFile)(publicIndexHtmlFile, {
+        encoding: 'utf8'
+    });
+    const publicIndexHtmlHead = publicIndexHtml.replace(/.*?<head>(.*?)<\/head>.*/s, '$1');
+    const htmlHeadMap = {};
+    // TODO check duplicated files like rscFileSet
+    const htmlFiles = await Promise.all(Array.from(buildConfig).map(async ({ pathname, entries, customCode, context })=>{
+        let htmlStr = publicIndexHtml;
+        let htmlHead = publicIndexHtmlHead;
+        const destHtmlFile = (0, _path.joinPath)(rootDir, config.distDir, config.publicDir, (0, _path.extname)(pathname) ? pathname : pathname + '/' + config.indexHtml);
+        const inputsForPrefetch = new Set();
+        const moduleIdsForPrefetch = new Set();
+        for (const { input, skipPrefetch } of entries || []){
+            if (!skipPrefetch) {
+                inputsForPrefetch.add(input);
+                for (const id of getClientModules(input)){
+                    moduleIdsForPrefetch.add(id);
+                }
+            }
+        }
+        const code = (0, _utils.generatePrefetchCode)(basePrefix, inputsForPrefetch, moduleIdsForPrefetch) + (customCode || '');
+        if (code) {
+            // HACK is this too naive to inject script code?
+            htmlStr = htmlStr.replace(/<\/head>/, `<script type="module" async>${code}</script></head>`);
+            htmlHead += `<script type="module" async>${code}</script>`;
+        }
+        htmlHeadMap[pathname] = htmlHead;
+        const htmlReadable = ssr && await (0, _htmlrenderer.renderHtml)({
+            config,
+            pathname,
+            searchParams: new URLSearchParams(),
+            htmlHead,
+            renderRscForHtml: (input, searchParams)=>(0, _rscrenderer.renderRsc)({
+                    entries: distEntries,
+                    config,
+                    input,
+                    searchParams,
+                    method: 'GET',
+                    context,
+                    isDev: false
+                }),
+            isDev: false,
+            entries: distEntries,
+            isBuild: true
+        });
+        await (0, _nodefs.mkdir)((0, _path.joinPath)(destHtmlFile, '..'), {
+            recursive: true
+        });
+        if (htmlReadable) {
+            await (0, _promises.pipeline)(_nodestream.Readable.fromWeb(htmlReadable), (0, _nodefs.createWriteStream)(destHtmlFile));
+        } else {
+            await (0, _nodefs.writeFile)(destHtmlFile, htmlStr);
+        }
+        return destHtmlFile;
+    }));
+    const loadHtmlHeadCode = `
+export function loadHtmlHead(pathname) {
+  return ${JSON.stringify(htmlHeadMap)}[pathname] || ${JSON.stringify(publicIndexHtmlHead)};
+}
+`;
+    await (0, _nodefs.appendFile)(distEntriesFile, loadHtmlHeadCode);
+    return {
+        htmlFiles
+    };
+};
+const resolveFileName = (fname)=>{
+    for (const ext of [
+        '.js',
+        '.ts',
+        '.tsx',
+        '.jsx'
+    ]){
+        const resolvedName = fname.slice(0, -(0, _path.extname)(fname).length) + ext;
+        if ((0, _nodefs.existsSync)(resolvedName)) {
+            return resolvedName;
+        }
+    }
+    return fname; // returning the default one
+};
+async function build(options) {
+    const config = await (0, _config.resolveConfig)(options.config || {});
+    const rootDir = (await (0, _vite.resolveConfig)({}, 'build', 'production', 'production')).root;
+    const entriesFile = resolveFileName((0, _path.joinPath)(rootDir, config.srcDir, config.entriesJs));
+    const distEntriesFile = resolveFileName((0, _path.joinPath)(rootDir, config.distDir, config.entriesJs));
+    const { commonEntryFiles, clientEntryFiles, serverEntryFiles } = await analyzeEntries(entriesFile);
+    const serverBuildOutput = await buildServerBundle(rootDir, config, entriesFile, distEntriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles);
+    await buildClientBundle(rootDir, config, commonEntryFiles, clientEntryFiles, serverBuildOutput);
+    const { buildConfig, getClientModules, rscFiles } = await emitRscFiles(rootDir, config, distEntriesFile);
+    const { htmlFiles } = await emitHtmlFiles(rootDir, config, distEntriesFile, buildConfig, getClientModules, !!options?.ssr);
+    if (options?.vercel) {
+        await (0, _outputvercel.emitVercelOutput)(rootDir, config, rscFiles, htmlFiles, !!options?.ssr, options.vercel.type);
+    }
+    if (options?.cloudflare) {
+        await (0, _outputcloudflare.emitCloudflareOutput)(rootDir, config, !!options?.ssr);
+    }
+    if (options?.deno) {
+        await (0, _outputdeno.emitDenoOutput)(rootDir, config, !!options?.ssr);
+    }
+}
diff --git a/dist/cjs/lib/builder/output-cloudflare.js b/dist/cjs/lib/builder/output-cloudflare.js
new file mode 100644
index 0000000000000000000000000000000000000000..e3d755156c6df97d72037010df6d512cf10a3687
--- /dev/null
+++ b/dist/cjs/lib/builder/output-cloudflare.js
@@ -0,0 +1,47 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "emitCloudflareOutput", {
+    enumerable: true,
+    get: function() {
+        return emitCloudflareOutput;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = require("node:fs");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const emitCloudflareOutput = async (rootDir, config, ssr)=>{
+    const outputDir = _nodepath.default.resolve('.');
+    const relativeRootDir = _nodepath.default.relative(outputDir, rootDir);
+    const entriesFile = _nodepath.default.join(relativeRootDir, config.distDir, config.entriesJs);
+    const publicDir = _nodepath.default.join(relativeRootDir, config.distDir, config.publicDir);
+    if (!(0, _nodefs.existsSync)(_nodepath.default.join(outputDir, 'serve.js'))) {
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(outputDir, 'serve.js'), `
+import { honoMiddleware } from 'waku';
+import { Hono } from 'hono';
+import { serveStatic } from 'hono/cloudflare-workers';
+
+const entries = import('./${entriesFile}');
+
+const app = new Hono();
+app.use('*', honoMiddleware({ entries, ssr: ${ssr} }));
+app.use('*', serveStatic({ root: './' }));
+export default app;
+`);
+    }
+    if (!(0, _nodefs.existsSync)(_nodepath.default.join(outputDir, 'wrangler.toml'))) {
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(outputDir, 'wrangler.toml'), `
+name = "waku-project"
+main = "serve.js"
+compatibility_date = "2023-12-06"
+
+[site]
+bucket = "./${publicDir}"
+`);
+    }
+};
diff --git a/dist/cjs/lib/builder/output-deno.js b/dist/cjs/lib/builder/output-deno.js
new file mode 100644
index 0000000000000000000000000000000000000000..4a564ce11f9d66e874181400a6953b7bb92fe578
--- /dev/null
+++ b/dist/cjs/lib/builder/output-deno.js
@@ -0,0 +1,38 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "emitDenoOutput", {
+    enumerable: true,
+    get: function() {
+        return emitDenoOutput;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = require("node:fs");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const emitDenoOutput = async (rootDir, config, ssr)=>{
+    const outputDir = _nodepath.default.resolve('.');
+    const relativeRootDir = _nodepath.default.relative(outputDir, rootDir);
+    const entriesFile = _nodepath.default.join(relativeRootDir, config.distDir, config.entriesJs);
+    const publicDir = _nodepath.default.join(relativeRootDir, config.distDir, config.publicDir);
+    if (!(0, _nodefs.existsSync)(_nodepath.default.join(outputDir, 'serve.ts'))) {
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(outputDir, 'serve.ts'), `
+import { Hono } from "https://deno.land/x/hono/mod.ts";
+import { serveStatic } from "https://deno.land/x/hono/middleware.ts";
+import { honoMiddleware } from "npm:waku@0.18.1";
+
+const entries = import('./${entriesFile}');
+
+const app = new Hono();
+app.use('*', honoMiddleware({ entries, ssr: ${ssr} }));
+app.use("*", serveStatic({ root: "${publicDir}" }));
+
+Deno.serve(app.fetch);
+`);
+    }
+};
diff --git a/dist/cjs/lib/builder/output-vercel.js b/dist/cjs/lib/builder/output-vercel.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3fa674f51dadf5eeb910b6a47d53d5536e122ab
--- /dev/null
+++ b/dist/cjs/lib/builder/output-vercel.js
@@ -0,0 +1,108 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "emitVercelOutput", {
+    enumerable: true,
+    get: function() {
+        return emitVercelOutput;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = require("node:fs");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const emitVercelOutput = async (rootDir, config, rscFiles, htmlFiles, ssr, type)=>{
+    const publicDir = _nodepath.default.join(rootDir, config.distDir, config.publicDir);
+    const outputDir = _nodepath.default.resolve('.vercel', 'output');
+    (0, _nodefs.cpSync)(_nodepath.default.join(rootDir, config.distDir, config.publicDir), _nodepath.default.join(outputDir, 'static'), {
+        recursive: true
+    });
+    if (type === 'serverless') {
+        // for serverless function
+        const serverlessDir = _nodepath.default.join(outputDir, 'functions', config.rscPath + '.func');
+        (0, _nodefs.mkdirSync)(_nodepath.default.join(serverlessDir, config.distDir), {
+            recursive: true
+        });
+        (0, _nodefs.mkdirSync)(_nodepath.default.join(serverlessDir, 'node_modules'), {
+            recursive: true
+        });
+        (0, _nodefs.cpSync)(_nodepath.default.join(rootDir, 'node_modules', 'waku'), _nodepath.default.join(serverlessDir, 'node_modules', 'waku'), {
+            dereference: true,
+            recursive: true
+        });
+        (0, _nodefs.cpSync)(_nodepath.default.join(rootDir, config.distDir), _nodepath.default.join(serverlessDir, config.distDir), {
+            recursive: true
+        });
+        const vcConfigJson = {
+            runtime: 'nodejs18.x',
+            handler: 'serve.js',
+            launcherType: 'Nodejs'
+        };
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(serverlessDir, '.vc-config.json'), JSON.stringify(vcConfigJson, null, 2));
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(serverlessDir, 'package.json'), JSON.stringify({
+            type: 'module'
+        }, null, 2));
+        (0, _nodefs.writeFileSync)(_nodepath.default.join(serverlessDir, 'serve.js'), `
+import path from 'node:path';
+import fs from 'node:fs';
+import { connectMiddleware } from 'waku';
+const entries = import(path.resolve('${config.distDir}', '${config.entriesJs}'));
+export default function handler(req, res) {
+  connectMiddleware({ entries, ssr: ${ssr} })(req, res, () => {
+    const { pathname } = new URL(req.url, 'http://localhost');
+    const fname = path.join(
+      '${config.distDir}',
+      '${config.publicDir}',
+      pathname,
+      path.extname(pathname) ? '' : '${config.indexHtml}',
+    );
+    if (fs.existsSync(fname)) {
+      if (fname.endsWith('.html')) {
+        res.setHeader('content-type', 'text/html; charset=utf-8');
+      } else if (fname.endsWith('.txt')) {
+        res.setHeader('content-type', 'text/plain');
+      }
+      fs.createReadStream(fname).pipe(res);
+      return;
+    }
+    res.statusCode = 404;
+    res.end();
+  });
+}
+`);
+    }
+    const overrides = Object.fromEntries(rscFiles.filter((file)=>!_nodepath.default.extname(file)).map((file)=>[
+            _nodepath.default.relative(publicDir, file),
+            {
+                contentType: 'text/plain'
+            }
+        ]));
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const routes = type === 'serverless' ? [
+        {
+            src: basePrefix + '(.*)',
+            dest: basePrefix
+        },
+        ...ssr ? htmlFiles.map((htmlFile)=>{
+            const file = config.basePath + _nodepath.default.relative(publicDir, htmlFile);
+            const src = file.endsWith('/' + config.indexHtml) ? file.slice(0, -('/' + config.indexHtml).length) || '/' : file;
+            return {
+                src,
+                dest: basePrefix
+            };
+        }) : []
+    ] : undefined;
+    const configJson = {
+        version: 3,
+        overrides,
+        routes
+    };
+    (0, _nodefs.mkdirSync)(outputDir, {
+        recursive: true
+    });
+    (0, _nodefs.writeFileSync)(_nodepath.default.join(outputDir, 'config.json'), JSON.stringify(configJson, null, 2));
+};
diff --git a/dist/cjs/lib/builder.js b/dist/cjs/lib/builder.js
new file mode 100644
index 0000000000000000000000000000000000000000..93505aab71d41633fd4d9fe483bf550b587c5c4c
--- /dev/null
+++ b/dist/cjs/lib/builder.js
@@ -0,0 +1,411 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "build", {
+    enumerable: true,
+    get: function() {
+        return build;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = /*#__PURE__*/ _interop_require_default(require("node:fs"));
+const _nodecrypto = require("node:crypto");
+const _promises = require("node:stream/promises");
+const _vite = require("vite");
+const _pluginreact = /*#__PURE__*/ _interop_require_default(require("@vitejs/plugin-react"));
+const _config = require("./config.js");
+const _utils = require("./middleware/rsc/utils.js");
+const _workerapi = require("./middleware/rsc/worker-api.js");
+const _rscindexplugin = require("./vite-plugin/rsc-index-plugin.js");
+const _rscanalyzeplugin = require("./vite-plugin/rsc-analyze-plugin.js");
+const _patchreactrefresh = require("./vite-plugin/patch-react-refresh.js");
+const _ssr = require("./middleware/rsc/ssr.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+// Upstream issue: https://github.com/rollup/rollup/issues/4699
+const onwarn = (warning, defaultHandler)=>{
+    if (warning.code === 'MODULE_LEVEL_DIRECTIVE' && /"use (client|server)"/.test(warning.message)) {
+        return;
+    } else if (warning.code === 'SOURCEMAP_ERROR' && warning.loc?.file?.endsWith('.tsx') && warning.loc?.column === 0 && warning.loc?.line === 1) {
+        return;
+    }
+    defaultHandler(warning);
+};
+const hash = (fname)=>new Promise((resolve)=>{
+        const sha256 = (0, _nodecrypto.createHash)('sha256');
+        sha256.on('readable', ()=>{
+            const data = sha256.read();
+            if (data) {
+                resolve(data.toString('hex').slice(0, 9));
+            }
+        });
+        _nodefs.default.createReadStream(fname).pipe(sha256);
+    });
+const analyzeEntries = async (entriesFile)=>{
+    const commonFileSet = new Set();
+    const clientFileSet = new Set();
+    const serverFileSet = new Set();
+    await (0, _vite.build)({
+        ...(0, _config.viteInlineConfig)(),
+        plugins: [
+            (0, _rscanalyzeplugin.rscAnalyzePlugin)(commonFileSet, clientFileSet, serverFileSet)
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server'
+                ],
+                externalConditions: [
+                    'react-server'
+                ]
+            },
+            noExternal: /^(?!node:)/
+        },
+        build: {
+            write: false,
+            ssr: true,
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile
+                }
+            }
+        }
+    });
+    const commonEntryFiles = Object.fromEntries(await Promise.all(Array.from(commonFileSet).map(async (fname, i)=>[
+            `com${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const clientEntryFiles = Object.fromEntries(await Promise.all(Array.from(clientFileSet).map(async (fname, i)=>[
+            `rsc${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const serverEntryFiles = Object.fromEntries(Array.from(serverFileSet).map((fname, i)=>[
+            `rsf${i}`,
+            fname
+        ]));
+    return {
+        commonEntryFiles,
+        clientEntryFiles,
+        serverEntryFiles
+    };
+};
+const buildServerBundle = async (config, entriesFile, distEntriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles)=>{
+    const serverBuildOutput = await (0, _vite.build)({
+        ...(0, _config.viteInlineConfig)(),
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server'
+                ],
+                externalConditions: [
+                    'react-server'
+                ]
+            },
+            external: [
+                'waku'
+            ],
+            noExternal: Object.values(clientEntryFiles).flatMap((fname)=>{
+                const items = fname.split(_nodepath.default.sep);
+                const index = items.lastIndexOf('node_modules');
+                const name = index >= 0 && items[index + 1];
+                return name ? [
+                    name
+                ] : [];
+            })
+        },
+        publicDir: false,
+        build: {
+            ssr: true,
+            ssrEmitAssets: true,
+            outDir: _nodepath.default.join(config.rootDir, config.distDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile,
+                    ...commonEntryFiles,
+                    ...clientEntryFiles,
+                    ...serverEntryFiles
+                },
+                output: {
+                    banner: (chunk)=>{
+                        // HACK to bring directives to the front
+                        let code = '';
+                        if (chunk.moduleIds.some((id)=>Object.values(clientEntryFiles).includes(id))) {
+                            code += '"use client";';
+                        }
+                        if (chunk.moduleIds.some((id)=>Object.values(serverEntryFiles).includes(id))) {
+                            code += '"use server";';
+                        }
+                        return code;
+                    },
+                    entryFileNames: (chunkInfo)=>{
+                        if (commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name] || serverEntryFiles[chunkInfo.name]) {
+                            return 'assets/[name].js';
+                        }
+                        return '[name].js';
+                    }
+                }
+            }
+        }
+    });
+    if (!('output' in serverBuildOutput)) {
+        throw new Error('Unexpected vite server build output');
+    }
+    const code = `export const resolveClientPath = (filePath, invert) => (invert ? ${JSON.stringify(Object.fromEntries(Object.entries(clientEntryFiles).map(([key, val])=>[
+            _nodepath.default.posix.join(config.rootDir, config.distDir, 'assets', key + '.js'),
+            val
+        ])))} : ${JSON.stringify(Object.fromEntries(Object.entries(clientEntryFiles).map(([key, val])=>[
+            val,
+            _nodepath.default.posix.join(config.rootDir, config.distDir, 'assets', key + '.js')
+        ])))})[filePath];
+`;
+    _nodefs.default.appendFileSync(distEntriesFile, code);
+    return serverBuildOutput;
+};
+const buildClientBundle = async (config, commonEntryFiles, clientEntryFiles, serverBuildOutput)=>{
+    const indexHtmlFile = _nodepath.default.join(config.rootDir, config.srcDir, config.indexHtml);
+    const cssAssets = serverBuildOutput.output.flatMap(({ type, fileName })=>type === 'asset' && fileName.endsWith('.css') ? [
+            fileName
+        ] : []);
+    const clientBuildOutput = await (0, _vite.build)({
+        ...(0, _config.viteInlineConfig)(),
+        root: _nodepath.default.join(config.rootDir, config.srcDir),
+        plugins: [
+            (0, _patchreactrefresh.patchReactRefresh)((0, _pluginreact.default)()),
+            (0, _rscindexplugin.rscIndexPlugin)(cssAssets)
+        ],
+        build: {
+            outDir: _nodepath.default.join(config.rootDir, config.distDir, config.publicDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    main: indexHtmlFile,
+                    ...commonEntryFiles,
+                    ...clientEntryFiles
+                },
+                preserveEntrySignatures: 'exports-only',
+                output: {
+                    entryFileNames: (chunkInfo)=>{
+                        if (commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name]) {
+                            return 'assets/[name].js';
+                        }
+                        return 'assets/[name]-[hash].js';
+                    },
+                    // FIXME This is simply to override for examples/07,10 vite configs
+                    preserveModules: false
+                }
+            }
+        }
+    });
+    if (!('output' in clientBuildOutput)) {
+        throw new Error('Unexpected vite client build output');
+    }
+    for (const cssAsset of cssAssets){
+        const from = _nodepath.default.join(config.rootDir, config.distDir, cssAsset);
+        const to = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir, cssAsset);
+        _nodefs.default.renameSync(from, to);
+    }
+    return clientBuildOutput;
+};
+const emitRscFiles = async (config)=>{
+    const buildConfig = await (0, _workerapi.getBuildConfigRSC)();
+    const clientModuleMap = new Map();
+    const addClientModule = (input, id)=>{
+        let idSet = clientModuleMap.get(input);
+        if (!idSet) {
+            idSet = new Set();
+            clientModuleMap.set(input, idSet);
+        }
+        idSet.add(id);
+    };
+    const getClientModules = (input)=>{
+        const idSet = clientModuleMap.get(input);
+        return Array.from(idSet || []);
+    };
+    const rscFileSet = new Set(); // XXX could be implemented better
+    await Promise.all(Object.entries(buildConfig).map(async ([, { entries, context }])=>{
+        for (const [input] of entries || []){
+            const destFile = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir, config.rscPath, // HACK to support windows filesystem
+            (0, _utils.encodeInput)(input).replaceAll('/', _nodepath.default.sep));
+            if (!rscFileSet.has(destFile)) {
+                rscFileSet.add(destFile);
+                _nodefs.default.mkdirSync(_nodepath.default.dirname(destFile), {
+                    recursive: true
+                });
+                const [readable] = await (0, _workerapi.renderRSC)({
+                    input,
+                    method: 'GET',
+                    headers: {},
+                    command: 'build',
+                    context,
+                    moduleIdCallback: (id)=>addClientModule(input, id)
+                });
+                await (0, _promises.pipeline)(readable, _nodefs.default.createWriteStream(destFile));
+            }
+        }
+    }));
+    return {
+        buildConfig,
+        getClientModules,
+        rscFiles: Array.from(rscFileSet)
+    };
+};
+const emitHtmlFiles = async (config, buildConfig, getClientModules, ssr)=>{
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const publicIndexHtmlFile = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir, config.indexHtml);
+    const publicIndexHtml = _nodefs.default.readFileSync(publicIndexHtmlFile, {
+        encoding: 'utf8'
+    });
+    const htmlFiles = await Promise.all(Object.entries(buildConfig).map(async ([pathStr, { entries, customCode, context }])=>{
+        const destFile = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir, pathStr, pathStr.endsWith('/') ? 'index.html' : '');
+        let htmlStr;
+        if (_nodefs.default.existsSync(destFile)) {
+            htmlStr = _nodefs.default.readFileSync(destFile, {
+                encoding: 'utf8'
+            });
+        } else {
+            _nodefs.default.mkdirSync(_nodepath.default.dirname(destFile), {
+                recursive: true
+            });
+            htmlStr = publicIndexHtml;
+        }
+        const inputsForPrefetch = new Set();
+        const moduleIdsForPrefetch = new Set();
+        for (const [input, skipPrefetch] of entries || []){
+            if (!skipPrefetch) {
+                inputsForPrefetch.add(input);
+                for (const id of getClientModules(input)){
+                    moduleIdsForPrefetch.add(id);
+                }
+            }
+        }
+        const code = (0, _utils.generatePrefetchCode)(basePrefix, inputsForPrefetch, moduleIdsForPrefetch) + (customCode || '');
+        if (code) {
+            // HACK is this too naive to inject script code?
+            htmlStr = htmlStr.replace(/<\/head>/, `<script>${code}</script></head>`);
+        }
+        const htmlResult = ssr && await (0, _ssr.renderHtml)(config, 'build', pathStr, htmlStr, context);
+        if (htmlResult) {
+            const [htmlReadable] = htmlResult;
+            await (0, _promises.pipeline)(htmlReadable, _nodefs.default.createWriteStream(destFile));
+        } else {
+            _nodefs.default.writeFileSync(destFile, htmlStr);
+        }
+        return destFile;
+    }));
+    return {
+        htmlFiles
+    };
+};
+const emitVercelOutput = (config, clientBuildOutput, rscFiles, htmlFiles)=>{
+    const clientFiles = clientBuildOutput.output.map(({ fileName })=>_nodepath.default.join(config.rootDir, config.distDir, config.publicDir, fileName));
+    const srcDir = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir);
+    const dstDir = _nodepath.default.join(config.rootDir, config.distDir, '.vercel', 'output');
+    for (const file of [
+        ...clientFiles,
+        ...rscFiles,
+        ...htmlFiles
+    ]){
+        const dstFile = _nodepath.default.join(dstDir, 'static', _nodepath.default.relative(srcDir, file));
+        if (!_nodefs.default.existsSync(dstFile)) {
+            _nodefs.default.mkdirSync(_nodepath.default.dirname(dstFile), {
+                recursive: true
+            });
+            _nodefs.default.symlinkSync(_nodepath.default.relative(_nodepath.default.dirname(dstFile), file), dstFile);
+        }
+    }
+    // for serverless function
+    const serverlessDir = _nodepath.default.join(dstDir, 'functions', config.rscPath + '.func');
+    _nodefs.default.mkdirSync(_nodepath.default.join(serverlessDir, config.distDir), {
+        recursive: true
+    });
+    _nodefs.default.symlinkSync(_nodepath.default.relative(serverlessDir, _nodepath.default.join(config.rootDir, 'node_modules')), _nodepath.default.join(serverlessDir, 'node_modules'));
+    _nodefs.default.readdirSync(_nodepath.default.join(config.rootDir, config.distDir)).forEach((file)=>{
+        if ([
+            '.vercel'
+        ].includes(file)) {
+            return;
+        }
+        _nodefs.default.symlinkSync(_nodepath.default.relative(_nodepath.default.join(serverlessDir, config.distDir), _nodepath.default.join(config.rootDir, config.distDir, file)), _nodepath.default.join(serverlessDir, config.distDir, file));
+    });
+    const vcConfigJson = {
+        runtime: 'nodejs18.x',
+        handler: 'serve.js',
+        launcherType: 'Nodejs'
+    };
+    _nodefs.default.writeFileSync(_nodepath.default.join(serverlessDir, '.vc-config.json'), JSON.stringify(vcConfigJson, null, 2));
+    _nodefs.default.writeFileSync(_nodepath.default.join(serverlessDir, 'package.json'), JSON.stringify({
+        type: 'module'
+    }, null, 2));
+    _nodefs.default.writeFileSync(_nodepath.default.join(serverlessDir, 'serve.js'), `
+export default async function handler(req, res) {
+  const { rsc } = await import("waku");
+  rsc({ command: "start" })(req, res, () => {
+    throw new Error("not handled");
+  });
+}
+`);
+    const overrides = Object.fromEntries([
+        ...rscFiles.filter((file)=>!_nodepath.default.extname(file)).map((file)=>[
+                _nodepath.default.relative(srcDir, file),
+                {
+                    contentType: 'text/plain'
+                }
+            ]),
+        ...htmlFiles.filter((file)=>!_nodepath.default.extname(file)).map((file)=>[
+                _nodepath.default.relative(srcDir, file),
+                {
+                    contentType: 'text/html'
+                }
+            ])
+    ]);
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const routes = [
+        {
+            src: basePrefix + '(.*)',
+            dest: basePrefix
+        }
+    ];
+    const configJson = {
+        version: 3,
+        overrides,
+        routes
+    };
+    _nodefs.default.mkdirSync(dstDir, {
+        recursive: true
+    });
+    _nodefs.default.writeFileSync(_nodepath.default.join(dstDir, 'config.json'), JSON.stringify(configJson, null, 2));
+};
+const resolveFileName = (fname)=>{
+    for (const ext of [
+        '.js',
+        '.ts',
+        '.tsx',
+        '.jsx'
+    ]){
+        const resolvedName = fname.slice(0, -_nodepath.default.extname(fname).length) + ext;
+        if (_nodefs.default.existsSync(resolvedName)) {
+            return resolvedName;
+        }
+    }
+    return fname; // returning the default one
+};
+async function build(options) {
+    const config = await (0, _config.resolveConfig)();
+    const entriesFile = resolveFileName(_nodepath.default.join(config.rootDir, config.srcDir, config.entriesJs));
+    const distEntriesFile = resolveFileName(_nodepath.default.join(config.rootDir, config.distDir, config.entriesJs));
+    const { commonEntryFiles, clientEntryFiles, serverEntryFiles } = await analyzeEntries(entriesFile);
+    const serverBuildOutput = await buildServerBundle(config, entriesFile, distEntriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles);
+    const clientBuildOutput = await buildClientBundle(config, commonEntryFiles, clientEntryFiles, serverBuildOutput);
+    const { buildConfig, getClientModules, rscFiles } = await emitRscFiles(config);
+    const { htmlFiles } = await emitHtmlFiles(config, buildConfig, getClientModules, !!options?.ssr);
+    // https://vercel.com/docs/build-output-api/v3
+    emitVercelOutput(config, clientBuildOutput, rscFiles, htmlFiles);
+    await (0, _ssr.shutdown)();
+    await (0, _workerapi.shutdown)();
+}
diff --git a/dist/cjs/lib/config.js b/dist/cjs/lib/config.js
new file mode 100644
index 0000000000000000000000000000000000000000..91fea88014f155b53a86ed63e72dcd7d4d926aae
--- /dev/null
+++ b/dist/cjs/lib/config.js
@@ -0,0 +1,30 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "resolveConfig", {
+    enumerable: true,
+    get: function() {
+        return resolveConfig;
+    }
+});
+const DEFAULT_HTML_HEAD = `
+<meta charset="utf-8" />
+<meta name="viewport" content="width=device-width, initial-scale=1" />
+`.trim();
+async function resolveConfig(config) {
+    const resolvedConfig = {
+        basePath: '/',
+        srcDir: 'src',
+        distDir: 'dist',
+        publicDir: 'public',
+        assetsDir: 'assets',
+        indexHtml: 'index.html',
+        mainJs: 'main.tsx',
+        entriesJs: 'entries.js',
+        rscPath: 'RSC',
+        htmlHead: DEFAULT_HTML_HEAD,
+        ...config
+    };
+    return resolvedConfig;
+}
diff --git a/dist/cjs/lib/handlers/dev-worker-api.js b/dist/cjs/lib/handlers/dev-worker-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..da16d48315e83a318a97534571b184be694483a1
--- /dev/null
+++ b/dist/cjs/lib/handlers/dev-worker-api.js
@@ -0,0 +1,245 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    registerImportCallback: function() {
+        return registerImportCallback;
+    },
+    registerModuleCallback: function() {
+        return registerModuleCallback;
+    },
+    registerReloadCallback: function() {
+        return registerReloadCallback;
+    },
+    renderRscWithWorker: function() {
+        return renderRscWithWorker;
+    }
+});
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const messageCallbacks = new Map();
+let lastWorker;
+const getWorker = ()=>{
+    if (lastWorker) {
+        return lastWorker;
+    }
+    return lastWorker = new Promise((resolve, reject)=>{
+        Promise.all([
+            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:worker_threads"))).catch((e)=>{
+                throw e;
+            }),
+            Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:module"))).catch((e)=>{
+                throw e;
+            })
+        ]).then(([{ Worker }, { default: module }])=>{
+            const HAS_MODULE_REGISTER = typeof module.register === 'function';
+            const worker = new Worker(new URL('dev-worker-impl.js', require("url").pathToFileURL(__filename).toString()), {
+                execArgv: [
+                    ...HAS_MODULE_REGISTER ? [] : [
+                        '--experimental-loader',
+                        'waku/node-loader'
+                    ],
+                    '--conditions',
+                    'react-server'
+                ]
+            });
+            worker.on('message', (mesg)=>{
+                if ('id' in mesg) {
+                    messageCallbacks.get(mesg.id)?.(mesg);
+                }
+            });
+            resolve(worker);
+        }).catch((e)=>reject(e));
+    });
+};
+async function registerReloadCallback(fn) {
+    const worker = await getWorker();
+    const listener = (mesg)=>{
+        if (mesg.type === 'full-reload') {
+            fn(mesg.type);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+async function registerImportCallback(fn) {
+    const worker = await getWorker();
+    const listener = (mesg)=>{
+        if (mesg.type === 'hot-import') {
+            fn(mesg.source);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+async function registerModuleCallback(fn) {
+    const worker = await getWorker();
+    const listener = (mesg)=>{
+        if (mesg.type === 'module-import') {
+            fn(mesg.result);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+let nextId = 1;
+async function renderRscWithWorker(rr) {
+    const worker = await getWorker();
+    const id = nextId++;
+    const pipe = async ()=>{
+        if (rr.stream) {
+            const reader = rr.stream.getReader();
+            try {
+                let result;
+                do {
+                    result = await reader.read();
+                    if (result.value) {
+                        const buf = result.value;
+                        let mesg;
+                        if (buf instanceof ArrayBuffer) {
+                            mesg = {
+                                id,
+                                type: 'buf',
+                                buf,
+                                offset: 0,
+                                len: buf.byteLength
+                            };
+                        } else if (buf instanceof Uint8Array) {
+                            mesg = {
+                                id,
+                                type: 'buf',
+                                buf: buf.buffer,
+                                offset: buf.byteOffset,
+                                len: buf.byteLength
+                            };
+                        } else {
+                            throw new Error('Unexepected buffer type');
+                        }
+                        worker.postMessage(mesg, [
+                            mesg.buf
+                        ]);
+                    }
+                }while (!result.done)
+            } catch (err) {
+                const mesg = {
+                    id,
+                    type: 'err',
+                    err
+                };
+                worker.postMessage(mesg);
+            }
+        }
+        const mesg = {
+            id,
+            type: 'end'
+        };
+        worker.postMessage(mesg);
+    };
+    let started = false;
+    return new Promise((resolve, reject)=>{
+        let controller;
+        const stream = new ReadableStream({
+            start (c) {
+                controller = c;
+            }
+        });
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'start') {
+                if (!started) {
+                    started = true;
+                    resolve([
+                        stream,
+                        mesg.context
+                    ]);
+                } else {
+                    throw new Error('already started');
+                }
+            } else if (mesg.type === 'buf') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                controller.enqueue(new Uint8Array(mesg.buf, mesg.offset, mesg.len));
+            } else if (mesg.type === 'moduleId') {
+                rr.moduleIdCallback?.(mesg.moduleId);
+            } else if (mesg.type === 'end') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                controller.close();
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                if (!started) {
+                    reject(err);
+                } else {
+                    controller.error(err);
+                }
+                messageCallbacks.delete(id);
+            }
+        });
+        const { ssr: _removed, ...copiedConfig } = rr.config; // HACK type
+        const copied = {
+            ...rr,
+            config: copiedConfig
+        };
+        delete copied.stream;
+        delete copied.moduleIdCallback;
+        const mesg = {
+            id,
+            type: 'render',
+            hasModuleIdCallback: !!rr.moduleIdCallback,
+            ...copied
+        };
+        worker.postMessage(mesg);
+        pipe();
+    });
+}
diff --git a/dist/cjs/lib/handlers/dev-worker-impl.js b/dist/cjs/lib/handlers/dev-worker-impl.js
new file mode 100644
index 0000000000000000000000000000000000000000..97b23e5f1ca7d4fe7768d66295912d7f39b50cd3
--- /dev/null
+++ b/dist/cjs/lib/handlers/dev-worker-impl.js
@@ -0,0 +1,225 @@
+// This file can depend on Node.js
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+const _nodeurl = require("node:url");
+const _nodeworker_threads = require("node:worker_threads");
+const _nodehttp = require("node:http");
+const _vite = require("vite");
+const _path = require("../utils/path.js");
+const _utils = require("../renderers/utils.js");
+const _rscrenderer = require("../renderers/rsc-renderer.js");
+const _vitepluginnonjsresolve = require("../plugins/vite-plugin-nonjs-resolve.js");
+const _vitepluginrsctransform = require("../plugins/vite-plugin-rsc-transform.js");
+const _vitepluginrscreload = require("../plugins/vite-plugin-rsc-reload.js");
+const _vitepluginrscdelegate = require("../plugins/vite-plugin-rsc-delegate.js");
+const _mergeviteconfig = require("../utils/merge-vite-config.js");
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const { default: module } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:module")));
+const HAS_MODULE_REGISTER = typeof module.register === 'function';
+if (HAS_MODULE_REGISTER) {
+    module.register('waku/node-loader', (0, _nodeurl.pathToFileURL)('./'));
+}
+const controllerMap = new Map();
+const handleRender = async (mesg)=>{
+    const { id, type: _removed, hasModuleIdCallback, ...rest } = mesg;
+    const rr = rest;
+    try {
+        const stream = new ReadableStream({
+            start (controller) {
+                controllerMap.set(id, controller);
+            }
+        });
+        rr.stream = stream;
+        if (hasModuleIdCallback) {
+            rr.moduleIdCallback = (moduleId)=>{
+                const mesg = {
+                    id,
+                    type: 'moduleId',
+                    moduleId
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+            };
+        }
+        const readable = await (0, _rscrenderer.renderRsc)({
+            config: rr.config,
+            input: rr.input,
+            searchParams: new URLSearchParams(rr.searchParamsString),
+            method: rr.method,
+            context: rr.context,
+            body: rr.stream,
+            contentType: rr.contentType,
+            ...rr.moduleIdCallback ? {
+                moduleIdCallback: rr.moduleIdCallback
+            } : {},
+            isDev: true,
+            customImport: loadServerFile,
+            entries: await loadEntries(rr.config)
+        });
+        const mesg = {
+            id,
+            type: 'start',
+            context: rr.context
+        };
+        _nodeworker_threads.parentPort.postMessage(mesg);
+        (0, _utils.deepFreeze)(rr.context);
+        const writable = new WritableStream({
+            write (chunk) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                const mesg = {
+                    id,
+                    type: 'buf',
+                    buf: chunk.buffer,
+                    offset: chunk.byteOffset,
+                    len: chunk.byteLength
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg, [
+                    mesg.buf
+                ]);
+            },
+            close () {
+                const mesg = {
+                    id,
+                    type: 'end'
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+            }
+        });
+        readable.pipeTo(writable);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err
+        };
+        if ((0, _utils.hasStatusCode)(err)) {
+            mesg.statusCode = err.statusCode;
+        }
+        _nodeworker_threads.parentPort.postMessage(mesg);
+    }
+};
+const dummyServer = new _nodehttp.Server(); // FIXME we hope to avoid this hack
+const moduleImports = new Set();
+const mergedViteConfig = await (0, _mergeviteconfig.mergeUserViteConfig)({
+    plugins: [
+        (0, _vitepluginnonjsresolve.nonjsResolvePlugin)(),
+        (0, _vitepluginrsctransform.rscTransformPlugin)({
+            isBuild: false
+        }),
+        (0, _vitepluginrscreload.rscReloadPlugin)(moduleImports, (type)=>{
+            const mesg = {
+                type
+            };
+            _nodeworker_threads.parentPort.postMessage(mesg);
+        }),
+        (0, _vitepluginrscdelegate.rscDelegatePlugin)(moduleImports, (resultOrSource)=>{
+            const mesg = typeof resultOrSource === 'object' ? {
+                type: 'module-import',
+                result: resultOrSource
+            } : {
+                type: 'hot-import',
+                source: resultOrSource
+            };
+            _nodeworker_threads.parentPort.postMessage(mesg);
+        })
+    ],
+    // HACK to suppress 'Skipping dependency pre-bundling' warning
+    optimizeDeps: {
+        include: []
+    },
+    ssr: {
+        resolve: {
+            conditions: [
+                'react-server',
+                'workerd'
+            ],
+            externalConditions: [
+                'react-server',
+                'workerd'
+            ]
+        },
+        external: [
+            'react',
+            'react-server-dom-webpack'
+        ],
+        noExternal: /^(?!node:)/
+    },
+    appType: 'custom',
+    server: {
+        middlewareMode: true,
+        hmr: {
+            server: dummyServer
+        }
+    }
+});
+const vitePromise = (0, _vite.createServer)(mergedViteConfig).then(async (vite)=>{
+    await vite.ws.close();
+    return vite;
+});
+const loadServerFile = async (fileURL)=>{
+    const vite = await vitePromise;
+    return vite.ssrLoadModule((0, _path.fileURLToFilePath)(fileURL));
+};
+const loadEntries = async (config)=>{
+    const vite = await vitePromise;
+    const filePath = (0, _path.joinPath)(vite.config.root, config.srcDir, config.entriesJs);
+    return vite.ssrLoadModule(filePath);
+};
+_nodeworker_threads.parentPort.on('message', (mesg)=>{
+    if (mesg.type === 'render') {
+        handleRender(mesg);
+    } else if (mesg.type === 'buf') {
+        const controller = controllerMap.get(mesg.id);
+        controller.enqueue(new Uint8Array(mesg.buf, mesg.offset, mesg.len));
+    } else if (mesg.type === 'end') {
+        const controller = controllerMap.get(mesg.id);
+        controller.close();
+    } else if (mesg.type === 'err') {
+        const controller = controllerMap.get(mesg.id);
+        const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+        controller.error(err);
+    }
+});
diff --git a/dist/cjs/lib/handlers/handler-dev.js b/dist/cjs/lib/handlers/handler-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..166193267ef4defc5a86176d8c0f4e755a4037ec
--- /dev/null
+++ b/dist/cjs/lib/handlers/handler-dev.js
@@ -0,0 +1,229 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "createHandler", {
+    enumerable: true,
+    get: function() {
+        return createHandler;
+    }
+});
+const _nodestream = require("node:stream");
+const _vite = require("vite");
+const _pluginreact = /*#__PURE__*/ _interop_require_default(require("@vitejs/plugin-react"));
+const _nodeos = require("node:os");
+const _config = require("../config.js");
+const _path = require("../utils/path.js");
+const _stream = require("../utils/stream.js");
+const _htmlrenderer = require("../renderers/html-renderer.js");
+const _utils = require("../renderers/utils.js");
+const _devworkerapi = require("./dev-worker-api.js");
+const _vitepluginnonjsresolve = require("../plugins/vite-plugin-nonjs-resolve.js");
+const _patchreactrefresh = require("../plugins/patch-react-refresh.js");
+const _vitepluginrscindex = require("../plugins/vite-plugin-rsc-index.js");
+const _vitepluginrschmr = require("../plugins/vite-plugin-rsc-hmr.js");
+const _mergeviteconfig = require("../utils/merge-vite-config.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function createHandler(options) {
+    const { ssr, unstable_prehook, unstable_posthook } = options;
+    if (!unstable_prehook && unstable_posthook) {
+        throw new Error('prehook is required if posthook is provided');
+    }
+    const configPromise = (0, _config.resolveConfig)(options.config || {});
+    const vitePromise = configPromise.then(async (config)=>{
+        const mergedViteConfig = await (0, _mergeviteconfig.mergeUserViteConfig)({
+            base: config.basePath,
+            optimizeDeps: {
+                include: [
+                    'react-server-dom-webpack/client',
+                    'react',
+                    'react-dom'
+                ],
+                exclude: [
+                    'waku'
+                ]
+            },
+            plugins: [
+                (0, _vitepluginnonjsresolve.nonjsResolvePlugin)(),
+                (0, _patchreactrefresh.patchReactRefresh)((0, _pluginreact.default)()),
+                (0, _vitepluginrscindex.rscIndexPlugin)(config),
+                (0, _vitepluginrschmr.rscHmrPlugin)()
+            ],
+            ssr: {
+                external: [
+                    'waku'
+                ]
+            },
+            server: {
+                middlewareMode: true
+            }
+        });
+        const viteServer = await (0, _vite.createServer)(mergedViteConfig);
+        (0, _devworkerapi.registerReloadCallback)((type)=>viteServer.ws.send({
+                type
+            }));
+        (0, _devworkerapi.registerImportCallback)((source)=>(0, _vitepluginrschmr.hotImport)(viteServer, source));
+        (0, _devworkerapi.registerModuleCallback)((result)=>(0, _vitepluginrschmr.moduleImport)(viteServer, result));
+        return viteServer;
+    });
+    const entries = Promise.all([
+        configPromise,
+        vitePromise
+    ]).then(async ([config, vite])=>{
+        const filePath = (0, _path.joinPath)(vite.config.root, config.srcDir, config.entriesJs);
+        return vite.ssrLoadModule(filePath);
+    });
+    const transformIndexHtml = async (pathname)=>{
+        const vite = await vitePromise;
+        const encoder = new TextEncoder();
+        const decoder = new TextDecoder();
+        let headSent = false;
+        return new TransformStream({
+            transform (chunk, controller) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                if (!headSent) {
+                    headSent = true;
+                    let data = decoder.decode(chunk);
+                    // FIXME without removing async, Vite will move it
+                    // to the proxy cache, which breaks __WAKU_PUSH__.
+                    data = data.replace(/<script type="module" async>/, '<script>');
+                    return new Promise((resolve)=>{
+                        vite.transformIndexHtml(pathname, data).then((result)=>{
+                            controller.enqueue(encoder.encode(result));
+                            resolve();
+                        });
+                    });
+                }
+                controller.enqueue(chunk);
+            },
+            flush () {
+                if (!headSent) {
+                    throw new Error('head not yet sent');
+                }
+            }
+        });
+    };
+    return async (req, res, next)=>{
+        const [config, vite] = await Promise.all([
+            configPromise,
+            vitePromise
+        ]);
+        const basePrefix = config.basePath + config.rscPath + '/';
+        const handleError = (err)=>{
+            if ((0, _utils.hasStatusCode)(err)) {
+                res.setStatus(err.statusCode);
+            } else {
+                console.info('Cannot render RSC', err);
+                res.setStatus(500);
+            }
+            (0, _stream.endStream)(res.stream, String(err));
+        };
+        let context;
+        try {
+            context = unstable_prehook?.(req, res);
+        } catch (e) {
+            handleError(e);
+            return;
+        }
+        if (ssr) {
+            try {
+                const readable = await (0, _htmlrenderer.renderHtml)({
+                    config,
+                    pathname: req.url.pathname,
+                    searchParams: req.url.searchParams,
+                    htmlHead: `${config.htmlHead}
+<script src="/${config.srcDir}/${config.mainJs}" async type="module"></script>`,
+                    renderRscForHtml: async (input, searchParams)=>{
+                        const [readable, nextCtx] = await (0, _devworkerapi.renderRscWithWorker)({
+                            input,
+                            searchParamsString: searchParams.toString(),
+                            method: 'GET',
+                            contentType: undefined,
+                            config,
+                            context
+                        });
+                        context = nextCtx;
+                        return readable;
+                    },
+                    isDev: true,
+                    entries: await entries
+                });
+                if (readable) {
+                    unstable_posthook?.(req, res, context);
+                    res.setHeader('content-type', 'text/html; charset=utf-8');
+                    readable.pipeThrough(await transformIndexHtml(req.url.pathname)).pipeTo(res.stream);
+                    return;
+                }
+            } catch (e) {
+                handleError(e);
+                return;
+            }
+        }
+        if (req.url.pathname.startsWith(basePrefix)) {
+            const { method, contentType } = req;
+            if (method !== 'GET' && method !== 'POST') {
+                throw new Error(`Unsupported method '${method}'`);
+            }
+            try {
+                const input = (0, _utils.decodeInput)(req.url.pathname.slice(basePrefix.length));
+                const [readable, nextCtx] = await (0, _devworkerapi.renderRscWithWorker)({
+                    input,
+                    searchParamsString: req.url.searchParams.toString(),
+                    method,
+                    contentType,
+                    config,
+                    context,
+                    stream: req.stream
+                });
+                unstable_posthook?.(req, res, nextCtx);
+                readable.pipeTo(res.stream);
+            } catch (e) {
+                handleError(e);
+            }
+            return;
+        }
+        // HACK re-export "?v=..." URL to avoid dual module hazard.
+        const viteUrl = req.url.toString().slice(req.url.origin.length);
+        const fname = viteUrl.startsWith(config.basePath + '@fs/') ? viteUrl.slice(config.basePath.length + ((0, _nodeos.platform)() !== "win32" ? '@fs'.length : '@fs/'.length)) : (0, _path.joinPath)(vite.config.root, viteUrl);
+        for (const item of vite.moduleGraph.idToModuleMap.values()){
+            if (item.file === fname && item.url !== viteUrl && !item.url.includes('?html-proxy')) {
+                res.setHeader('Content-Type', 'application/javascript');
+                res.setStatus(200);
+                (0, _stream.endStream)(res.stream, `export * from "${item.url}";`);
+                return;
+            }
+        }
+        const viteReq = _nodestream.Readable.fromWeb(req.stream);
+        viteReq.method = req.method;
+        viteReq.url = viteUrl;
+        viteReq.headers = {
+            'content-type': req.contentType
+        };
+        const viteRes = _nodestream.Writable.fromWeb(res.stream);
+        Object.defineProperty(viteRes, 'statusCode', {
+            set (code) {
+                res.setStatus(code);
+            }
+        });
+        const headers = new Map();
+        viteRes.setHeader = (name, value)=>{
+            headers.set(name, value);
+            res.setHeader(name, value);
+        };
+        viteRes.getHeader = (name)=>headers.get(name);
+        viteRes.writeHead = (code, headers)=>{
+            res.setStatus(code);
+            for (const [name, value] of Object.entries(headers || {})){
+                viteRes.setHeader(name, value);
+            }
+        };
+        vite.middlewares(viteReq, viteRes, next);
+        return;
+    };
+}
diff --git a/dist/cjs/lib/handlers/handler-prd.js b/dist/cjs/lib/handlers/handler-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..d1defb1b40f358b545f17a0864edfd58cc7f927f
--- /dev/null
+++ b/dist/cjs/lib/handlers/handler-prd.js
@@ -0,0 +1,107 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "createHandler", {
+    enumerable: true,
+    get: function() {
+        return createHandler;
+    }
+});
+const _config = require("../config.js");
+const _stream = require("../utils/stream.js");
+const _htmlrenderer = require("../renderers/html-renderer.js");
+const _utils = require("../renderers/utils.js");
+const _rscrenderer = require("../renderers/rsc-renderer.js");
+function createHandler(options) {
+    const { config, ssr, unstable_prehook, unstable_posthook, entries } = options;
+    if (!unstable_prehook && unstable_posthook) {
+        throw new Error('prehook is required if posthook is provided');
+    }
+    const configPromise = (0, _config.resolveConfig)(config || {});
+    return async (req, res, next)=>{
+        const config = await configPromise;
+        const basePrefix = config.basePath + config.rscPath + '/';
+        const handleError = (err)=>{
+            if ((0, _utils.hasStatusCode)(err)) {
+                res.setStatus(err.statusCode);
+            } else {
+                console.info('Cannot render RSC', err);
+                res.setStatus(500);
+            }
+            (0, _stream.endStream)(res.stream);
+        };
+        let context;
+        try {
+            context = unstable_prehook?.(req, res);
+        } catch (e) {
+            handleError(e);
+            return;
+        }
+        if (ssr) {
+            try {
+                const resolvedEntries = await entries;
+                const { loadHtmlHead } = resolvedEntries;
+                const readable = await (0, _htmlrenderer.renderHtml)({
+                    config,
+                    pathname: req.url.pathname,
+                    searchParams: req.url.searchParams,
+                    htmlHead: loadHtmlHead(req.url.pathname),
+                    renderRscForHtml: (input, searchParams)=>(0, _rscrenderer.renderRsc)({
+                            entries: resolvedEntries,
+                            config,
+                            input,
+                            searchParams,
+                            method: 'GET',
+                            context,
+                            isDev: false
+                        }),
+                    isDev: false,
+                    entries: resolvedEntries,
+                    isBuild: false
+                });
+                if (readable) {
+                    unstable_posthook?.(req, res, context);
+                    (0, _utils.deepFreeze)(context);
+                    res.setHeader('content-type', 'text/html; charset=utf-8');
+                    readable.pipeTo(res.stream);
+                    return;
+                }
+            } catch (e) {
+                handleError(e);
+                return;
+            }
+        }
+        if (req.url.pathname.startsWith(basePrefix)) {
+            const { method, contentType } = req;
+            if (method !== 'GET' && method !== 'POST') {
+                throw new Error(`Unsupported method '${method}'`);
+            }
+            const { skipRenderRsc } = await entries;
+            try {
+                const input = (0, _utils.decodeInput)(req.url.pathname.slice(basePrefix.length));
+                if (!skipRenderRsc(input)) {
+                    const readable = await (0, _rscrenderer.renderRsc)({
+                        config,
+                        input,
+                        searchParams: req.url.searchParams,
+                        method,
+                        context,
+                        body: req.stream,
+                        contentType,
+                        isDev: false,
+                        entries: await entries
+                    });
+                    unstable_posthook?.(req, res, context);
+                    (0, _utils.deepFreeze)(context);
+                    readable.pipeTo(res.stream);
+                    return;
+                }
+            } catch (e) {
+                handleError(e);
+                return;
+            }
+        }
+        next();
+    };
+}
diff --git a/dist/cjs/lib/handlers/types.js b/dist/cjs/lib/handlers/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..b62a6d552c31f18232522abd4007b7f4258d2b26
--- /dev/null
+++ b/dist/cjs/lib/handlers/types.js
@@ -0,0 +1,4 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
diff --git a/dist/cjs/lib/middleware/connect-dev.js b/dist/cjs/lib/middleware/connect-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..7fd436a9b2d5cd485de82c4582fc1541032ca188
--- /dev/null
+++ b/dist/cjs/lib/middleware/connect-dev.js
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "connectMiddleware", {
+    enumerable: true,
+    get: function() {
+        return connectMiddleware;
+    }
+});
+const _connectutils = require("./connect-utils.js");
+const _handlerdev = require("../handlers/handler-dev.js");
+function connectMiddleware(...args) {
+    return (0, _connectutils.connectWrapper)((0, _handlerdev.createHandler)(...args));
+}
diff --git a/dist/cjs/lib/middleware/connect-prd.js b/dist/cjs/lib/middleware/connect-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..3b4789e670eba0c94dc56976f57e020ad5318197
--- /dev/null
+++ b/dist/cjs/lib/middleware/connect-prd.js
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "connectMiddleware", {
+    enumerable: true,
+    get: function() {
+        return connectMiddleware;
+    }
+});
+const _connectutils = require("./connect-utils.js");
+const _handlerprd = require("../handlers/handler-prd.js");
+function connectMiddleware(...args) {
+    return (0, _connectutils.connectWrapper)((0, _handlerprd.createHandler)(...args));
+}
diff --git a/dist/cjs/lib/middleware/connect-utils.js b/dist/cjs/lib/middleware/connect-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..44f0cde0b52e4a3efd9240d574fe5e8941507f90
--- /dev/null
+++ b/dist/cjs/lib/middleware/connect-utils.js
@@ -0,0 +1,73 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "connectWrapper", {
+    enumerable: true,
+    get: function() {
+        return connectWrapper;
+    }
+});
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const connectWrapper = (m)=>{
+    return async (connectReq, connectRes, next)=>{
+        const { Readable, Writable } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:stream"))).catch((e)=>{
+            // XXX explicit catch to avoid bundle time error
+            throw e;
+        });
+        const req = {
+            stream: Readable.toWeb(connectReq),
+            method: connectReq.method || '',
+            url: new URL(connectReq.url || '', `http://${connectReq.headers.host}`),
+            contentType: connectReq.headers['content-type'],
+            orig: connectReq
+        };
+        const res = {
+            stream: Writable.toWeb(connectRes),
+            setStatus: (code)=>connectRes.statusCode = code,
+            setHeader: (name, value)=>connectRes.setHeader(name, value),
+            orig: connectRes
+        };
+        m(req, res, next);
+    };
+};
diff --git a/dist/cjs/lib/middleware/hono-dev.js b/dist/cjs/lib/middleware/hono-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..9332cc0e76f66d12634c3d9c89f21a88d22e7967
--- /dev/null
+++ b/dist/cjs/lib/middleware/hono-dev.js
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "honoMiddleware", {
+    enumerable: true,
+    get: function() {
+        return honoMiddleware;
+    }
+});
+const _honoutils = require("./hono-utils.js");
+const _handlerdev = require("../handlers/handler-dev.js");
+function honoMiddleware(...args) {
+    return (0, _honoutils.honoWrapper)((0, _handlerdev.createHandler)(...args));
+}
diff --git a/dist/cjs/lib/middleware/hono-prd.js b/dist/cjs/lib/middleware/hono-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..6191682b9fb39bf9711690306bee8596897c55b1
--- /dev/null
+++ b/dist/cjs/lib/middleware/hono-prd.js
@@ -0,0 +1,15 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "honoMiddleware", {
+    enumerable: true,
+    get: function() {
+        return honoMiddleware;
+    }
+});
+const _honoutils = require("./hono-utils.js");
+const _handlerprd = require("../handlers/handler-prd.js");
+function honoMiddleware(...args) {
+    return (0, _honoutils.honoWrapper)((0, _handlerprd.createHandler)(...args));
+}
diff --git a/dist/cjs/lib/middleware/hono-utils.js b/dist/cjs/lib/middleware/hono-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..56833045459a67015571db60b6a38431db77963e
--- /dev/null
+++ b/dist/cjs/lib/middleware/hono-utils.js
@@ -0,0 +1,70 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "honoWrapper", {
+    enumerable: true,
+    get: function() {
+        return honoWrapper;
+    }
+});
+const createEmptyReadableStream = ()=>new ReadableStream({
+        start (controller) {
+            controller.close();
+        }
+    });
+const createStreamPair = (callback)=>{
+    let controller;
+    const readable = new ReadableStream({
+        start (c) {
+            controller = c;
+        },
+        cancel () {
+            controller = undefined;
+        }
+    });
+    let hasData = false;
+    const writable = new WritableStream({
+        write (chunk) {
+            if (!controller) {
+                return;
+            }
+            controller.enqueue(chunk);
+            if (!hasData) {
+                hasData = true;
+                callback(readable);
+            }
+        },
+        close () {
+            if (!controller) {
+                return;
+            }
+            controller.close();
+            if (!hasData) {
+                callback(null);
+            }
+        }
+    });
+    return writable;
+};
+const honoWrapper = (m)=>{
+    return (c, next)=>new Promise((resolve)=>{
+            const req = {
+                stream: c.req.raw.body || createEmptyReadableStream(),
+                method: c.req.method,
+                url: new URL(c.req.url),
+                contentType: c.req.header('content-type'),
+                c
+            };
+            const writable = createStreamPair((readable)=>{
+                resolve(c.body(readable));
+            });
+            const res = {
+                stream: writable,
+                setStatus: (code)=>c.status(code),
+                setHeader: (name, value)=>c.header(name, value),
+                c
+            };
+            m(req, res, ()=>next().then(resolve));
+        });
+};
diff --git a/dist/cjs/lib/middleware/rsc/ssr.js b/dist/cjs/lib/middleware/rsc/ssr.js
new file mode 100644
index 0000000000000000000000000000000000000000..032180bd4b98e016c77e499393817957109859ab
--- /dev/null
+++ b/dist/cjs/lib/middleware/rsc/ssr.js
@@ -0,0 +1,359 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    loadServerFile: function() {
+        return loadServerFile;
+    },
+    renderHtml: function() {
+        return renderHtml;
+    },
+    shutdown: function() {
+        return shutdown;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = /*#__PURE__*/ _interop_require_default(require("node:fs"));
+const _nodeurl = /*#__PURE__*/ _interop_require_default(require("node:url"));
+const _nodecrypto = /*#__PURE__*/ _interop_require_default(require("node:crypto"));
+const _nodestream = require("node:stream");
+const _nodebuffer = require("node:buffer");
+const _nodehttp = require("node:http");
+const _react = require("react");
+const _server = /*#__PURE__*/ _interop_require_default(require("react-dom/server"));
+const _clientnodeunbundled = /*#__PURE__*/ _interop_require_default(require("react-server-dom-webpack/client.node.unbundled"));
+const _config = require("../../config.js");
+const _workerapi = require("./worker-api.js");
+const _utils = require("./utils.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+// eslint-disable-next-line import/no-named-as-default-member
+const { renderToPipeableStream } = _server.default;
+const { createFromNodeStream } = _clientnodeunbundled.default;
+let lastViteServer;
+const getViteServer = async ()=>{
+    if (lastViteServer) {
+        return lastViteServer;
+    }
+    const dummyServer = new _nodehttp.Server(); // FIXME we hope to avoid this hack
+    const { createServer: viteCreateServer } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("vite")));
+    const { nonjsResolvePlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../vite-plugin/nonjs-resolve-plugin.js")));
+    const viteServer = await viteCreateServer({
+        ...(0, _config.viteInlineConfig)(),
+        plugins: [
+            nonjsResolvePlugin()
+        ],
+        ssr: {
+            external: [
+                'waku'
+            ]
+        },
+        appType: 'custom',
+        server: {
+            middlewareMode: true,
+            hmr: {
+                server: dummyServer
+            }
+        }
+    });
+    await viteServer.watcher.close(); // TODO watch: null
+    await viteServer.ws.close();
+    lastViteServer = viteServer;
+    return viteServer;
+};
+const shutdown = async ()=>{
+    if (lastViteServer) {
+        await lastViteServer.close();
+        lastViteServer = undefined;
+    }
+};
+const loadServerFile = async (fname, command)=>{
+    if (command !== 'dev') {
+        return Promise.resolve(fname).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p)));
+    }
+    const vite = await getViteServer();
+    return vite.ssrLoadModule(fname);
+};
+// FIXME this is very hacky
+const createTranspiler = (cleanupFns)=>{
+    return (filePath, name)=>{
+        const temp = _nodepath.default.resolve(`.temp-${_nodecrypto.default.randomBytes(8).toString('hex')}.js`);
+        const code = `
+const { loadServerFile } = await import('${require("url").pathToFileURL(__filename).toString()}');
+const { ${name} } = await loadServerFile('${_nodeurl.default.pathToFileURL(filePath).toString().slice('file://'.length)}', 'dev');
+export { ${name} }
+`;
+        _nodefs.default.writeFileSync(temp, code);
+        cleanupFns.add(()=>_nodefs.default.unlinkSync(temp));
+        return temp;
+    };
+};
+// FIXME this is a hack. don't know why we need this. possible Vite bug?
+const getWakuClient = (cleanupFns)=>{
+    const temp = _nodepath.default.resolve(`.temp-${_nodecrypto.default.randomBytes(8).toString('hex')}.js`);
+    const code = `export * from 'waku/client';`;
+    _nodefs.default.writeFileSync(temp, code);
+    cleanupFns.add(()=>_nodefs.default.unlinkSync(temp));
+    return temp;
+};
+const getEntriesFile = (config, command)=>{
+    const filePath = _nodepath.default.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir, config.entriesJs);
+    return command === 'dev' ? filePath : _nodeurl.default.pathToFileURL(filePath).toString();
+};
+const fakeFetchCode = `
+Promise.resolve({
+  ok: true,
+  body: new ReadableStream({
+    start(c) {
+      const f = (s) => new TextEncoder().encode(decodeURI(s));
+      globalThis.__WAKU_PUSH__ = (s) => s ? c.enqueue(f(s)) : c.close();
+    }
+  })
+})
+`.split('\n').map((line)=>line.trim()).join('');
+const injectRscPayload = (stream, input)=>{
+    const chunks = [];
+    let closed = false;
+    let notify;
+    const copied = new _nodestream.PassThrough();
+    stream.on('data', (chunk)=>{
+        chunks.push(chunk);
+        notify?.();
+        copied.write(chunk);
+    });
+    stream.on('end', ()=>{
+        closed = true;
+        notify?.();
+        copied.end();
+    });
+    const modifyHead = (data)=>{
+        const matchPrefetched = data.match(// HACK This is very brittle
+        /(.*)<script>\nglobalThis\.__WAKU_PREFETCHED__ = {\n(.*?)\n};(.*)/s);
+        let prefetchedLines = [];
+        if (matchPrefetched) {
+            prefetchedLines = matchPrefetched[2].split('\n');
+            data = matchPrefetched[1] + '<script>\n' + matchPrefetched[3];
+        }
+        const closingHeadIndex = data.indexOf('</head>');
+        if (closingHeadIndex === -1) {
+            throw new Error('closing head not found');
+        }
+        data = data.slice(0, closingHeadIndex) + `
+<script>
+globalThis.__WAKU_PREFETCHED__ = {
+${prefetchedLines.filter((line)=>!line.startsWith(`  '${input}':`)).join('\n')}
+  '${input}': ${fakeFetchCode},
+};
+globalThis.__WAKU_SSR_ENABLED__ = true;
+</script>
+` + data.slice(closingHeadIndex);
+        return data;
+    };
+    const interleave = (preamble, intermediate, postamble)=>{
+        let preambleSent = false;
+        let closedSent = false;
+        return new _nodestream.Transform({
+            transform (chunk, encoding, callback) {
+                if (encoding !== 'buffer') {
+                    throw new Error('Unknown encoding');
+                }
+                if (!preambleSent) {
+                    const data = chunk.toString();
+                    preambleSent = true;
+                    callback(null, _nodebuffer.Buffer.concat([
+                        _nodebuffer.Buffer.from(modifyHead(preamble)),
+                        _nodebuffer.Buffer.from(data),
+                        _nodebuffer.Buffer.from(intermediate)
+                    ]));
+                    notify = ()=>{
+                        const scripts = chunks.splice(0).map((chunk)=>_nodebuffer.Buffer.from(`
+<script>globalThis.__WAKU_PUSH__("${encodeURI(chunk.toString())}")</script>`));
+                        if (closed) {
+                            closedSent = true;
+                            scripts.push(_nodebuffer.Buffer.from(`
+<script>globalThis.__WAKU_PUSH__()</script>`));
+                        }
+                        this.push(_nodebuffer.Buffer.concat(scripts));
+                    };
+                    notify();
+                    return;
+                }
+                callback(null, chunk);
+            },
+            final (callback) {
+                if (!preambleSent) {
+                    this.push(_nodebuffer.Buffer.from(preamble));
+                    this.push(_nodebuffer.Buffer.from(intermediate));
+                }
+                if (!closedSent) {
+                    const notifyOrig = notify;
+                    notify = ()=>{
+                        notifyOrig?.();
+                        if (closedSent) {
+                            this.push(_nodebuffer.Buffer.from(postamble));
+                            callback();
+                        }
+                    };
+                } else {
+                    this.push(_nodebuffer.Buffer.from(postamble));
+                    callback();
+                }
+            }
+        });
+    };
+    return [
+        copied,
+        interleave
+    ];
+};
+// HACK for now, do we want to use HTML parser?
+const rectifyHtml = ()=>{
+    const pending = [];
+    return new _nodestream.Transform({
+        transform (chunk, encoding, callback) {
+            if (encoding !== 'buffer') {
+                throw new Error('Unknown encoding');
+            }
+            pending.push(chunk);
+            if (/<\/\w+>$/.test(chunk.toString())) {
+                callback(null, _nodebuffer.Buffer.concat(pending.splice(0)));
+            } else {
+                callback();
+            }
+        },
+        final (callback) {
+            if (!pending.length) {
+                this.push(_nodebuffer.Buffer.concat(pending.splice(0)));
+            }
+            callback();
+        }
+    });
+};
+const renderHtml = async (config, command, pathStr, htmlStr, context)=>{
+    const entriesFile = getEntriesFile(config, command);
+    const { default: { getSsrConfig }, resolveClientPath } = await loadServerFile(entriesFile, command);
+    const ssrConfig = await getSsrConfig?.(pathStr);
+    if (!ssrConfig) {
+        return null;
+    }
+    let pipeable;
+    let nextCtx;
+    try {
+        [pipeable, nextCtx] = await (0, _workerapi.renderRSC)({
+            input: ssrConfig.input,
+            method: 'GET',
+            headers: {},
+            command,
+            context
+        });
+    } catch (e) {
+        if ((0, _utils.hasStatusCode)(e) && e.statusCode === 404) {
+            return null;
+        }
+        throw e;
+    }
+    const { splitHTML } = config.ssr;
+    const cleanupFns = new Set();
+    const transpile = command === 'dev' ? createTranspiler(cleanupFns) : undefined;
+    const moduleMap = new Proxy({}, {
+        get (_target, filePath) {
+            return new Proxy({}, {
+                get (_target, name) {
+                    const file = filePath.slice(config.basePath.length);
+                    if (command === 'dev') {
+                        const filePath = file.startsWith('@fs/') ? file.slice(3) : _nodepath.default.join(config.rootDir, config.srcDir, file);
+                        const specifier = _nodeurl.default.pathToFileURL(transpile(filePath, name)).toString();
+                        return {
+                            specifier,
+                            name
+                        };
+                    }
+                    const origFile = resolveClientPath?.(_nodepath.default.join(config.rootDir, config.distDir, file), true);
+                    if (origFile && !origFile.startsWith(_nodepath.default.join(config.rootDir, config.srcDir))) {
+                        return {
+                            specifier: _nodeurl.default.pathToFileURL(origFile).toString(),
+                            name
+                        };
+                    }
+                    return {
+                        specifier: _nodeurl.default.pathToFileURL(_nodepath.default.join(config.rootDir, config.distDir, file)).toString(),
+                        name
+                    };
+                }
+            });
+        }
+    });
+    const [copied, interleave] = injectRscPayload(pipeable, ssrConfig.input);
+    const elements = createFromNodeStream(copied, {
+        moduleMap
+    });
+    const { ServerRoot } = await loadServerFile(getWakuClient(cleanupFns), command);
+    const readable = renderToPipeableStream((0, _react.createElement)(ServerRoot, {
+        elements
+    }, ssrConfig.unstable_render()), {
+        onAllReady: ()=>{
+            cleanupFns.forEach((fn)=>fn());
+            cleanupFns.clear();
+        },
+        onError (err) {
+            cleanupFns.forEach((fn)=>fn());
+            cleanupFns.clear();
+            console.error(err);
+        }
+    }).pipe(rectifyHtml()).pipe(interleave(...splitHTML(htmlStr)));
+    return [
+        readable,
+        nextCtx
+    ];
+};
diff --git a/dist/cjs/lib/middleware/rsc/utils.js b/dist/cjs/lib/middleware/rsc/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..db31cb19b60708223821ddd811d7b7ef5dd7a2ca
--- /dev/null
+++ b/dist/cjs/lib/middleware/rsc/utils.js
@@ -0,0 +1,74 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    codeToInject: function() {
+        return codeToInject;
+    },
+    decodeInput: function() {
+        return decodeInput;
+    },
+    deepFreeze: function() {
+        return deepFreeze;
+    },
+    encodeInput: function() {
+        return encodeInput;
+    },
+    generatePrefetchCode: function() {
+        return generatePrefetchCode;
+    },
+    hasStatusCode: function() {
+        return hasStatusCode;
+    }
+});
+const encodeInput = (input)=>{
+    if (input === '') {
+        return '_';
+    } else if (!input.startsWith('_')) {
+        return input;
+    }
+    throw new Error("Input must not start with '_'");
+};
+const decodeInput = (encodedInput)=>{
+    if (encodedInput === '_') {
+        return '';
+    } else if (!encodedInput.startsWith('_')) {
+        return encodedInput;
+    }
+    throw new Error('Invalid encoded input');
+};
+const hasStatusCode = (x)=>typeof x?.statusCode === 'number';
+const codeToInject = `
+globalThis.__waku_module_cache__ = new Map();
+globalThis.__webpack_chunk_load__ = (id) => import(id).then((m) => globalThis.__waku_module_cache__.set(id, m));
+globalThis.__webpack_require__ = (id) => globalThis.__waku_module_cache__.get(id);`;
+const generatePrefetchCode = (basePrefix, inputs, moduleIds)=>{
+    const inputsArray = Array.from(inputs);
+    let code = '';
+    if (inputsArray.length) {
+        code += `
+globalThis.__WAKU_PREFETCHED__ = {
+${inputsArray.map((input)=>`  '${input}': fetch('${basePrefix}${encodeInput(input)}')`).join(',\n')}
+};`;
+    }
+    for (const moduleId of moduleIds){
+        code += `
+import('${moduleId}');`;
+    }
+    return code;
+};
+const deepFreeze = (x)=>{
+    if (typeof x === 'object' && x !== null) {
+        Object.freeze(x);
+        for (const value of Object.values(x)){
+            deepFreeze(value);
+        }
+    }
+};
diff --git a/dist/cjs/lib/middleware/rsc/worker-api.js b/dist/cjs/lib/middleware/rsc/worker-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..fb454784be32e320069781c794eb171cb4c9a10d
--- /dev/null
+++ b/dist/cjs/lib/middleware/rsc/worker-api.js
@@ -0,0 +1,181 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    getBuildConfigRSC: function() {
+        return getBuildConfigRSC;
+    },
+    registerImportCallback: function() {
+        return registerImportCallback;
+    },
+    registerReloadCallback: function() {
+        return registerReloadCallback;
+    },
+    renderRSC: function() {
+        return renderRSC;
+    },
+    shutdown: function() {
+        return shutdown;
+    }
+});
+const _nodestream = require("node:stream");
+const _nodebuffer = require("node:buffer");
+const _nodeworker_threads = require("node:worker_threads");
+const IS_NODE_18 = Number(process.versions.node.split('.')[0]) < 20;
+const worker = new _nodeworker_threads.Worker(new URL('worker-impl.js', require("url").pathToFileURL(__filename).toString()), {
+    execArgv: [
+        ...IS_NODE_18 ? [
+            '--experimental-loader',
+            'waku/node-loader',
+            '--experimental-loader',
+            'react-server-dom-webpack/node-loader'
+        ] : [],
+        '--conditions',
+        'react-server'
+    ]
+});
+const messageCallbacks = new Map();
+worker.on('message', (mesg)=>{
+    if ('id' in mesg) {
+        messageCallbacks.get(mesg.id)?.(mesg);
+    }
+});
+function registerReloadCallback(fn) {
+    const listener = (mesg)=>{
+        if (mesg.type === 'full-reload') {
+            fn(mesg.type);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+function registerImportCallback(fn) {
+    const listener = (mesg)=>{
+        if (mesg.type === 'hot-import') {
+            fn(mesg.source);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+function shutdown() {
+    return new Promise((resolve)=>{
+        worker.on('close', resolve);
+        const mesg = {
+            type: 'shutdown'
+        };
+        worker.postMessage(mesg);
+    });
+}
+let nextId = 1;
+function renderRSC(rr) {
+    const id = nextId++;
+    const pipe = async ()=>{
+        if (rr.stream) {
+            rr.stream.on('error', (err)=>{
+                const mesg = {
+                    id,
+                    type: 'err',
+                    err
+                };
+                worker.postMessage(mesg);
+            });
+            for await (const chunk of rr.stream){
+                const buffer = chunk;
+                const mesg = {
+                    id,
+                    type: 'buf',
+                    buf: buffer.buffer,
+                    offset: buffer.byteOffset,
+                    len: buffer.length
+                };
+                worker.postMessage(mesg);
+            }
+        }
+        const mesg = {
+            id,
+            type: 'end'
+        };
+        worker.postMessage(mesg);
+    };
+    let started = false;
+    return new Promise((resolve, reject)=>{
+        const passthrough = new _nodestream.PassThrough();
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'start') {
+                if (!started) {
+                    started = true;
+                    resolve([
+                        passthrough,
+                        mesg.context
+                    ]);
+                } else {
+                    throw new Error('already started');
+                }
+            } else if (mesg.type === 'buf') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                passthrough.write(_nodebuffer.Buffer.from(mesg.buf, mesg.offset, mesg.len));
+            } else if (mesg.type === 'moduleId') {
+                rr.moduleIdCallback?.(mesg.moduleId);
+            } else if (mesg.type === 'end') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                passthrough.end();
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                if (!started) {
+                    reject(err);
+                } else {
+                    passthrough.destroy(err);
+                }
+                messageCallbacks.delete(id);
+            }
+        });
+        const copied = {
+            ...rr
+        };
+        delete copied.stream;
+        delete copied.moduleIdCallback;
+        const mesg = {
+            id,
+            type: 'render',
+            hasModuleIdCallback: !!rr.moduleIdCallback,
+            ...copied
+        };
+        worker.postMessage(mesg);
+        pipe();
+    });
+}
+function getBuildConfigRSC() {
+    return new Promise((resolve, reject)=>{
+        const id = nextId++;
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'buildConfig') {
+                resolve(mesg.output);
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                reject(mesg.err);
+                messageCallbacks.delete(id);
+            }
+        });
+        const mesg = {
+            id,
+            type: 'getBuildConfig'
+        };
+        worker.postMessage(mesg);
+    });
+}
diff --git a/dist/cjs/lib/middleware/rsc/worker-impl.js b/dist/cjs/lib/middleware/rsc/worker-impl.js
new file mode 100644
index 0000000000000000000000000000000000000000..e2dd034e1e4529490ee108f4e7e9d9620bcf888b
--- /dev/null
+++ b/dist/cjs/lib/middleware/rsc/worker-impl.js
@@ -0,0 +1,406 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodeurl = /*#__PURE__*/ _interop_require_default(require("node:url"));
+const _nodeworker_threads = require("node:worker_threads");
+const _nodestream = require("node:stream");
+const _promises = require("node:stream/promises");
+const _nodehttp = require("node:http");
+const _nodebuffer = require("node:buffer");
+const _server = /*#__PURE__*/ _interop_require_default(require("react-server-dom-webpack/server"));
+const _busboy = /*#__PURE__*/ _interop_require_default(require("busboy"));
+const _config = require("../../config.js");
+const _utils = require("./utils.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const { renderToPipeableStream, decodeReply, decodeReplyFromBusboy } = _server.default;
+const IS_NODE_20 = Number(process.versions.node.split('.')[0]) >= 20;
+if (IS_NODE_20) {
+    const { default: { register } } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:module")));
+    register('waku/node-loader', _nodeurl.default.pathToFileURL('./'));
+    register('react-server-dom-webpack/node-loader', _nodeurl.default.pathToFileURL('./'));
+}
+const streamMap = new Map();
+const handleRender = async (mesg)=>{
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const { id, type, hasModuleIdCallback, ...rest } = mesg;
+    const rr = rest;
+    try {
+        const stream = new _nodestream.PassThrough();
+        streamMap.set(id, stream);
+        rr.stream = stream;
+        if (hasModuleIdCallback) {
+            rr.moduleIdCallback = (moduleId)=>{
+                const mesg = {
+                    id,
+                    type: 'moduleId',
+                    moduleId
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+            };
+        }
+        const pipeable = await renderRSC(rr);
+        const mesg = {
+            id,
+            type: 'start',
+            context: rr.context
+        };
+        _nodeworker_threads.parentPort.postMessage(mesg);
+        (0, _utils.deepFreeze)(rr.context);
+        const writable = new _nodestream.Writable({
+            write (chunk, encoding, callback) {
+                if (encoding !== 'buffer') {
+                    throw new Error('Unknown encoding');
+                }
+                const buffer = chunk;
+                const mesg = {
+                    id,
+                    type: 'buf',
+                    buf: buffer.buffer,
+                    offset: buffer.byteOffset,
+                    len: buffer.length
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg, [
+                    mesg.buf
+                ]);
+                callback();
+            },
+            final (callback) {
+                const mesg = {
+                    id,
+                    type: 'end'
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+                callback();
+            }
+        });
+        pipeable.pipe(writable);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err
+        };
+        if ((0, _utils.hasStatusCode)(err)) {
+            mesg.statusCode = err.statusCode;
+        }
+        _nodeworker_threads.parentPort.postMessage(mesg);
+    }
+};
+const handleGetBuildConfig = async (mesg)=>{
+    const { id } = mesg;
+    try {
+        const output = await getBuildConfigRSC();
+        const mesg = {
+            id,
+            type: 'buildConfig',
+            output
+        };
+        _nodeworker_threads.parentPort.postMessage(mesg);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err
+        };
+        _nodeworker_threads.parentPort.postMessage(mesg);
+    }
+};
+let lastViteServer;
+const getViteServer = async ()=>{
+    if (lastViteServer) {
+        return lastViteServer;
+    }
+    const dummyServer = new _nodehttp.Server(); // FIXME we hope to avoid this hack
+    const { createServer: viteCreateServer } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("vite")));
+    const { rscTransformPlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../vite-plugin/rsc-transform-plugin.js")));
+    const { rscReloadPlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../vite-plugin/rsc-reload-plugin.js")));
+    const { rscDelegatePlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../../vite-plugin/rsc-delegate-plugin.js")));
+    const viteServer = await viteCreateServer({
+        ...(0, _config.viteInlineConfig)(),
+        plugins: [
+            rscTransformPlugin(),
+            rscReloadPlugin((type)=>{
+                const mesg = {
+                    type
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+            }),
+            rscDelegatePlugin((source)=>{
+                const mesg = {
+                    type: 'hot-import',
+                    source
+                };
+                _nodeworker_threads.parentPort.postMessage(mesg);
+            })
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server'
+                ],
+                externalConditions: [
+                    'react-server'
+                ]
+            },
+            external: [
+                'react',
+                'react-server-dom-webpack',
+                'waku'
+            ],
+            noExternal: /^(?!node:)/
+        },
+        appType: 'custom',
+        server: {
+            middlewareMode: true,
+            hmr: {
+                server: dummyServer
+            }
+        }
+    });
+    await viteServer.ws.close();
+    lastViteServer = viteServer;
+    return viteServer;
+};
+const shutdown = async ()=>{
+    if (lastViteServer) {
+        await lastViteServer.close();
+        lastViteServer = undefined;
+    }
+    _nodeworker_threads.parentPort.close();
+};
+const loadServerFile = async (fname, command)=>{
+    if (command !== 'dev') {
+        return Promise.resolve(fname).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p)));
+    }
+    const vite = await getViteServer();
+    return vite.ssrLoadModule(fname);
+};
+_nodeworker_threads.parentPort.on('message', (mesg)=>{
+    if (mesg.type === 'shutdown') {
+        shutdown();
+    } else if (mesg.type === 'render') {
+        handleRender(mesg);
+    } else if (mesg.type === 'getBuildConfig') {
+        handleGetBuildConfig(mesg);
+    } else if (mesg.type === 'buf') {
+        const stream = streamMap.get(mesg.id);
+        stream.write(_nodebuffer.Buffer.from(mesg.buf, mesg.offset, mesg.len));
+    } else if (mesg.type === 'end') {
+        const stream = streamMap.get(mesg.id);
+        stream.end();
+    } else if (mesg.type === 'err') {
+        const stream = streamMap.get(mesg.id);
+        const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+        stream.destroy(err);
+    }
+});
+const getEntriesFile = (config, command)=>{
+    const filePath = _nodepath.default.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir, config.entriesJs);
+    return command === 'dev' ? filePath : _nodeurl.default.pathToFileURL(filePath).toString();
+};
+const resolveClientEntry = (filePath, config, command, resolveClientPath)=>{
+    if (filePath.startsWith('file://')) {
+        filePath = filePath.slice('file://'.length);
+    }
+    filePath = resolveClientPath?.(filePath) || filePath;
+    let root = _nodepath.default.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir);
+    if (_nodepath.default.sep !== '/') {
+        // HACK to support windows filesystem
+        root = root.replaceAll(_nodepath.default.sep, '/');
+        if (filePath[0] === '/') {
+            filePath = filePath.slice(1);
+        }
+    }
+    if (!filePath.startsWith(root)) {
+        if (command === 'dev') {
+            // HACK this relies on Vite's internal implementation detail.
+            return config.basePath + '@fs/' + filePath.replace(/^\//, '');
+        } else {
+            throw new Error('Resolving client module outside root is unsupported for now');
+        }
+    }
+    return config.basePath + _nodepath.default.relative(root, filePath);
+};
+// HACK Patching stream is very fragile.
+const transformRsfId = (prefixToRemove)=>new _nodestream.Transform({
+        transform (chunk, encoding, callback) {
+            if (encoding !== 'buffer') {
+                throw new Error('Unknown encoding');
+            }
+            const data = chunk.toString();
+            const lines = data.split('\n');
+            let changed = false;
+            for(let i = 0; i < lines.length; ++i){
+                const match = lines[i].match(new RegExp(`^([0-9]+):{"id":"(?:file://)?${prefixToRemove}(.*?)"(.*)$`));
+                if (match) {
+                    lines[i] = `${match[1]}:{"id":"${match[2]}"${match[3]}`;
+                    changed = true;
+                }
+            }
+            callback(null, changed ? _nodebuffer.Buffer.from(lines.join('\n')) : chunk);
+        }
+    });
+async function renderRSC(rr) {
+    const config = await (0, _config.resolveConfig)();
+    const { runWithAsyncLocalStorage } = await loadServerFile('waku/server', rr.command);
+    const entriesFile = getEntriesFile(config, rr.command);
+    const { default: { renderEntries }, resolveClientPath } = await loadServerFile(entriesFile, rr.command);
+    const render = async (input)=>{
+        const elements = await renderEntries(input);
+        if (elements === null) {
+            const err = new Error('No function component found');
+            err.statusCode = 404; // HACK our convention for NotFound
+            throw err;
+        }
+        if (Object.keys(elements).some((key)=>key.startsWith('_'))) {
+            throw new Error('"_" prefix is reserved');
+        }
+        return elements;
+    };
+    const bundlerConfig = new Proxy({}, {
+        get (_target, encodedId) {
+            const [filePath, name] = encodedId.split('#');
+            const id = resolveClientEntry(filePath, config, rr.command, resolveClientPath);
+            rr?.moduleIdCallback?.(id);
+            return {
+                id,
+                chunks: [
+                    id
+                ],
+                name,
+                async: true
+            };
+        }
+    });
+    if (rr.method === 'POST') {
+        const actionId = decodeURIComponent(rr.input);
+        let args = [];
+        const contentType = rr.headers['content-type'];
+        if (typeof contentType === 'string' && contentType.startsWith('multipart/form-data')) {
+            const bb = (0, _busboy.default)({
+                headers: rr.headers
+            });
+            const reply = decodeReplyFromBusboy(bb);
+            rr.stream?.pipe(bb);
+            args = await reply;
+        } else {
+            let body = '';
+            for await (const chunk of rr.stream || []){
+                body += chunk;
+            }
+            if (body) {
+                args = await decodeReply(body);
+            }
+        }
+        const [fileId, name] = actionId.split('#');
+        const filePath = _nodepath.default.join(config.rootDir, fileId);
+        const fname = rr.command === 'dev' ? filePath : _nodeurl.default.pathToFileURL(filePath).toString();
+        const mod = await loadServerFile(fname, rr.command);
+        let elements = Promise.resolve({});
+        const rerender = (input)=>{
+            elements = Promise.all([
+                elements,
+                render(input)
+            ]).then(([oldElements, newElements])=>({
+                    ...oldElements,
+                    ...newElements
+                }));
+        };
+        return runWithAsyncLocalStorage({
+            getContext: ()=>rr.context,
+            rerender
+        }, async ()=>{
+            const data = await (mod[name] || mod)(...args);
+            return renderToPipeableStream({
+                ...await elements,
+                _value: data
+            }, bundlerConfig).pipe(transformRsfId(config.rootDir));
+        });
+    }
+    return runWithAsyncLocalStorage({
+        getContext: ()=>rr.context,
+        rerender: ()=>{
+            throw new Error('Cannot rerender');
+        }
+    }, async ()=>{
+        const elements = await render(rr.input);
+        return renderToPipeableStream(elements, bundlerConfig).pipe(transformRsfId(config.rootDir));
+    });
+}
+async function getBuildConfigRSC() {
+    const config = await (0, _config.resolveConfig)();
+    const entriesFile = getEntriesFile(config, 'build');
+    const { default: { getBuildConfig } } = await loadServerFile(entriesFile, 'build');
+    if (!getBuildConfig) {
+        console.warn("getBuildConfig is undefined. It's recommended for optimization and sometimes required.");
+        return {};
+    }
+    const unstable_collectClientModules = async (input)=>{
+        const idSet = new Set();
+        const pipeable = await renderRSC({
+            input,
+            method: 'GET',
+            headers: {},
+            command: 'build',
+            context: null,
+            moduleIdCallback: (id)=>idSet.add(id)
+        });
+        const stream = new _nodestream.Writable({
+            write (_chunk, _encoding, callback) {
+                callback();
+            }
+        });
+        pipeable.pipe(stream);
+        await (0, _promises.finished)(stream);
+        return Array.from(idSet);
+    };
+    const output = await getBuildConfig(unstable_collectClientModules);
+    return output;
+}
diff --git a/dist/cjs/lib/middleware/rsc.js b/dist/cjs/lib/middleware/rsc.js
new file mode 100644
index 0000000000000000000000000000000000000000..ac847f61ca04c598d36bb2b5a25133fc881c37ff
--- /dev/null
+++ b/dist/cjs/lib/middleware/rsc.js
@@ -0,0 +1,225 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rsc", {
+    enumerable: true,
+    get: function() {
+        return rsc;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _promises = /*#__PURE__*/ _interop_require_default(require("node:fs/promises"));
+const _config = require("../config.js");
+const _ssr = require("./rsc/ssr.js");
+const _utils = require("./rsc/utils.js");
+const _workerapi = require("./rsc/worker-api.js");
+const _patchreactrefresh = require("../vite-plugin/patch-react-refresh.js");
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rsc(options) {
+    const { command, ssr, unstable_prehook, unstable_posthook } = options;
+    if (!unstable_prehook && unstable_posthook) {
+        throw new Error('prehook is required if posthook is provided');
+    }
+    const configPromise = (0, _config.resolveConfig)();
+    let lastViteServer;
+    const getViteServer = async ()=>{
+        if (lastViteServer) {
+            return lastViteServer;
+        }
+        const config = await configPromise;
+        const { createServer: viteCreateServer } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("vite")));
+        const { default: viteReact } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("@vitejs/plugin-react")));
+        const { rscIndexPlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../vite-plugin/rsc-index-plugin.js")));
+        const { rscHmrPlugin, hotImport } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../vite-plugin/rsc-hmr-plugin.js")));
+        const viteServer = await viteCreateServer({
+            ...(0, _config.viteInlineConfig)(),
+            root: _nodepath.default.join(config.rootDir, config.srcDir),
+            optimizeDeps: {
+                include: [
+                    'react-server-dom-webpack/client'
+                ],
+                exclude: [
+                    'waku'
+                ]
+            },
+            plugins: [
+                (0, _patchreactrefresh.patchReactRefresh)(viteReact()),
+                rscIndexPlugin([]),
+                rscHmrPlugin()
+            ],
+            server: {
+                middlewareMode: true
+            }
+        });
+        (0, _workerapi.registerReloadCallback)((type)=>viteServer.ws.send({
+                type
+            }));
+        (0, _workerapi.registerImportCallback)((source)=>hotImport(viteServer, source));
+        lastViteServer = viteServer;
+        return viteServer;
+    };
+    let publicIndexHtml;
+    const getHtmlStr = async (pathStr)=>{
+        const config = await configPromise;
+        if (!publicIndexHtml) {
+            const publicIndexHtmlFile = _nodepath.default.join(config.rootDir, command === 'dev' ? config.srcDir : _nodepath.default.join(config.distDir, config.publicDir), config.indexHtml);
+            publicIndexHtml = await _promises.default.readFile(publicIndexHtmlFile, {
+                encoding: 'utf8'
+            });
+        }
+        if (command === 'start') {
+            const destFile = _nodepath.default.join(config.rootDir, config.distDir, config.publicDir, pathStr, pathStr.endsWith('/') ? 'index.html' : '');
+            try {
+                return await _promises.default.readFile(destFile, {
+                    encoding: 'utf8'
+                });
+            } catch (e) {
+                return publicIndexHtml;
+            }
+        }
+        // command === "dev"
+        const vite = await getViteServer();
+        for (const item of vite.moduleGraph.idToModuleMap.values()){
+            if (item.url === pathStr) {
+                return null;
+            }
+        }
+        const destFile = _nodepath.default.join(config.rootDir, config.srcDir, pathStr);
+        try {
+            // check if exists?
+            const stats = await _promises.default.stat(destFile);
+            if (stats.isFile()) {
+                return null;
+            }
+        } catch (e) {
+        // does not exist
+        }
+        return vite.transformIndexHtml(pathStr, publicIndexHtml);
+    };
+    return async (req, res, next)=>{
+        const config = await configPromise;
+        const basePrefix = config.basePath + config.rscPath + '/';
+        const pathStr = req.url || '';
+        const handleError = (err)=>{
+            if ((0, _utils.hasStatusCode)(err)) {
+                res.statusCode = err.statusCode;
+            } else {
+                console.info('Cannot render RSC', err);
+                res.statusCode = 500;
+            }
+            if (command === 'dev') {
+                res.end(String(err));
+            } else {
+                res.end();
+            }
+        };
+        let context;
+        try {
+            context = unstable_prehook?.(req, res);
+        } catch (e) {
+            handleError(e);
+            return;
+        }
+        if (ssr) {
+            try {
+                const htmlStr = await getHtmlStr(pathStr);
+                const result = htmlStr && await (0, _ssr.renderHtml)(config, command, pathStr, htmlStr, context);
+                if (result) {
+                    const [readable, nextCtx] = result;
+                    unstable_posthook?.(req, res, nextCtx);
+                    readable.on('error', handleError);
+                    readable.pipe(res);
+                    return;
+                }
+            } catch (e) {
+                handleError(e);
+                return;
+            }
+        }
+        if (pathStr.startsWith(basePrefix)) {
+            const { method, headers } = req;
+            if (method !== 'GET' && method !== 'POST') {
+                throw new Error(`Unsupported method '${method}'`);
+            }
+            try {
+                const [readable, nextCtx] = await (0, _workerapi.renderRSC)({
+                    input: (0, _utils.decodeInput)(pathStr.slice(basePrefix.length)),
+                    method,
+                    headers,
+                    command,
+                    context,
+                    stream: req
+                });
+                unstable_posthook?.(req, res, nextCtx);
+                readable.on('error', handleError);
+                readable.pipe(res);
+            } catch (e) {
+                handleError(e);
+            }
+            return;
+        }
+        if (command === 'dev') {
+            const vite = await getViteServer();
+            // TODO Do we still need this?
+            // HACK re-export "?v=..." URL to avoid dual module hazard.
+            const fname = pathStr.startsWith(config.basePath + '@fs/') ? pathStr.slice(config.basePath.length + 3) : _nodepath.default.join(vite.config.root, pathStr);
+            for (const item of vite.moduleGraph.idToModuleMap.values()){
+                if (item.file === fname && item.url !== pathStr && !item.url.includes('?html-proxy')) {
+                    res.setHeader('Content-Type', 'application/javascript');
+                    res.statusCode = 200;
+                    res.end(`export * from "${item.url}";`, 'utf8');
+                    return;
+                }
+            }
+            vite.middlewares(req, res, next);
+            return;
+        }
+        next();
+    };
+}
diff --git a/dist/cjs/lib/plugins/patch-react-refresh.js b/dist/cjs/lib/plugins/patch-react-refresh.js
new file mode 100644
index 0000000000000000000000000000000000000000..c7465db5871ea20568b2a33ed316d9e9c5d46579
--- /dev/null
+++ b/dist/cjs/lib/plugins/patch-react-refresh.js
@@ -0,0 +1,33 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "patchReactRefresh", {
+    enumerable: true,
+    get: function() {
+        return patchReactRefresh;
+    }
+});
+const patchReactRefresh = (options)=>options.map((option)=>{
+        const plugin = option;
+        const origTransformIndexHtml = plugin?.transformIndexHtml;
+        if (plugin?.name === 'vite:react-refresh' && typeof origTransformIndexHtml === 'function') {
+            return {
+                ...option,
+                transformIndexHtml (...args) {
+                    const result = origTransformIndexHtml(...args);
+                    if (Array.isArray(result)) {
+                        return result.map((item)=>({
+                                ...item,
+                                attrs: {
+                                    ...item.attrs,
+                                    async: true
+                                }
+                            }));
+                    }
+                    return result;
+                }
+            };
+        }
+        return option;
+    });
diff --git a/dist/cjs/lib/plugins/vite-plugin-nonjs-resolve.js b/dist/cjs/lib/plugins/vite-plugin-nonjs-resolve.js
new file mode 100644
index 0000000000000000000000000000000000000000..1015af05f371b5d8dacafd451b23f3ca2600f621
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-nonjs-resolve.js
@@ -0,0 +1,81 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "nonjsResolvePlugin", {
+    enumerable: true,
+    get: function() {
+        return nonjsResolvePlugin;
+    }
+});
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function nonjsResolvePlugin() {
+    return {
+        name: 'nonjs-resolve-plugin',
+        async resolveId (id, importer, options) {
+            const path = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:path"))).catch((e)=>{
+                // XXX explicit catch to avoid bundle time error
+                throw e;
+            });
+            if (!options.ssr) {
+                return id;
+            }
+            if (!id.endsWith('.js')) {
+                return id;
+            }
+            for (const ext of [
+                '.js',
+                '.ts',
+                '.tsx',
+                '.jsx',
+                '.mjs',
+                '.cjs'
+            ]){
+                const resolved = await this.resolve(id.slice(0, -path.extname(id).length) + ext, importer, options);
+                if (resolved) {
+                    return resolved;
+                }
+            }
+        }
+    };
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-analyze.js b/dist/cjs/lib/plugins/vite-plugin-rsc-analyze.js
new file mode 100644
index 0000000000000000000000000000000000000000..7e1ba1ecdd02aa4126595fd5c5d7a15836dc8707
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-analyze.js
@@ -0,0 +1,158 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscAnalyzePlugin", {
+    enumerable: true,
+    get: function() {
+        return rscAnalyzePlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = require("node:fs");
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscAnalyzePlugin(commonFileSet, clientFileSet, serverFileSet) {
+    const dependencyMap = new Map();
+    const clientEntryCallback = (id)=>clientFileSet.add(id);
+    const serverEntryCallback = (id)=>serverFileSet.add(id);
+    const dependencyCallback = (id, depId)=>{
+        let depSet = dependencyMap.get(id);
+        if (!depSet) {
+            depSet = new Set();
+            dependencyMap.set(id, depSet);
+        }
+        depSet.add(depId);
+    };
+    return {
+        name: 'rsc-analyze-plugin',
+        async transform (code, id) {
+            const ext = _nodepath.default.extname(id);
+            if ([
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx',
+                '.mjs'
+            ].includes(ext)) {
+                const mod = _core.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral') {
+                        if (item.expression.value === 'use client') {
+                            clientEntryCallback(id);
+                        } else if (item.expression.value === 'use server') {
+                            serverEntryCallback(id);
+                        }
+                    }
+                    if (item.type === 'ImportDeclaration') {
+                        const resolvedId = await this.resolve(item.source.value, id);
+                        if (resolvedId) {
+                            dependencyCallback(id, resolvedId.id);
+                        }
+                    }
+                }
+            }
+            return code;
+        },
+        generateBundle (_options, bundle) {
+            // TODO the logic in this function should probably be redesigned.
+            const outputIds = Object.values(bundle).flatMap((item)=>'facadeModuleId' in item && item.facadeModuleId ? [
+                    item.facadeModuleId
+                ] : []);
+            const possibleCommonFileMap = new Map();
+            const seen = new Set();
+            const loop = (id, isClient)=>{
+                if (seen.has(id)) {
+                    return;
+                }
+                seen.add(id);
+                isClient = isClient || clientFileSet.has(id);
+                for (const depId of dependencyMap.get(id) ?? []){
+                    if (!(0, _nodefs.existsSync)(depId)) {
+                        // HACK is there a better way?
+                        return;
+                    }
+                    let value = possibleCommonFileMap.get(depId);
+                    if (!value) {
+                        value = {};
+                        possibleCommonFileMap.set(depId, value);
+                    }
+                    if (isClient) {
+                        value.fromClient = true;
+                    } else {
+                        value.notFromClient = true;
+                    }
+                    loop(depId, isClient);
+                }
+            };
+            for (const id of outputIds){
+                loop(id, false);
+            }
+            for (const id of clientFileSet){
+                loop(id, true);
+            }
+            for (const id of serverFileSet){
+                loop(id, false);
+            }
+            for (const [id, val] of possibleCommonFileMap){
+                if (val.fromClient && val.notFromClient) {
+                    commonFileSet.add(id);
+                }
+            }
+            for (const id of clientFileSet){
+                commonFileSet.delete(id);
+            }
+            for (const id of serverFileSet){
+                commonFileSet.delete(id);
+            }
+        }
+    };
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-delegate.js b/dist/cjs/lib/plugins/vite-plugin-rsc-delegate.js
new file mode 100644
index 0000000000000000000000000000000000000000..46d084fb42b56d5b55e93be4b572d94bf84d44bb
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-delegate.js
@@ -0,0 +1,123 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscDelegatePlugin", {
+    enumerable: true,
+    get: function() {
+        return rscDelegatePlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+// import { CSS_LANGS_RE } from "vite/dist/node/constants.js";
+const CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
+function rscDelegatePlugin(moduleImports, importCallback) {
+    let mode = 'development';
+    let base = '/';
+    let server;
+    return {
+        name: 'rsc-delegate-plugin',
+        configResolved (config) {
+            mode = config.mode;
+            base = config.base;
+        },
+        configureServer (serverInstance) {
+            server = serverInstance;
+        },
+        async handleHotUpdate ({ file }) {
+            if (moduleImports.has(file)) {
+                // re-inject
+                const transformedResult = await server.transformRequest(file);
+                transformedResult && importCallback({
+                    ...transformedResult,
+                    id: file
+                });
+            }
+        },
+        async transform (code, id) {
+            const ext = _nodepath.default.extname(id);
+            if (mode === 'development' && [
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx'
+            ].includes(ext)) {
+                const mod = _core.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ImportDeclaration') {
+                        if (item.source.value.startsWith('virtual:')) {
+                            // HACK this relies on Vite's internal implementation detail.
+                            const source = base + '@id/__x00__' + item.source.value;
+                            importCallback(source);
+                        } else if (CSS_LANGS_RE.test(item.source.value)) {
+                            const resolvedSource = await server.pluginContainer.resolveId(item.source.value, id, {
+                                ssr: true
+                            });
+                            if (resolvedSource?.id) {
+                                const transformedResult = await server.transformRequest(resolvedSource.id);
+                                if (transformedResult) {
+                                    moduleImports.add(resolvedSource.id);
+                                    importCallback({
+                                        ...transformedResult,
+                                        id: resolvedSource.id
+                                    });
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            return code;
+        }
+    };
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-hmr.js b/dist/cjs/lib/plugins/vite-plugin-rsc-hmr.js
new file mode 100644
index 0000000000000000000000000000000000000000..b4cb3aad19b2cf7c4060df298eff5d63a832aff8
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-hmr.js
@@ -0,0 +1,108 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    hotImport: function() {
+        return hotImport;
+    },
+    moduleImport: function() {
+        return moduleImport;
+    },
+    rscHmrPlugin: function() {
+        return rscHmrPlugin;
+    }
+});
+const customCode = `
+import { createHotContext as __vite__createHotContext } from "/@vite/client";
+import.meta.hot = __vite__createHotContext(import.meta.url);
+
+if (import.meta.hot && !globalThis.__WAKU_HMR_CONFIGURED__) {
+  globalThis.__WAKU_HMR_CONFIGURED__ = true;
+  import.meta.hot.on('hot-import', (data) => import(/* @vite-ignore */ data));
+  import.meta.hot.on('module', (data) => {
+    // remove element with the same 'waku-module-id'
+    let script = document.querySelector(
+      'script[waku-module-id="' + data.id + '"]',
+    );
+    script?.remove();
+
+    const code = data.code;
+    script = document.createElement('script');
+    script.type = 'module';
+    script.text = code;
+    script.setAttribute('waku-module-id', data.id);
+    document.head.appendChild(script);
+  });
+}
+`;
+function rscHmrPlugin() {
+    return {
+        name: 'rsc-hmr-plugin',
+        enforce: 'post',
+        transformIndexHtml () {
+            return [
+                {
+                    tag: 'script',
+                    attrs: {
+                        type: 'module'
+                    },
+                    children: customCode,
+                    injectTo: 'head'
+                }
+            ];
+        }
+    };
+}
+const pendingMap = new WeakMap();
+function hotImport(vite, source) {
+    let sourceSet = pendingMap.get(vite);
+    if (!sourceSet) {
+        sourceSet = new Set();
+        pendingMap.set(vite, sourceSet);
+        vite.ws.on('connection', ()=>{
+            for (const source of sourceSet){
+                vite.ws.send({
+                    type: 'custom',
+                    event: 'hot-import',
+                    data: source
+                });
+            }
+        });
+    }
+    sourceSet.add(source);
+    vite.ws.send({
+        type: 'custom',
+        event: 'hot-import',
+        data: source
+    });
+}
+const modulePendingMap = new WeakMap();
+function moduleImport(viteServer, result) {
+    let sourceSet = modulePendingMap.get(viteServer);
+    if (!sourceSet) {
+        sourceSet = new Set();
+        modulePendingMap.set(viteServer, sourceSet);
+        viteServer.ws.on('connection', ()=>{
+            for (const result of sourceSet){
+                viteServer.ws.send({
+                    type: 'custom',
+                    event: 'module',
+                    data: result
+                });
+            }
+        });
+    }
+    sourceSet.add(result);
+    viteServer.ws.send({
+        type: 'custom',
+        event: 'module',
+        data: result
+    });
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-index.js b/dist/cjs/lib/plugins/vite-plugin-rsc-index.js
new file mode 100644
index 0000000000000000000000000000000000000000..d754084e39a72b8dd5eca0525a56ac7e8f0ee4be
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-index.js
@@ -0,0 +1,103 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscIndexPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscIndexPlugin;
+    }
+});
+const _utils = require("../renderers/utils.js");
+function rscIndexPlugin(config) {
+    const html = `
+<!doctype html>
+<html>
+  <head>
+${config.htmlHead}
+<script src="/${config.srcDir}/${config.mainJs}" async type="module"></script>
+  </head>
+  <body>
+  </body>
+</html>
+`;
+    return {
+        name: 'rsc-index-plugin',
+        configureServer (server) {
+            return ()=>{
+                server.middlewares.use((req, res)=>{
+                    res.statusCode = 200;
+                    res.setHeader('content-type', 'text/html; charset=utf-8');
+                    server.transformIndexHtml(req.url || '', html).then((content)=>{
+                        res.end(content);
+                    });
+                });
+            };
+        },
+        config () {
+            return {
+                optimizeDeps: {
+                    entries: [
+                        `${config.srcDir}/${config.mainJs}`
+                    ]
+                }
+            };
+        },
+        options (options) {
+            if (typeof options.input === 'string') {
+                throw new Error('string input is unsupported');
+            }
+            if (Array.isArray(options.input)) {
+                throw new Error('array input is unsupported');
+            }
+            return {
+                ...options,
+                input: {
+                    indexHtml: config.indexHtml,
+                    ...options.input
+                }
+            };
+        },
+        resolveId (id) {
+            if (id === config.indexHtml) {
+                return {
+                    id: config.indexHtml,
+                    moduleSideEffects: true
+                };
+            }
+        },
+        load (id) {
+            if (id === config.indexHtml) {
+                return html;
+            }
+        },
+        transformIndexHtml () {
+            return [
+                // HACK without <base>, some relative assets don't work.
+                // FIXME ideally, we should avoid this.
+                {
+                    tag: 'base',
+                    attrs: {
+                        href: config.basePath
+                    }
+                },
+                {
+                    tag: 'script',
+                    attrs: {
+                        type: 'module',
+                        async: true
+                    },
+                    children: _utils.codeToInject
+                },
+                ...(config.cssAssets || []).map((href)=>({
+                        tag: 'link',
+                        attrs: {
+                            rel: 'stylesheet',
+                            href
+                        },
+                        injectTo: 'head'
+                    }))
+            ];
+        }
+    };
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-reload.js b/dist/cjs/lib/plugins/vite-plugin-rsc-reload.js
new file mode 100644
index 0000000000000000000000000000000000000000..727d0f9b8f6b73ceb82ea89ba0da6caa5980ee3a
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-reload.js
@@ -0,0 +1,99 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscReloadPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscReloadPlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscReloadPlugin(moduleImports, fn) {
+    let enabled = false;
+    const isClientEntry = (id, code)=>{
+        const ext = _nodepath.default.extname(id);
+        if ([
+            '.ts',
+            '.tsx',
+            '.js',
+            '.jsx'
+        ].includes(ext)) {
+            const mod = _core.parseSync(code, {
+                syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                tsx: ext === '.tsx'
+            });
+            for (const item of mod.body){
+                if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral' && item.expression.value === 'use client') {
+                    return true;
+                }
+            }
+        }
+        return false;
+    };
+    return {
+        name: 'rsc-reload-plugin',
+        configResolved (config) {
+            if (config.mode === 'development') {
+                enabled = true;
+            }
+        },
+        async handleHotUpdate (ctx) {
+            if (!enabled) {
+                return [];
+            }
+            if (ctx.modules.length && !isClientEntry(ctx.file, await ctx.read()) && !moduleImports.has(ctx.file)) {
+                fn('full-reload');
+            } else {
+                return [];
+            }
+        }
+    };
+}
diff --git a/dist/cjs/lib/plugins/vite-plugin-rsc-transform.js b/dist/cjs/lib/plugins/vite-plugin-rsc-transform.js
new file mode 100644
index 0000000000000000000000000000000000000000..9293ca9611edbfa56d7fb1a32a9a3b1227b02a08
--- /dev/null
+++ b/dist/cjs/lib/plugins/vite-plugin-rsc-transform.js
@@ -0,0 +1,123 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscTransformPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscTransformPlugin;
+    }
+});
+const _nodeloader = /*#__PURE__*/ _interop_require_wildcard(require("react-server-dom-webpack/node-loader"));
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscTransformPlugin(opts) {
+    const getClientId = (id)=>{
+        if (!opts.isBuild) {
+            throw new Error('not buiding');
+        }
+        for (const [k, v] of Object.entries(opts.clientEntryFiles)){
+            if (v === id) {
+                return `@id/${opts.assetsDir}/${k}.js`;
+            }
+        }
+        throw new Error('client id not found: ' + id);
+    };
+    const getServerId = (id)=>{
+        if (!opts.isBuild) {
+            throw new Error('not buiding');
+        }
+        for (const [k, v] of Object.entries(opts.serverEntryFiles)){
+            if (v === id) {
+                return `@id/${opts.assetsDir}/${k}.js`;
+            }
+        }
+        throw new Error('server id not found: ' + id);
+    };
+    return {
+        name: 'rsc-transform-plugin',
+        async transform (code, id) {
+            const resolve = async (specifier, { parentURL })=>{
+                if (!specifier) {
+                    return {
+                        url: ''
+                    };
+                }
+                const url = (await this.resolve(specifier, parentURL)).id;
+                return {
+                    url
+                };
+            };
+            const load = async (url)=>{
+                let source = url === id ? code : (await this.load({
+                    id: url
+                })).code;
+                // HACK move directives before import statements.
+                source = source.replace(/^(import {.*?} from ".*?";)\s*"use (client|server)";/, '"use $2";$1');
+                return {
+                    format: 'module',
+                    source
+                };
+            };
+            _nodeloader.resolve('', {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                parentURL: ''
+            }, resolve);
+            let { source } = await _nodeloader.load(id, null, load);
+            if (opts.isBuild) {
+                // TODO we should parse the source code by ourselves with SWC
+                if (/^import {registerClientReference} from "react-server-dom-webpack\/server";/.test(source)) {
+                    // HACK tweak registerClientReference for production
+                    source = source.replace(/registerClientReference\(function\(\) {throw new Error\("([^"]*)"\);},"[^"]*","([^"]*)"\);/gs, `registerClientReference(function() {return "$1";}, "${getClientId(id)}", "$2");`);
+                }
+                if (/;import {registerServerReference} from "react-server-dom-webpack\/server";/.test(source)) {
+                    // HACK tweak registerServerReference for production
+                    source = source.replace(/registerServerReference\(([^,]*),"[^"]*","([^"]*)"\);/gs, `registerServerReference($1, "${getServerId(id)}", "$2");`);
+                }
+            }
+            return source;
+        }
+    };
+}
diff --git a/dist/cjs/lib/renderers/html-renderer.js b/dist/cjs/lib/renderers/html-renderer.js
new file mode 100644
index 0000000000000000000000000000000000000000..49b69c6b0f6a32b5d2bb297750365a0add1dbb4b
--- /dev/null
+++ b/dist/cjs/lib/renderers/html-renderer.js
@@ -0,0 +1,377 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    RD_SERVER_MODULE: function() {
+        return RD_SERVER_MODULE;
+    },
+    RD_SERVER_MODULE_VALUE: function() {
+        return RD_SERVER_MODULE_VALUE;
+    },
+    REACT_MODULE: function() {
+        return REACT_MODULE;
+    },
+    REACT_MODULE_VALUE: function() {
+        return REACT_MODULE_VALUE;
+    },
+    RSDW_CLIENT_MODULE: function() {
+        return RSDW_CLIENT_MODULE;
+    },
+    RSDW_CLIENT_MODULE_VALUE: function() {
+        return RSDW_CLIENT_MODULE_VALUE;
+    },
+    WAKU_CLIENT_MODULE: function() {
+        return WAKU_CLIENT_MODULE;
+    },
+    WAKU_CLIENT_MODULE_VALUE: function() {
+        return WAKU_CLIENT_MODULE_VALUE;
+    },
+    renderHtml: function() {
+        return renderHtml;
+    }
+});
+const _stream = require("../utils/stream.js");
+const _path = require("../utils/path.js");
+const _utils = require("./utils.js");
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const REACT_MODULE = 'react';
+const REACT_MODULE_VALUE = 'react';
+const RD_SERVER_MODULE = 'rd-server';
+const RD_SERVER_MODULE_VALUE = 'react-dom/server.edge';
+const RSDW_CLIENT_MODULE = 'rsdw-client';
+const RSDW_CLIENT_MODULE_VALUE = 'react-server-dom-webpack/client.edge';
+const WAKU_CLIENT_MODULE = 'waku-client';
+const WAKU_CLIENT_MODULE_VALUE = 'waku/client';
+// HACK for react-server-dom-webpack without webpack
+const moduleLoading = new Map();
+const moduleCache = new Map();
+globalThis.__webpack_chunk_load__ = async (id)=>moduleLoading.get(id);
+globalThis.__webpack_require__ = (id)=>moduleCache.get(id);
+let lastViteServer;
+const getViteServer = async ()=>{
+    if (lastViteServer) {
+        return lastViteServer;
+    }
+    const { Server } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("node:http"))).catch((e)=>{
+        // XXX explicit catch to avoid bundle time error
+        throw e;
+    });
+    const dummyServer = new Server(); // FIXME we hope to avoid this hack
+    const { createServer: createViteServer } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("vite"))).catch((e)=>{
+        // XXX explicit catch to avoid bundle time error
+        throw e;
+    });
+    const { nonjsResolvePlugin } = await Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard(require("../plugins/vite-plugin-nonjs-resolve.js")));
+    const viteServer = await createViteServer({
+        plugins: [
+            nonjsResolvePlugin()
+        ],
+        // HACK to suppress 'Skipping dependency pre-bundling' warning
+        optimizeDeps: {
+            include: []
+        },
+        ssr: {
+            external: [
+                'waku'
+            ]
+        },
+        appType: 'custom',
+        server: {
+            middlewareMode: true,
+            hmr: {
+                server: dummyServer
+            }
+        }
+    });
+    await viteServer.watcher.close(); // TODO watch: null
+    await viteServer.ws.close();
+    lastViteServer = viteServer;
+    return viteServer;
+};
+const loadServerFileDev = async (fileURL)=>{
+    const vite = await getViteServer();
+    return vite.ssrLoadModule((0, _path.fileURLToFilePath)(fileURL));
+};
+const fakeFetchCode = `
+Promise.resolve(new Response(new ReadableStream({
+  start(c) {
+    const f = (s) => new TextEncoder().encode(decodeURI(s));
+    globalThis.__WAKU_PUSH__ = (s) => s ? c.enqueue(f(s)) : c.close();
+  }
+})))
+`.split('\n').map((line)=>line.trim()).join('');
+// TODO this is an easy solution. we could do it better at the build time.
+const enableSsrCode = 'globalThis.__WAKU_SSR_ENABLED__ = true;';
+const injectRscPayload = (readable, urlForFakeFetch)=>{
+    const chunks = [];
+    const copied = readable.pipeThrough(new TransformStream({
+        transform (chunk, controller) {
+            if (!(chunk instanceof Uint8Array)) {
+                throw new Error('Unknown chunk type');
+            }
+            chunks.push(chunk);
+            controller.enqueue(chunk);
+        }
+    }));
+    const modifyHead = (data)=>{
+        const matchPrefetched = data.match(// HACK This is very brittle
+        /(.*<script[^>]*>\nglobalThis\.__WAKU_PREFETCHED__ = {\n)(.*?)(\n};.*)/s);
+        if (matchPrefetched) {
+            data = matchPrefetched[1] + `  '${urlForFakeFetch}': ${fakeFetchCode},` + matchPrefetched[3];
+        }
+        const closingHeadIndex = data.indexOf('</head>');
+        if (closingHeadIndex === -1) {
+            throw new Error('closing head not found');
+        }
+        let code = '';
+        if (!matchPrefetched) {
+            code += `
+globalThis.__WAKU_PREFETCHED__ = {
+  '${urlForFakeFetch}': ${fakeFetchCode},
+};
+`;
+        }
+        if (!data.includes(enableSsrCode)) {
+            code += enableSsrCode;
+        }
+        if (code) {
+            data = data.slice(0, closingHeadIndex) + `<script type="module" async>${code}</script>` + data.slice(closingHeadIndex);
+        }
+        return data;
+    };
+    const interleave = ()=>{
+        const encoder = new TextEncoder();
+        const decoder = new TextDecoder();
+        let headSent = false;
+        let data = '';
+        let scriptsClosed = false;
+        const sendScripts = (controller, close)=>{
+            if (scriptsClosed) {
+                return;
+            }
+            const scripts = chunks.splice(0).map((chunk)=>`
+<script type="module" async>globalThis.__WAKU_PUSH__("${encodeURI(decoder.decode(chunk))}")</script>`);
+            if (close) {
+                scriptsClosed = true;
+                scripts.push(`
+<script type="module" async>globalThis.__WAKU_PUSH__()</script>`);
+            }
+            if (scripts.length) {
+                controller.enqueue(encoder.encode(scripts.join('')));
+            }
+        };
+        return new TransformStream({
+            transform (chunk, controller) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                data += decoder.decode(chunk);
+                if (!headSent) {
+                    if (!data.includes('</head>')) {
+                        return;
+                    }
+                    headSent = true;
+                    data = modifyHead(data);
+                }
+                const closingBodyIndex = data.lastIndexOf('</body>');
+                if (closingBodyIndex === -1) {
+                    controller.enqueue(encoder.encode(data));
+                    data = '';
+                    sendScripts(controller);
+                } else {
+                    controller.enqueue(encoder.encode(data.slice(0, closingBodyIndex)));
+                    sendScripts(controller, true);
+                    controller.enqueue(encoder.encode(data.slice(closingBodyIndex)));
+                    data = '';
+                }
+            }
+        });
+    };
+    return [
+        copied,
+        interleave
+    ];
+};
+// HACK for now, do we want to use HTML parser?
+const rectifyHtml = ()=>{
+    const pending = [];
+    const decoder = new TextDecoder();
+    let timer;
+    return new TransformStream({
+        transform (chunk, controller) {
+            if (!(chunk instanceof Uint8Array)) {
+                throw new Error('Unknown chunk type');
+            }
+            pending.push(chunk);
+            if (/<\/\w+>$/.test(decoder.decode(chunk))) {
+                clearTimeout(timer);
+                timer = setTimeout(()=>{
+                    controller.enqueue((0, _stream.concatUint8Arrays)(pending.splice(0)));
+                });
+            }
+        },
+        flush (controller) {
+            clearTimeout(timer);
+            if (pending.length) {
+                controller.enqueue((0, _stream.concatUint8Arrays)(pending.splice(0)));
+            }
+        }
+    });
+};
+const buildHtml = (createElement, head, body)=>createElement('html', null, createElement('head', {
+        dangerouslySetInnerHTML: {
+            __html: head
+        }
+    }), createElement('body', null, body));
+const renderHtml = async (opts)=>{
+    const { config, pathname, searchParams, htmlHead, renderRscForHtml, isDev, entries } = opts;
+    const { default: { getSsrConfig }, loadModule } = entries;
+    const [{ createElement, Fragment }, { renderToReadableStream }, { createFromReadableStream }, { ServerRoot, Slot }] = await Promise.all([
+        isDev ? Promise.resolve(REACT_MODULE_VALUE).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))) : loadModule('public/' + REACT_MODULE).then((m)=>m.default),
+        isDev ? Promise.resolve(RD_SERVER_MODULE_VALUE).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))) : loadModule('public/' + RD_SERVER_MODULE).then((m)=>m.default),
+        isDev ? Promise.resolve(RSDW_CLIENT_MODULE_VALUE).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))) : loadModule('public/' + RSDW_CLIENT_MODULE).then((m)=>m.default),
+        isDev ? Promise.resolve(WAKU_CLIENT_MODULE_VALUE).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))) : loadModule('public/' + WAKU_CLIENT_MODULE)
+    ]);
+    const ssrConfig = await getSsrConfig?.(pathname, {
+        searchParams,
+        isPrd: !isDev && !opts.isBuild
+    });
+    if (!ssrConfig) {
+        return null;
+    }
+    const rootDirDev = isDev && (await getViteServer()).config.root;
+    let stream;
+    try {
+        stream = await renderRscForHtml(ssrConfig.input, ssrConfig.searchParams || searchParams);
+    } catch (e) {
+        if ((0, _utils.hasStatusCode)(e) && e.statusCode === 404) {
+            return null;
+        }
+        throw e;
+    }
+    const moduleMap = new Proxy({}, {
+        get (_target, filePath) {
+            return new Proxy({}, {
+                get (_target, name) {
+                    const file = filePath.slice(config.basePath.length);
+                    // TODO too long, we need to refactor this logic
+                    if (isDev) {
+                        if (!rootDirDev) {
+                            throw new Error('rootDirDev is not defined');
+                        }
+                        const filePath = file.startsWith('@fs/') ? (0, _path.decodeFilePathFromAbsolute)(file.slice('@fs'.length)) : (0, _path.joinPath)(rootDirDev, file);
+                        const wakuDist = (0, _path.joinPath)((0, _path.fileURLToFilePath)(require("url").pathToFileURL(__filename).toString()), '../../..');
+                        if (filePath.startsWith(wakuDist)) {
+                            const id = 'waku' + filePath.slice(wakuDist.length).replace(/\.\w+$/, '');
+                            if (!moduleLoading.has(id)) {
+                                moduleLoading.set(id, Promise.resolve(id).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))).then((m)=>{
+                                    moduleCache.set(id, m);
+                                }));
+                            }
+                            return {
+                                id,
+                                chunks: [
+                                    id
+                                ],
+                                name
+                            };
+                        }
+                        const id = (0, _path.filePathToFileURL)(filePath);
+                        if (!moduleLoading.has(id)) {
+                            moduleLoading.set(id, loadServerFileDev(id).then((m)=>{
+                                moduleCache.set(id, m);
+                            }));
+                        }
+                        return {
+                            id,
+                            chunks: [
+                                id
+                            ],
+                            name
+                        };
+                    }
+                    // !isDev
+                    const id = file;
+                    if (!moduleLoading.has(id)) {
+                        moduleLoading.set(id, loadModule('public/' + id).then((m)=>{
+                            moduleCache.set(id, m);
+                        }));
+                    }
+                    return {
+                        id,
+                        chunks: [
+                            id
+                        ],
+                        name
+                    };
+                }
+            });
+        }
+    });
+    const [copied, interleave] = injectRscPayload(stream, config.basePath + config.rscPath + '/' + (0, _utils.encodeInput)(ssrConfig.input));
+    const elements = createFromReadableStream(copied, {
+        ssrManifest: {
+            moduleMap,
+            moduleLoading: null
+        }
+    });
+    const readable = (await renderToReadableStream(buildHtml(createElement, htmlHead, createElement(ServerRoot, {
+        elements
+    }, ssrConfig.unstable_render({
+        createElement,
+        Fragment,
+        Slot
+    }))), {
+        onError (err) {
+            console.error(err);
+        }
+    })).pipeThrough(rectifyHtml()).pipeThrough(interleave());
+    return readable;
+};
diff --git a/dist/cjs/lib/renderers/rsc-renderer.js b/dist/cjs/lib/renderers/rsc-renderer.js
new file mode 100644
index 0000000000000000000000000000000000000000..0f6e05cce8e4c93ba2f3dee63a0ec9e63e6aac22
--- /dev/null
+++ b/dist/cjs/lib/renderers/rsc-renderer.js
@@ -0,0 +1,212 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    RSDW_SERVER_MODULE: function() {
+        return RSDW_SERVER_MODULE;
+    },
+    RSDW_SERVER_MODULE_VALUE: function() {
+        return RSDW_SERVER_MODULE_VALUE;
+    },
+    getBuildConfig: function() {
+        return getBuildConfig;
+    },
+    renderRsc: function() {
+        return renderRsc;
+    }
+});
+const _path = require("../utils/path.js");
+const _form = require("../utils/form.js");
+const _stream = require("../utils/stream.js");
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const RSDW_SERVER_MODULE = 'rsdw-server';
+const RSDW_SERVER_MODULE_VALUE = 'react-server-dom-webpack/server.edge';
+const resolveClientEntry = (file, config, isDev)=>{
+    if (isDev) {
+        const filePath = file.startsWith('file://') ? (0, _path.fileURLToFilePath)(file) : file;
+        // HACK this relies on Vite's internal implementation detail.
+        return config.basePath + '@fs' + (0, _path.encodeFilePathToAbsolute)(filePath);
+    }
+    if (!file.startsWith('@id/')) {
+        throw new Error('Unexpected client entry in PRD');
+    }
+    return config.basePath + file.slice('@id/'.length);
+};
+async function renderRsc(opts) {
+    const { config, input, searchParams, method, contentType, context, body, moduleIdCallback, isDev, entries } = opts;
+    const { default: { renderEntries }, loadModule } = entries;
+    const { renderToReadableStream, decodeReply } = await (isDev ? Promise.resolve(RSDW_SERVER_MODULE_VALUE).then((p)=>/*#__PURE__*/ _interop_require_wildcard(require(p))) : loadModule(RSDW_SERVER_MODULE).then((m)=>m.default));
+    const render = async (renderContext, input, searchParams)=>{
+        const elements = await renderEntries.call(renderContext, input, searchParams);
+        if (elements === null) {
+            const err = new Error('No function component found');
+            err.statusCode = 404; // HACK our convention for NotFound
+            throw err;
+        }
+        if (Object.keys(elements).some((key)=>key.startsWith('_'))) {
+            throw new Error('"_" prefix is reserved');
+        }
+        return elements;
+    };
+    const bundlerConfig = new Proxy({}, {
+        get (_target, encodedId) {
+            const [file, name] = encodedId.split('#');
+            const id = resolveClientEntry(file, config, isDev);
+            moduleIdCallback?.(id);
+            return {
+                id,
+                chunks: [
+                    id
+                ],
+                name,
+                async: true
+            };
+        }
+    });
+    if (method === 'POST') {
+        const rsfId = decodeURIComponent(input);
+        let args = [];
+        let bodyStr = '';
+        if (body) {
+            bodyStr = await (0, _stream.streamToString)(body);
+        }
+        if (typeof contentType === 'string' && contentType.startsWith('multipart/form-data')) {
+            // XXX This doesn't support streaming unlike busboy
+            const formData = (0, _form.parseFormData)(bodyStr, contentType);
+            args = await decodeReply(formData);
+        } else if (bodyStr) {
+            args = await decodeReply(bodyStr);
+        }
+        const [fileId, name] = rsfId.split('#');
+        let mod;
+        if (isDev) {
+            mod = await opts.customImport((0, _path.filePathToFileURL)(fileId));
+        } else {
+            if (!fileId.startsWith('@id/')) {
+                throw new Error('Unexpected server entry in PRD');
+            }
+            mod = await loadModule(fileId.slice('@id/'.length));
+        }
+        const fn = mod[name] || mod;
+        let elements = Promise.resolve({});
+        let rendered = false;
+        const rerender = (input, searchParams = new URLSearchParams())=>{
+            if (rendered) {
+                throw new Error('already rendered');
+            }
+            const renderContext = {
+                rerender,
+                context
+            };
+            elements = Promise.all([
+                elements,
+                render(renderContext, input, searchParams)
+            ]).then(([oldElements, newElements])=>({
+                    ...oldElements,
+                    ...newElements
+                }));
+        };
+        const renderContext = {
+            rerender,
+            context
+        };
+        const data = await fn.apply(renderContext, args);
+        const resolvedElements = await elements;
+        rendered = true;
+        return renderToReadableStream({
+            ...resolvedElements,
+            _value: data
+        }, bundlerConfig);
+    }
+    // method === 'GET'
+    const renderContext = {
+        rerender: ()=>{
+            throw new Error('Cannot rerender');
+        },
+        context
+    };
+    const elements = await render(renderContext, input, searchParams);
+    return renderToReadableStream(elements, bundlerConfig);
+}
+async function getBuildConfig(opts) {
+    const { config, entries } = opts;
+    const { default: { getBuildConfig } } = entries;
+    if (!getBuildConfig) {
+        console.warn("getBuildConfig is undefined. It's recommended for optimization and sometimes required.");
+        return [];
+    }
+    const unstable_collectClientModules = async (input)=>{
+        const idSet = new Set();
+        const readable = await renderRsc({
+            config,
+            input,
+            searchParams: new URLSearchParams(),
+            method: 'GET',
+            context: null,
+            moduleIdCallback: (id)=>idSet.add(id),
+            isDev: false,
+            entries
+        });
+        await new Promise((resolve, reject)=>{
+            const writable = new WritableStream({
+                close () {
+                    resolve();
+                },
+                abort (reason) {
+                    reject(reason);
+                }
+            });
+            readable.pipeTo(writable);
+        });
+        return Array.from(idSet);
+    };
+    const output = await getBuildConfig(unstable_collectClientModules);
+    return output;
+}
diff --git a/dist/cjs/lib/renderers/utils.js b/dist/cjs/lib/renderers/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..6d601e6cbf7cbc697265420d94e23cdca789bff9
--- /dev/null
+++ b/dist/cjs/lib/renderers/utils.js
@@ -0,0 +1,88 @@
+// This file should not include Node specific code.
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    codeToInject: function() {
+        return codeToInject;
+    },
+    decodeInput: function() {
+        return decodeInput;
+    },
+    deepFreeze: function() {
+        return deepFreeze;
+    },
+    encodeInput: function() {
+        return encodeInput;
+    },
+    generatePrefetchCode: function() {
+        return generatePrefetchCode;
+    },
+    hasStatusCode: function() {
+        return hasStatusCode;
+    }
+});
+const encodeInput = (input)=>{
+    if (input === '') {
+        return 'index.txt';
+    }
+    if (input === 'index') {
+        throw new Error('Input should not be `index`');
+    }
+    if (input.startsWith('/')) {
+        throw new Error('Input should not start with `/`');
+    }
+    if (input.endsWith('/')) {
+        throw new Error('Input should not end with `/`');
+    }
+    return input + '.txt';
+};
+const decodeInput = (encodedInput)=>{
+    if (encodedInput === 'index.txt') {
+        return '';
+    }
+    if (encodedInput?.endsWith('.txt')) {
+        return encodedInput.slice(0, -'.txt'.length);
+    }
+    const err = new Error('Invalid encoded input');
+    err.statusCode = 400;
+    throw err;
+};
+const hasStatusCode = (x)=>typeof x?.statusCode === 'number';
+const codeToInject = `
+globalThis.__waku_module_cache__ = new Map();
+globalThis.__webpack_chunk_load__ = (id) => import(id).then((m) => globalThis.__waku_module_cache__.set(id, m));
+globalThis.__webpack_require__ = (id) => globalThis.__waku_module_cache__.get(id);`;
+const generatePrefetchCode = (basePrefix, inputs, moduleIds)=>{
+    const inputsArray = Array.from(inputs);
+    let code = '';
+    if (inputsArray.length) {
+        code += `
+globalThis.__WAKU_PREFETCHED__ = {
+${inputsArray.map((input)=>{
+            const url = basePrefix + encodeInput(input);
+            return `  '${url}': fetch('${url}'),`;
+        }).join('\n')}
+};`;
+    }
+    for (const moduleId of moduleIds){
+        code += `
+import('${moduleId}');`;
+    }
+    return code;
+};
+const deepFreeze = (x)=>{
+    if (typeof x === 'object' && x !== null) {
+        Object.freeze(x);
+        for (const value of Object.values(x)){
+            deepFreeze(value);
+        }
+    }
+};
diff --git a/dist/cjs/lib/utils/form.js b/dist/cjs/lib/utils/form.js
new file mode 100644
index 0000000000000000000000000000000000000000..429ab02c58312673777f20a2968a0fd48eff6bd0
--- /dev/null
+++ b/dist/cjs/lib/utils/form.js
@@ -0,0 +1,44 @@
+// TODO is this correct? better to use a library?
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "parseFormData", {
+    enumerable: true,
+    get: function() {
+        return parseFormData;
+    }
+});
+const parseFormData = (body, contentType)=>{
+    const boundary = contentType.split('boundary=')[1];
+    const parts = body.split(`--${boundary}`);
+    const formData = new FormData();
+    for (const part of parts){
+        if (part.trim() === '' || part === '--') continue;
+        const [rawHeaders, content] = part.split('\r\n\r\n', 2);
+        const headers = rawHeaders.split('\r\n').reduce((acc, currentHeader)=>{
+            const [key, value] = currentHeader.split(': ');
+            acc[key.toLowerCase()] = value;
+            return acc;
+        }, {});
+        const contentDisposition = headers['content-disposition'];
+        const nameMatch = /name="([^"]+)"/.exec(contentDisposition);
+        const filenameMatch = /filename="([^"]+)"/.exec(contentDisposition);
+        if (nameMatch) {
+            const name = nameMatch[1];
+            if (filenameMatch) {
+                const filename = filenameMatch[1];
+                const type = headers['content-type'] || 'application/octet-stream';
+                const blob = new Blob([
+                    content
+                ], {
+                    type
+                });
+                formData.append(name, blob, filename);
+            } else {
+                formData.append(name, content.trim());
+            }
+        }
+    }
+    return formData;
+};
diff --git a/dist/cjs/lib/utils/merge-vite-config.js b/dist/cjs/lib/utils/merge-vite-config.js
new file mode 100644
index 0000000000000000000000000000000000000000..5a360760a1842cdca506e62704ae9cdb218b862c
--- /dev/null
+++ b/dist/cjs/lib/utils/merge-vite-config.js
@@ -0,0 +1,25 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "mergeUserViteConfig", {
+    enumerable: true,
+    get: function() {
+        return mergeUserViteConfig;
+    }
+});
+const _vite = require("vite");
+async function mergeUserViteConfig(config) {
+    const resolvedViteConfig = await (0, _vite.resolveConfig)({}, 'serve');
+    const mergedViteConfig = (0, _vite.mergeConfig)({
+        ...resolvedViteConfig,
+        plugins: resolvedViteConfig.plugins.filter((plugin)=>!plugin.name.startsWith('vite:'))
+    }, config);
+    // vite sets terserOptions to {} in resolveViteConfig and minify to 'esbuild' at the same time which shows a warning
+    if (!Object.keys(mergedViteConfig.build.terserOptions).length) {
+        mergedViteConfig.build.terserOptions = null;
+    }
+    // HACK: Vite bug: TypeError [ERR_INVALID_ARG_TYPE]: The "path" argument must be of type string. Received function assetsInclude
+    mergedViteConfig.assetsInclude = null;
+    return mergedViteConfig;
+}
diff --git a/dist/cjs/lib/utils/node-fs.js b/dist/cjs/lib/utils/node-fs.js
new file mode 100644
index 0000000000000000000000000000000000000000..833027208b357207e5f11ce470ee1cdd3a6406aa
--- /dev/null
+++ b/dist/cjs/lib/utils/node-fs.js
@@ -0,0 +1,57 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    appendFile: function() {
+        return appendFile;
+    },
+    createReadStream: function() {
+        return createReadStream;
+    },
+    createWriteStream: function() {
+        return createWriteStream;
+    },
+    existsSync: function() {
+        return existsSync;
+    },
+    mkdir: function() {
+        return mkdir;
+    },
+    readFile: function() {
+        return readFile;
+    },
+    rename: function() {
+        return rename;
+    },
+    stat: function() {
+        return stat;
+    },
+    writeFile: function() {
+        return writeFile;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = /*#__PURE__*/ _interop_require_default(require("node:fs"));
+const _promises = /*#__PURE__*/ _interop_require_default(require("node:fs/promises"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const filePathToOsPath = (filePath)=>_nodepath.default.sep === '/' ? filePath : filePath.replace(/\//g, '\\');
+const createReadStream = (filePath)=>_nodefs.default.createReadStream(filePathToOsPath(filePath));
+const createWriteStream = (filePath)=>_nodefs.default.createWriteStream(filePathToOsPath(filePath));
+const existsSync = (filePath)=>_nodefs.default.existsSync(filePathToOsPath(filePath));
+const rename = (filePath1, filePath2)=>_promises.default.rename(filePathToOsPath(filePath1), filePathToOsPath(filePath2));
+const mkdir = (filePath, options)=>_promises.default.mkdir(filePathToOsPath(filePath), options);
+const readFile = (filePath, options)=>_promises.default.readFile(filePathToOsPath(filePath), options);
+const writeFile = (filePath, content)=>_promises.default.writeFile(filePathToOsPath(filePath), content);
+const appendFile = (filePath, content)=>_promises.default.appendFile(filePathToOsPath(filePath), content);
+const stat = (filePath)=>_promises.default.stat(filePathToOsPath(filePath));
diff --git a/dist/cjs/lib/utils/path.js b/dist/cjs/lib/utils/path.js
new file mode 100644
index 0000000000000000000000000000000000000000..b75bc6f00b94179536702573c3f59ff6be0cfa5e
--- /dev/null
+++ b/dist/cjs/lib/utils/path.js
@@ -0,0 +1,84 @@
+// Terminology:
+// - filePath: posix-like file path, e.g. `/foo/bar.js` or `c:/foo/bar.js`
+//   This is used by Vite.
+// - fileURL: file URL, e.g. `file:///foo/bar.js` or `file:///c:/foo/bar.js`
+//   This is used by import().
+// - osPath: os dependent path, e.g. `/foo/bar.js` or `c:\foo\bar.js`
+//   This is used by node:fs.
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    decodeFilePathFromAbsolute: function() {
+        return decodeFilePathFromAbsolute;
+    },
+    encodeFilePathToAbsolute: function() {
+        return encodeFilePathToAbsolute;
+    },
+    extname: function() {
+        return extname;
+    },
+    filePathToFileURL: function() {
+        return filePathToFileURL;
+    },
+    fileURLToFilePath: function() {
+        return fileURLToFilePath;
+    },
+    joinPath: function() {
+        return joinPath;
+    }
+});
+const ABSOLUTE_WIN32_PATH_REGEXP = /^\/[a-zA-Z]:\//;
+const encodeFilePathToAbsolute = (filePath)=>{
+    if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {
+        throw new Error('Unsupported absolute file path');
+    }
+    if (filePath.startsWith('/')) {
+        return filePath;
+    }
+    return '/' + filePath;
+};
+const decodeFilePathFromAbsolute = (filePath)=>{
+    if (ABSOLUTE_WIN32_PATH_REGEXP.test(filePath)) {
+        return filePath.slice(1);
+    }
+    return filePath;
+};
+const filePathToFileURL = (filePath)=>'file://' + encodeURI(filePath);
+const fileURLToFilePath = (fileURL)=>{
+    if (!fileURL.startsWith('file://')) {
+        throw new Error('Not a file URL');
+    }
+    return decodeURI(fileURL.slice('file://'.length));
+};
+const joinPath = (...paths)=>{
+    const isAbsolute = paths[0]?.startsWith('/');
+    const items = [].concat(...paths.map((path)=>path.split('/')));
+    let i = 0;
+    while(i < items.length){
+        if (items[i] === '.' || items[i] === '') {
+            items.splice(i, 1);
+        } else if (items[i] === '..') {
+            if (i > 0) {
+                items.splice(i - 1, 2);
+                --i;
+            } else {
+                items.splice(i, 1);
+            }
+        } else {
+            ++i;
+        }
+    }
+    return (isAbsolute ? '/' : '') + items.join('/') || '.';
+};
+const extname = (filePath)=>{
+    const index = filePath.lastIndexOf('.');
+    return index > 0 ? filePath.slice(index) : '';
+};
diff --git a/dist/cjs/lib/utils/stream.js b/dist/cjs/lib/utils/stream.js
new file mode 100644
index 0000000000000000000000000000000000000000..1b6519e04d27ac235ab2335d1f7fb7b69fbdf860
--- /dev/null
+++ b/dist/cjs/lib/utils/stream.js
@@ -0,0 +1,58 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    concatUint8Arrays: function() {
+        return concatUint8Arrays;
+    },
+    endStream: function() {
+        return endStream;
+    },
+    streamToString: function() {
+        return streamToString;
+    }
+});
+const endStream = async (stream, message)=>{
+    const writer = stream.getWriter();
+    await writer.ready;
+    if (message) {
+        await writer.write(new TextEncoder().encode(message));
+    }
+    await writer.close();
+};
+const concatUint8Arrays = (arrs)=>{
+    const len = arrs.reduce((acc, arr)=>acc + arr.length, 0);
+    const array = new Uint8Array(len);
+    let offset = 0;
+    for (const arr of arrs){
+        array.set(arr, offset);
+        offset += arr.length;
+    }
+    return array;
+};
+const streamToString = async (stream)=>{
+    const decoder = new TextDecoder();
+    const reader = stream.getReader();
+    const outs = [];
+    let result;
+    do {
+        result = await reader.read();
+        if (result.value) {
+            if (!(result.value instanceof Uint8Array)) {
+                throw new Error('Unexepected buffer type');
+            }
+            outs.push(decoder.decode(result.value, {
+                stream: true
+            }));
+        }
+    }while (!result.done)
+    outs.push(decoder.decode());
+    return outs.join('');
+};
diff --git a/dist/cjs/lib/vite-plugin/nonjs-resolve-plugin.js b/dist/cjs/lib/vite-plugin/nonjs-resolve-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..44fd849a855aba47254366869c7573f696662502
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/nonjs-resolve-plugin.js
@@ -0,0 +1,40 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "nonjsResolvePlugin", {
+    enumerable: true,
+    get: function() {
+        return nonjsResolvePlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function nonjsResolvePlugin() {
+    return {
+        name: 'nonjs-resolve-plugin',
+        async resolveId (id, importer, options) {
+            if (!id.endsWith('.js')) {
+                return id;
+            }
+            for (const ext of [
+                '.js',
+                '.ts',
+                '.tsx',
+                '.jsx'
+            ]){
+                const resolved = await this.resolve(id.slice(0, -_nodepath.default.extname(id).length) + ext, importer, {
+                    ...options,
+                    skipSelf: true
+                });
+                if (resolved) {
+                    return resolved;
+                }
+            }
+        }
+    };
+}
diff --git a/dist/cjs/lib/vite-plugin/patch-react-refresh.js b/dist/cjs/lib/vite-plugin/patch-react-refresh.js
new file mode 100644
index 0000000000000000000000000000000000000000..c7465db5871ea20568b2a33ed316d9e9c5d46579
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/patch-react-refresh.js
@@ -0,0 +1,33 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "patchReactRefresh", {
+    enumerable: true,
+    get: function() {
+        return patchReactRefresh;
+    }
+});
+const patchReactRefresh = (options)=>options.map((option)=>{
+        const plugin = option;
+        const origTransformIndexHtml = plugin?.transformIndexHtml;
+        if (plugin?.name === 'vite:react-refresh' && typeof origTransformIndexHtml === 'function') {
+            return {
+                ...option,
+                transformIndexHtml (...args) {
+                    const result = origTransformIndexHtml(...args);
+                    if (Array.isArray(result)) {
+                        return result.map((item)=>({
+                                ...item,
+                                attrs: {
+                                    ...item.attrs,
+                                    async: true
+                                }
+                            }));
+                    }
+                    return result;
+                }
+            };
+        }
+        return option;
+    });
diff --git a/dist/cjs/lib/vite-plugin/rsc-analyze-plugin.js b/dist/cjs/lib/vite-plugin/rsc-analyze-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..e99c92b737f8e8d4e2833ba7580efee3e2413ffc
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-analyze-plugin.js
@@ -0,0 +1,148 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscAnalyzePlugin", {
+    enumerable: true,
+    get: function() {
+        return rscAnalyzePlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodefs = /*#__PURE__*/ _interop_require_default(require("node:fs"));
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscAnalyzePlugin(commonFileSet, clientFileSet, serverFileSet) {
+    const dependencyMap = new Map();
+    const clientEntryCallback = (id)=>clientFileSet.add(id);
+    const serverEntryCallback = (id)=>serverFileSet.add(id);
+    const dependencyCallback = (id, depId)=>{
+        let depSet = dependencyMap.get(id);
+        if (!depSet) {
+            depSet = new Set();
+            dependencyMap.set(id, depSet);
+        }
+        depSet.add(depId);
+    };
+    return {
+        name: 'rsc-analyze-plugin',
+        async transform (code, id) {
+            const ext = _nodepath.default.extname(id);
+            if ([
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx',
+                '.mjs'
+            ].includes(ext)) {
+                const mod = _core.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral') {
+                        if (item.expression.value === 'use client') {
+                            clientEntryCallback(id);
+                        } else if (item.expression.value === 'use server') {
+                            serverEntryCallback(id);
+                        }
+                    }
+                    if (item.type === 'ImportDeclaration') {
+                        const resolvedId = await this.resolve(item.source.value, id);
+                        if (resolvedId) {
+                            dependencyCallback(id, resolvedId.id);
+                        }
+                    }
+                }
+            }
+            return code;
+        },
+        generateBundle (_options, bundle) {
+            // TODO the logic in this function should probably be redesigned.
+            const outputIds = Object.values(bundle).flatMap((item)=>'facadeModuleId' in item && item.facadeModuleId ? [
+                    item.facadeModuleId
+                ] : []);
+            const possibleCommonFileMap = new Map();
+            const seen = new Set();
+            const loop = (id, isClient)=>{
+                if (seen.has(id)) {
+                    return;
+                }
+                seen.add(id);
+                isClient = isClient || clientFileSet.has(id);
+                dependencyMap.get(id)?.forEach((depId)=>{
+                    if (!_nodefs.default.existsSync(depId)) {
+                        // HACK is there a better way?
+                        return;
+                    }
+                    let value = possibleCommonFileMap.get(depId);
+                    if (!value) {
+                        value = {};
+                        possibleCommonFileMap.set(depId, value);
+                    }
+                    if (isClient) {
+                        value.fromClient = true;
+                    } else {
+                        value.notFromClient = true;
+                    }
+                    loop(depId, isClient);
+                });
+            };
+            outputIds.forEach((id)=>loop(id, false));
+            clientFileSet.forEach((id)=>loop(id, true));
+            serverFileSet.forEach((id)=>loop(id, false));
+            for (const [id, val] of possibleCommonFileMap){
+                if (val.fromClient && val.notFromClient) {
+                    commonFileSet.add(id);
+                }
+            }
+            clientFileSet.forEach((id)=>commonFileSet.delete(id));
+            serverFileSet.forEach((id)=>commonFileSet.delete(id));
+        }
+    };
+}
diff --git a/dist/cjs/lib/vite-plugin/rsc-delegate-plugin.js b/dist/cjs/lib/vite-plugin/rsc-delegate-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..9132f3a8aa1c5ac892c4022dd7e2f19ce84e8607
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-delegate-plugin.js
@@ -0,0 +1,100 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscDelegatePlugin", {
+    enumerable: true,
+    get: function() {
+        return rscDelegatePlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+// import { CSS_LANGS_RE } from "vite/dist/node/constants.js";
+const CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
+function rscDelegatePlugin(importCallback) {
+    let mode = 'development';
+    let base = '/';
+    return {
+        name: 'rsc-delegate-plugin',
+        configResolved (config) {
+            mode = config.mode;
+            base = config.base;
+        },
+        transform (code, id) {
+            const ext = _nodepath.default.extname(id);
+            if (mode === 'development' && [
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx'
+            ].includes(ext)) {
+                const mod = _core.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ImportDeclaration') {
+                        if (item.source.value.startsWith('virtual:')) {
+                            // HACK this relies on Vite's internal implementation detail.
+                            const source = base + '@id/__x00__' + item.source.value;
+                            importCallback(source);
+                        } else if (CSS_LANGS_RE.test(item.source.value)) {
+                            const filePath = _nodepath.default.join(_nodepath.default.dirname(id), item.source.value);
+                            // HACK this relies on Vite's internal implementation detail.
+                            const source = base + '@fs/' + filePath.replace(/^\//, '');
+                            importCallback(source);
+                        }
+                    }
+                }
+            }
+            return code;
+        }
+    };
+}
diff --git a/dist/cjs/lib/vite-plugin/rsc-hmr-plugin.js b/dist/cjs/lib/vite-plugin/rsc-hmr-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..4d359e72d8c63059450924eb035b6863267c0868
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-hmr-plugin.js
@@ -0,0 +1,70 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    hotImport: function() {
+        return hotImport;
+    },
+    rscHmrPlugin: function() {
+        return rscHmrPlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+const customCode = `
+if (import.meta.hot && !globalThis.__WAKU_HMR_CONFIGURED__) {
+  globalThis.__WAKU_HMR_CONFIGURED__ = true;
+  import.meta.hot.on('hot-import', (data) => import(/* @vite-ignore */ data));
+}
+`;
+function rscHmrPlugin() {
+    return {
+        name: 'rsc-hmr-plugin',
+        async transform (code, id) {
+            const ext = _nodepath.default.extname(id);
+            if ([
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx'
+            ].includes(ext)) {
+                return code + customCode;
+            }
+            return code;
+        }
+    };
+}
+const pendingMap = new WeakMap();
+function hotImport(vite, source) {
+    let sourceSet = pendingMap.get(vite);
+    if (!sourceSet) {
+        sourceSet = new Set();
+        pendingMap.set(vite, sourceSet);
+        vite.ws.on('connection', ()=>{
+            for (const source of sourceSet){
+                vite.ws.send({
+                    type: 'custom',
+                    event: 'hot-import',
+                    data: source
+                });
+            }
+        });
+    }
+    sourceSet.add(source);
+    vite.ws.send({
+        type: 'custom',
+        event: 'hot-import',
+        data: source
+    });
+}
diff --git a/dist/cjs/lib/vite-plugin/rsc-index-plugin.js b/dist/cjs/lib/vite-plugin/rsc-index-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..592367c2eefcb5c3c028f96a329552797a00b593
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-index-plugin.js
@@ -0,0 +1,37 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscIndexPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscIndexPlugin;
+    }
+});
+const _utils = require("../middleware/rsc/utils.js");
+function rscIndexPlugin(cssAssets) {
+    return {
+        name: 'rsc-index-plugin',
+        async transformIndexHtml () {
+            return [
+                {
+                    tag: 'script',
+                    attrs: {
+                        type: 'module',
+                        async: true
+                    },
+                    children: _utils.codeToInject,
+                    injectTo: 'head-prepend'
+                },
+                ...cssAssets.map((href)=>({
+                        tag: 'link',
+                        attrs: {
+                            rel: 'stylesheet',
+                            href
+                        },
+                        injectTo: 'head'
+                    }))
+            ];
+        }
+    };
+}
diff --git a/dist/cjs/lib/vite-plugin/rsc-reload-plugin.js b/dist/cjs/lib/vite-plugin/rsc-reload-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..b3fa6cef45adf815b6331ae9dded6afcbd3fb197
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-reload-plugin.js
@@ -0,0 +1,99 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscReloadPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscReloadPlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _core = /*#__PURE__*/ _interop_require_wildcard(require("@swc/core"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscReloadPlugin(fn) {
+    let enabled = false;
+    const isClientEntry = (id, code)=>{
+        const ext = _nodepath.default.extname(id);
+        if ([
+            '.ts',
+            '.tsx',
+            '.js',
+            '.jsx'
+        ].includes(ext)) {
+            const mod = _core.parseSync(code, {
+                syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                tsx: ext === '.tsx'
+            });
+            for (const item of mod.body){
+                if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral' && item.expression.value === 'use client') {
+                    return true;
+                }
+            }
+        }
+        return false;
+    };
+    return {
+        name: 'rsc-reload-plugin',
+        configResolved (config) {
+            if (config.mode === 'development') {
+                enabled = true;
+            }
+        },
+        async handleHotUpdate (ctx) {
+            if (!enabled) {
+                return [];
+            }
+            if (ctx.modules.length && !isClientEntry(ctx.file, await ctx.read())) {
+                fn('full-reload');
+            } else {
+                return [];
+            }
+        }
+    };
+}
diff --git a/dist/cjs/lib/vite-plugin/rsc-transform-plugin.js b/dist/cjs/lib/vite-plugin/rsc-transform-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..0399129417e04b5279a3a7ccae62d0a63b8df0b3
--- /dev/null
+++ b/dist/cjs/lib/vite-plugin/rsc-transform-plugin.js
@@ -0,0 +1,117 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "rscTransformPlugin", {
+    enumerable: true,
+    get: function() {
+        return rscTransformPlugin;
+    }
+});
+const _nodepath = /*#__PURE__*/ _interop_require_default(require("node:path"));
+const _nodeloader = /*#__PURE__*/ _interop_require_wildcard(require("react-server-dom-webpack/node-loader"));
+function _interop_require_default(obj) {
+    return obj && obj.__esModule ? obj : {
+        default: obj
+    };
+}
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+function rscTransformPlugin() {
+    return {
+        name: 'rsc-transform-plugin',
+        async resolveId (id, importer, options) {
+            if (!id.endsWith('.js')) {
+                return id;
+            }
+            // FIXME This isn't necessary in production mode
+            // (But, waku/router may depend on this.)
+            for (const ext of [
+                '.js',
+                '.ts',
+                '.tsx',
+                '.jsx'
+            ]){
+                const resolved = await this.resolve(id.slice(0, -_nodepath.default.extname(id).length) + ext, importer, {
+                    ...options,
+                    skipSelf: true
+                });
+                if (resolved) {
+                    return resolved;
+                }
+            }
+        },
+        async transform (code, id) {
+            const resolve = async (specifier, { parentURL })=>{
+                if (!specifier) {
+                    return {
+                        url: ''
+                    };
+                }
+                const url = (await this.resolve(specifier, parentURL, {
+                    skipSelf: true
+                })).id;
+                return {
+                    url
+                };
+            };
+            const load = async (url)=>{
+                let source = url === id ? code : (await this.load({
+                    id: url
+                })).code;
+                // HACK move directives before import statements.
+                source = source.replace(/^(import {.*?} from ".*?";)\s*"use (client|server)";/, '"use $2";$1');
+                return {
+                    format: 'module',
+                    source
+                };
+            };
+            _nodeloader.resolve('', {
+                conditions: [
+                    'react-server'
+                ],
+                parentURL: ''
+            }, resolve);
+            return (await _nodeloader.load(id, null, load)).source;
+        }
+    };
+}
diff --git a/dist/cjs/main.js b/dist/cjs/main.js
new file mode 100644
index 0000000000000000000000000000000000000000..417f6eb788b4e75858309c70b60c6f7a179529de
--- /dev/null
+++ b/dist/cjs/main.js
@@ -0,0 +1,24 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    connectMiddleware: function() {
+        return _connectprd.connectMiddleware;
+    },
+    honoMiddleware: function() {
+        return _honoprd.honoMiddleware;
+    },
+    unstable_createHandler: function() {
+        return _handlerprd.createHandler;
+    }
+});
+const _honoprd = require("./lib/middleware/hono-prd.js");
+const _connectprd = require("./lib/middleware/connect-prd.js");
+const _handlerprd = require("./lib/handlers/handler-prd.js");
diff --git a/dist/cjs/node-loader.js b/dist/cjs/node-loader.js
new file mode 100644
index 0000000000000000000000000000000000000000..3193ae300ef07576cd5eef39f70309c22f5d947e
--- /dev/null
+++ b/dist/cjs/node-loader.js
@@ -0,0 +1,91 @@
+/**
+ * We manually call the hooks on react-server-dom-webpack/node-loader.
+ * 1. `react-server-dom-webpack/node-loader` uses Node.js 18 deprecated API.
+ * 2. `conditions` will not be read in ESM,
+ *      which will lead to a React warning on Node.js 20.
+ *      Refs: https://github.com/nodejs/node/issues/50885
+ */ "use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    load: function() {
+        return load;
+    },
+    resolve: function() {
+        return resolve;
+    }
+});
+const _nodeloader = /*#__PURE__*/ _interop_require_wildcard(require("react-server-dom-webpack/node-loader"));
+function _getRequireWildcardCache(nodeInterop) {
+    if (typeof WeakMap !== "function") return null;
+    var cacheBabelInterop = new WeakMap();
+    var cacheNodeInterop = new WeakMap();
+    return (_getRequireWildcardCache = function(nodeInterop) {
+        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
+    })(nodeInterop);
+}
+function _interop_require_wildcard(obj, nodeInterop) {
+    if (!nodeInterop && obj && obj.__esModule) {
+        return obj;
+    }
+    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
+        return {
+            default: obj
+        };
+    }
+    var cache = _getRequireWildcardCache(nodeInterop);
+    if (cache && cache.has(obj)) {
+        return cache.get(obj);
+    }
+    var newObj = {
+        __proto__: null
+    };
+    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
+    for(var key in obj){
+        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
+            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
+            if (desc && (desc.get || desc.set)) {
+                Object.defineProperty(newObj, key, desc);
+            } else {
+                newObj[key] = obj[key];
+            }
+        }
+    }
+    newObj.default = obj;
+    if (cache) {
+        cache.set(obj, newObj);
+    }
+    return newObj;
+}
+const load = async (url, context, nextLoad)=>{
+    return _nodeloader.load(url, context, async (reqUrl, context)=>{
+        const result = await nextLoad(reqUrl, context);
+        if (result.format === 'module') {
+            let { source } = result;
+            if (source && typeof source !== 'string') {
+                source = source.toString();
+                return {
+                    ...result,
+                    source
+                };
+            }
+        }
+        return result;
+    });
+};
+const resolve = async (specifier, context, nextResolve)=>{
+    return _nodeloader.resolve(specifier, {
+        ...context,
+        conditions: [
+            ...context.conditions,
+            'react-server'
+        ]
+    }, nextResolve);
+};
diff --git a/dist/cjs/package.json b/dist/cjs/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..641481328076b2a76950a8bcfc19ec43666d5bb1
--- /dev/null
+++ b/dist/cjs/package.json
@@ -0,0 +1 @@
+'{"type":"commonjs"}' 
diff --git a/dist/cjs/router/client.js b/dist/cjs/router/client.js
new file mode 100644
index 0000000000000000000000000000000000000000..2142064770db58e4333a732b1373831a06464bbe
--- /dev/null
+++ b/dist/cjs/router/client.js
@@ -0,0 +1,235 @@
+'use client';
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    Link: function() {
+        return Link;
+    },
+    Router: function() {
+        return Router;
+    },
+    useChangeLocation: function() {
+        return useChangeLocation;
+    },
+    useLocation: function() {
+        return useLocation;
+    }
+});
+const _react = require("react");
+const _client = require("../client.js");
+const _common = require("./common.js");
+const parseLocation = ()=>{
+    const { pathname, search } = window.location;
+    const searchParams = new URLSearchParams(search);
+    if (searchParams.has(_common.PARAM_KEY_SKIP)) {
+        console.warn(`The search param "${_common.PARAM_KEY_SKIP}" is reserved`);
+    }
+    return {
+        path: pathname,
+        searchParams
+    };
+};
+const RouterContext = (0, _react.createContext)(null);
+function useChangeLocation() {
+    const value = (0, _react.useContext)(RouterContext);
+    if (!value) {
+        return ()=>{
+            throw new Error('Missing Router');
+        };
+    }
+    return value.changeLocation;
+}
+function useLocation() {
+    const value = (0, _react.useContext)(RouterContext);
+    if (!value) {
+        throw new Error('Missing Router');
+    }
+    return value.loc;
+}
+function Link({ href, children, pending, notPending, unstable_prefetchOnEnter }) {
+    const value = (0, _react.useContext)(RouterContext);
+    const changeLocation = value ? value.changeLocation : ()=>{
+        throw new Error('Missing Router');
+    };
+    const prefetchLocation = value ? value.prefetchLocation : ()=>{
+        throw new Error('Missing Router');
+    };
+    const [isPending, startTransition] = (0, _react.useTransition)();
+    const onClick = (event)=>{
+        event.preventDefault();
+        const url = new URL(href, window.location.href);
+        if (url.href !== window.location.href) {
+            prefetchLocation(url.pathname, url.searchParams);
+            startTransition(()=>{
+                changeLocation(url.pathname, url.searchParams);
+            });
+        }
+    };
+    const onMouseEnter = unstable_prefetchOnEnter ? ()=>{
+        const url = new URL(href, window.location.href);
+        if (url.href !== window.location.href) {
+            prefetchLocation(url.pathname, url.searchParams);
+        }
+    } : undefined;
+    const ele = (0, _react.createElement)('a', {
+        href,
+        onClick,
+        onMouseEnter
+    }, children);
+    if (isPending && pending !== undefined) {
+        return (0, _react.createElement)(_react.Fragment, null, ele, pending);
+    }
+    if (!isPending && notPending !== undefined) {
+        return (0, _react.createElement)(_react.Fragment, null, ele, notPending);
+    }
+    return ele;
+}
+const getSkipList = (componentIds, props, cached)=>{
+    const ele = document.querySelector('meta[name="waku-should-skip"]');
+    if (!ele) {
+        return [];
+    }
+    const shouldSkip = JSON.parse(ele.content);
+    return componentIds.filter((id)=>{
+        const prevProps = cached[id];
+        if (!prevProps) {
+            return false;
+        }
+        const shouldCheck = shouldSkip?.[id];
+        if (!shouldCheck) {
+            return false;
+        }
+        if (shouldCheck.path && props.path !== prevProps.path) {
+            return false;
+        }
+        if (shouldCheck.keys?.some((key)=>props.searchParams.get(key) !== prevProps.searchParams.get(key))) {
+            return false;
+        }
+        return true;
+    });
+};
+function InnerRouter({ basePath }) {
+    const refetch = (0, _client.useRefetch)();
+    const [loc, setLoc] = (0, _react.useState)(parseLocation);
+    const componentIds = (0, _common.getComponentIds)(loc.path);
+    const [cached, setCached] = (0, _react.useState)(()=>{
+        return Object.fromEntries(componentIds.map((id)=>[
+                id,
+                loc
+            ]));
+    });
+    const cachedRef = (0, _react.useRef)(cached);
+    (0, _react.useEffect)(()=>{
+        cachedRef.current = cached;
+    }, [
+        cached
+    ]);
+    const changeLocation = (0, _react.useCallback)((path, searchParams, mode = 'push')=>{
+        const url = new URL(window.location.href);
+        if (path) {
+            url.pathname = path;
+        }
+        if (searchParams) {
+            url.search = '?' + searchParams.toString();
+        }
+        if (mode === 'replace') {
+            window.history.replaceState(window.history.state, '', url);
+        } else if (mode === 'push') {
+            window.history.pushState(window.history.state, '', url);
+        }
+        const loc = parseLocation();
+        setLoc(loc);
+        const componentIds = (0, _common.getComponentIds)(loc.path);
+        const skip = getSkipList(componentIds, loc, cachedRef.current);
+        if (componentIds.every((id)=>skip.includes(id))) {
+            return; // everything is cached
+        }
+        const input = (0, _common.getInputString)(loc.path);
+        refetch(input, new URLSearchParams([
+            ...Array.from(loc.searchParams.entries()),
+            ...skip.map((id)=>[
+                    _common.PARAM_KEY_SKIP,
+                    id
+                ])
+        ]));
+        setCached((prev)=>({
+                ...prev,
+                ...Object.fromEntries(componentIds.flatMap((id)=>skip.includes(id) ? [] : [
+                        [
+                            id,
+                            loc
+                        ]
+                    ]))
+            }));
+    }, [
+        refetch
+    ]);
+    const prefetchLocation = (0, _react.useCallback)((path, searchParams)=>{
+        const componentIds = (0, _common.getComponentIds)(path);
+        const routeProps = {
+            path,
+            searchParams
+        };
+        const skip = getSkipList(componentIds, routeProps, cachedRef.current);
+        if (componentIds.every((id)=>skip.includes(id))) {
+            return; // everything is cached
+        }
+        const input = (0, _common.getInputString)(path);
+        const searchParamsString = new URLSearchParams([
+            ...Array.from(searchParams.entries()),
+            ...skip.map((id)=>[
+                    _common.PARAM_KEY_SKIP,
+                    id
+                ])
+        ]).toString();
+        (0, _client.prefetchRSC)(input, searchParamsString, basePath);
+        globalThis.__WAKU_ROUTER_PREFETCH__?.(path);
+    }, [
+        basePath
+    ]);
+    (0, _react.useEffect)(()=>{
+        const callback = ()=>{
+            const loc = parseLocation();
+            prefetchLocation(loc.path, loc.searchParams);
+            changeLocation(loc.path, loc.searchParams, false);
+        };
+        window.addEventListener('popstate', callback);
+        return ()=>window.removeEventListener('popstate', callback);
+    }, [
+        changeLocation,
+        prefetchLocation
+    ]);
+    const children = componentIds.reduceRight((acc, id)=>(0, _react.createElement)(_client.Slot, {
+            id,
+            fallback: (children)=>children
+        }, acc), null);
+    return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_client.Slot, {
+        id: _common.SHOULD_SKIP_ID
+    }), (0, _react.createElement)(RouterContext.Provider, {
+        value: {
+            loc,
+            changeLocation,
+            prefetchLocation
+        }
+    }, children));
+}
+function Router({ basePath = '/RSC/' }) {
+    const loc = parseLocation();
+    const initialInput = (0, _common.getInputString)(loc.path);
+    const initialSearchParamsString = loc.searchParams.toString();
+    return (0, _react.createElement)(_client.Root, {
+        initialInput,
+        initialSearchParamsString,
+        basePath
+    }, (0, _react.createElement)(InnerRouter, {
+        basePath
+    }));
+}
diff --git a/dist/cjs/router/common.js b/dist/cjs/router/common.js
new file mode 100644
index 0000000000000000000000000000000000000000..226f72f2f2378931febb9550019930760d07b76a
--- /dev/null
+++ b/dist/cjs/router/common.js
@@ -0,0 +1,54 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    PARAM_KEY_SKIP: function() {
+        return PARAM_KEY_SKIP;
+    },
+    SHOULD_SKIP_ID: function() {
+        return SHOULD_SKIP_ID;
+    },
+    getComponentIds: function() {
+        return getComponentIds;
+    },
+    getInputString: function() {
+        return getInputString;
+    },
+    parseInputString: function() {
+        return parseInputString;
+    }
+});
+function getComponentIds(path) {
+    const pathItems = path.split('/').filter(Boolean);
+    const idSet = new Set();
+    for(let index = 0; index <= pathItems.length; ++index){
+        const id = [
+            ...pathItems.slice(0, index),
+            'layout'
+        ].join('/');
+        idSet.add(id);
+    }
+    idSet.add([
+        ...pathItems,
+        'page'
+    ].join('/'));
+    return Array.from(idSet);
+}
+function getInputString(path) {
+    if (!path.startsWith('/')) {
+        throw new Error('Path should start with `/`');
+    }
+    return path.slice(1);
+}
+function parseInputString(input) {
+    return '/' + input;
+}
+const PARAM_KEY_SKIP = 'waku_router_skip';
+const SHOULD_SKIP_ID = '/SHOULD_SKIP';
diff --git a/dist/cjs/router/server.js b/dist/cjs/router/server.js
new file mode 100644
index 0000000000000000000000000000000000000000..7e630960a638255c6ced20a255a99abb6ec5a9d5
--- /dev/null
+++ b/dist/cjs/router/server.js
@@ -0,0 +1,347 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+function _export(target, all) {
+    for(var name in all)Object.defineProperty(target, name, {
+        enumerable: true,
+        get: all[name]
+    });
+}
+_export(exports, {
+    createPages: function() {
+        return createPages;
+    },
+    defineRouter: function() {
+        return defineRouter;
+    }
+});
+const _react = require("react");
+const _client = require("../client.js");
+const _common = require("./common.js");
+const _path = require("../lib/utils/path.js");
+const ShoudSkipComponent = ({ shouldSkip })=>(0, _react.createElement)('meta', {
+        name: 'waku-should-skip',
+        content: JSON.stringify(shouldSkip)
+    });
+function defineRouter(existsPath, getComponent, getPathsForBuild) {
+    const shouldSkip = {};
+    const renderEntries = async (input, searchParams)=>{
+        const path = (0, _common.parseInputString)(input);
+        if (!await existsPath(path)) {
+            return null;
+        }
+        const skip = searchParams.getAll(_common.PARAM_KEY_SKIP) || [];
+        const componentIds = (0, _common.getComponentIds)(path);
+        const props = {
+            path,
+            searchParams
+        };
+        const entries = (await Promise.all(componentIds.map(async (id)=>{
+            if (skip?.includes(id)) {
+                return [];
+            }
+            const mod = await getComponent(id, (val)=>{
+                if (val) {
+                    shouldSkip[id] = val;
+                } else {
+                    delete shouldSkip[id];
+                }
+            });
+            const component = mod && 'default' in mod ? mod.default : mod;
+            if (!component) {
+                return [];
+            }
+            const element = (0, _react.createElement)(component, props, (0, _react.createElement)(_client.Children));
+            return [
+                [
+                    id,
+                    element
+                ]
+            ];
+        }))).flat();
+        entries.push([
+            _common.SHOULD_SKIP_ID,
+            (0, _react.createElement)(ShoudSkipComponent, {
+                shouldSkip
+            })
+        ]);
+        return Object.fromEntries(entries);
+    };
+    const getBuildConfig = async (unstable_collectClientModules)=>{
+        const pathsForBuild = await getPathsForBuild?.();
+        const path2moduleIds = {};
+        for (const path of pathsForBuild || []){
+            const input = (0, _common.getInputString)(path);
+            const moduleIds = await unstable_collectClientModules(input);
+            path2moduleIds[path] = moduleIds;
+        }
+        const customCode = `
+globalThis.__WAKU_ROUTER_PREFETCH__ = (path) => {
+  const path2ids = ${JSON.stringify(path2moduleIds)};
+  for (const id of path2ids[path] || []) {
+    import(id);
+  }
+};`;
+        const buildConfig = [];
+        for (const path of pathsForBuild || []){
+            const isStatic = await existsPath(path) === 'static';
+            const input = (0, _common.getInputString)(path);
+            const entries = [
+                {
+                    input,
+                    isStatic
+                }
+            ];
+            buildConfig.push({
+                pathname: path,
+                entries,
+                customCode
+            });
+        }
+        return buildConfig;
+    };
+    const getSsrConfig = async (pathname, { isPrd })=>{
+        const pathType = await existsPath(pathname);
+        if (isPrd ? pathType !== 'dynamic' : pathType === null) {
+            return null;
+        }
+        const componentIds = (0, _common.getComponentIds)(pathname);
+        const input = (0, _common.getInputString)(pathname);
+        const render = ({ createElement, Fragment, Slot })=>createElement(Fragment, null, createElement(Slot, {
+                id: _common.SHOULD_SKIP_ID
+            }), componentIds.reduceRight((acc, id)=>createElement(Slot, {
+                    id,
+                    fallback: (children)=>children
+                }, acc), null));
+        return {
+            input,
+            unstable_render: render
+        };
+    };
+    return {
+        renderEntries,
+        getBuildConfig,
+        getSsrConfig
+    };
+}
+const parsePath = (path)=>path.replace(/^\//, '').split('/').map((name)=>{
+        const isSlug = name.startsWith('[') && name.endsWith(']');
+        if (isSlug) {
+            name = name.slice(1, -1);
+        }
+        const isWildcard = name.startsWith('...');
+        if (isWildcard) {
+            name = name.slice(3);
+        }
+        return {
+            name,
+            isSlug,
+            isWildcard
+        };
+    });
+const getDynamicMapping = (parsedPath, actual)=>{
+    if (parsedPath.length !== actual.length) {
+        return null;
+    }
+    const mapping = {};
+    for(let i = 0; i < parsedPath.length; i++){
+        const { name, isSlug } = parsedPath[i];
+        if (isSlug) {
+            mapping[name] = actual[i];
+        } else {
+            if (name !== actual[i]) {
+                return null;
+            }
+        }
+    }
+    return mapping;
+};
+const getWildcardMapping = (parsedPath, actual)=>{
+    if (parsedPath.length > actual.length) {
+        return null;
+    }
+    const mapping = {};
+    let wildcardStartIndex = -1;
+    for(let i = 0; i < parsedPath.length; i++){
+        const { name, isSlug, isWildcard } = parsedPath[i];
+        if (isWildcard) {
+            wildcardStartIndex = i;
+            break;
+        } else if (isSlug) {
+            mapping[name] = actual[i];
+        } else {
+            if (name !== actual[i]) {
+                return null;
+            }
+        }
+    }
+    let wildcardEndIndex = -1;
+    for(let i = 0; i < parsedPath.length; i++){
+        const { name, isSlug, isWildcard } = parsedPath[parsedPath.length - i - 1];
+        if (isWildcard) {
+            wildcardEndIndex = actual.length - i - 1;
+            break;
+        } else if (isSlug) {
+            mapping[name] = actual[actual.length - i - 1];
+        } else {
+            if (name !== actual[actual.length - i - 1]) {
+                return null;
+            }
+        }
+    }
+    if (wildcardStartIndex === -1 || wildcardEndIndex === -1) {
+        throw new Error('Invalid wildcard path');
+    }
+    mapping[parsedPath[wildcardStartIndex].name] = actual.slice(wildcardStartIndex, wildcardEndIndex + 1).join('/');
+    return mapping;
+};
+function createPages(fn) {
+    let configured = false;
+    const staticPathSet = new Set();
+    const dynamicPathMap = new Map();
+    const wildcardPathMap = new Map();
+    const staticComponentMap = new Map();
+    const registerStaticComponent = (id, component)=>{
+        if (staticComponentMap.has(id) && staticComponentMap.get(id) !== component) {
+            throw new Error(`Duplicated component for: ${id}`);
+        }
+        staticComponentMap.set(id, component);
+    };
+    const createPage = (page)=>{
+        if (configured) {
+            throw new Error('no longer available');
+        }
+        const parsedPath = parsePath(page.path);
+        const numSlugs = parsedPath.filter(({ isSlug })=>isSlug).length;
+        const numWildcards = parsedPath.filter(({ isWildcard })=>isWildcard).length;
+        if (page.render === 'static' && numSlugs === 0) {
+            staticPathSet.add(page.path);
+            const id = (0, _path.joinPath)(page.path, 'page').replace(/^\//, '');
+            registerStaticComponent(id, page.component);
+        } else if (page.render === 'static' && numSlugs > 0 && numWildcards === 0) {
+            const staticPaths = page.staticPaths.map((item)=>Array.isArray(item) ? item : [
+                    item
+                ]);
+            for (const staticPath of staticPaths){
+                if (staticPath.length !== numSlugs) {
+                    throw new Error('staticPaths does not match with slug pattern');
+                }
+                const mapping = {};
+                let slugIndex = 0;
+                const pathItems = parsedPath.map(({ name, isSlug })=>{
+                    if (isSlug) {
+                        return mapping[name] = staticPath[slugIndex++];
+                    }
+                    return name;
+                });
+                staticPathSet.add('/' + (0, _path.joinPath)(...pathItems));
+                const id = (0, _path.joinPath)(...pathItems, 'page');
+                const WrappedComponent = (props)=>(0, _react.createElement)(page.component, {
+                        ...props,
+                        ...mapping
+                    });
+                registerStaticComponent(id, WrappedComponent);
+            }
+        } else if (page.render === 'dynamic' && numWildcards === 0) {
+            if (dynamicPathMap.has(page.path)) {
+                throw new Error(`Duplicated dynamic path: ${page.path}`);
+            }
+            dynamicPathMap.set(page.path, [
+                parsedPath,
+                page.component
+            ]);
+        } else if (page.render === 'dynamic' && numWildcards === 1) {
+            if (wildcardPathMap.has(page.path)) {
+                throw new Error(`Duplicated dynamic path: ${page.path}`);
+            }
+            wildcardPathMap.set(page.path, [
+                parsedPath,
+                page.component
+            ]);
+        } else {
+            throw new Error('Invalid page configuration');
+        }
+    };
+    const createLayout = (layout)=>{
+        if (configured) {
+            throw new Error('no longer available');
+        }
+        const id = (0, _path.joinPath)(layout.path, 'layout').replace(/^\//, '');
+        registerStaticComponent(id, layout.component);
+    };
+    const ready = fn({
+        createPage,
+        createLayout
+    }).then(()=>{
+        configured = true;
+    });
+    return defineRouter(async (path)=>{
+        await ready;
+        if (staticPathSet.has(path)) {
+            return 'static';
+        }
+        for (const [parsedPath] of dynamicPathMap.values()){
+            const mapping = getDynamicMapping(parsedPath, path.split('/').slice(1));
+            if (mapping) {
+                return 'dynamic';
+            }
+        }
+        for (const [parsedPath] of wildcardPathMap.values()){
+            const mapping = getWildcardMapping(parsedPath, path.split('/').slice(1));
+            if (mapping) {
+                return 'dynamic';
+            }
+        }
+        return null; // not found
+    }, async (id, unstable_setShouldSkip)=>{
+        await ready;
+        const staticComponent = staticComponentMap.get(id);
+        if (staticComponent) {
+            unstable_setShouldSkip({});
+            return staticComponent;
+        }
+        for (const [parsedPath, Component] of dynamicPathMap.values()){
+            const mapping = getDynamicMapping([
+                ...parsedPath,
+                {
+                    name: 'page',
+                    isSlug: false,
+                    isWildcard: false
+                }
+            ], id.split('/'));
+            if (mapping) {
+                if (Object.keys(mapping).length === 0) {
+                    unstable_setShouldSkip();
+                    return Component;
+                }
+                const WrappedComponent = (props)=>(0, _react.createElement)(Component, {
+                        ...props,
+                        ...mapping
+                    });
+                unstable_setShouldSkip();
+                return WrappedComponent;
+            }
+        }
+        for (const [parsedPath, Component] of wildcardPathMap.values()){
+            const mapping = getWildcardMapping([
+                ...parsedPath,
+                {
+                    name: 'page',
+                    isSlug: false,
+                    isWildcard: false
+                }
+            ], id.split('/'));
+            if (mapping) {
+                const WrappedComponent = (props)=>(0, _react.createElement)(Component, {
+                        ...props,
+                        ...mapping
+                    });
+                unstable_setShouldSkip();
+                return WrappedComponent;
+            }
+        }
+        unstable_setShouldSkip({}); // negative cache
+        return null; // not found
+    }, async ()=>staticPathSet);
+}
diff --git a/dist/cjs/server.js b/dist/cjs/server.js
new file mode 100644
index 0000000000000000000000000000000000000000..333efa807e1028d284c8cb1290d012be342a3177
--- /dev/null
+++ b/dist/cjs/server.js
@@ -0,0 +1,17 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", {
+    value: true
+});
+Object.defineProperty(exports, "defineEntries", {
+    enumerable: true,
+    get: function() {
+        return defineEntries;
+    }
+});
+function defineEntries(renderEntries, getBuildConfig, getSsrConfig) {
+    return {
+        renderEntries,
+        getBuildConfig,
+        getSsrConfig
+    };
+}
diff --git a/dist/cjs/types.d.js b/dist/cjs/types.d.js
new file mode 100644
index 0000000000000000000000000000000000000000..3918c74e446336be4151ea3bdad00f4d9e6df47a
--- /dev/null
+++ b/dist/cjs/types.d.js
@@ -0,0 +1 @@
+"use strict";
diff --git a/dist/cli.js b/dist/cli.js
index aaded42819feb6217872c21e6fd3f2e18cbb2737..6e0c47d8eab55fb86256267f7c93c900e405b32e 100644
--- a/dist/cli.js
+++ b/dist/cli.js
@@ -4,6 +4,7 @@ import { pathToFileURL } from 'node:url';
 import { parseArgs } from 'node:util';
 import { createRequire } from 'node:module';
 import { Hono } from 'hono';
+import { contextStorage } from 'hono/context-storage';
 import { serve } from '@hono/node-server';
 import { serveStatic } from '@hono/node-server/serve-static';
 import * as dotenv from 'dotenv';
@@ -90,7 +91,9 @@ if (values.version) {
 }
 async function runDev() {
     const config = await loadConfig();
+    const honoEnhancer = config.unstable_honoEnhancer || ((app)=>app);
     const app = new Hono();
+    app.use(contextStorage());
     app.use('*', runner({
         cmd: 'dev',
         config,
@@ -105,7 +108,7 @@ async function runDev() {
         return c.text('404 Not Found', 404);
     });
     const port = parseInt(values.port || '3000', 10);
-    await startServer(app, port);
+    await startServer(honoEnhancer(app), port);
 }
 async function runBuild() {
     const config = await loadConfig();
@@ -118,9 +121,12 @@ async function runBuild() {
     });
 }
 async function runStart() {
-    const { distDir = 'dist' } = await loadConfig();
+    const config = await loadConfig();
+    const { distDir = 'dist' } = config;
+    const honoEnhancer = config.unstable_honoEnhancer || ((app)=>app);
     const loadEntries = ()=>import(pathToFileURL(path.resolve(distDir, DIST_ENTRIES_JS)).toString());
     const app = new Hono();
+    app.use(contextStorage());
     app.use('*', serveStatic({
         root: path.join(distDir, DIST_PUBLIC)
     }));
@@ -138,7 +144,7 @@ async function runStart() {
         return c.text('404 Not Found', 404);
     });
     const port = parseInt(values.port || '8080', 10);
-    await startServer(app, port);
+    await startServer(honoEnhancer(app), port);
 }
 function startServer(app, port) {
     return new Promise((resolve, reject)=>{
diff --git a/dist/client.d.ts b/dist/client.d.ts
index 991bd6487e70b0629e3f46092cc4e77ceae27400..e60d1ef5fba3ab4348a05faac36b9a40e11a82e5 100644
--- a/dist/client.d.ts
+++ b/dist/client.d.ts
@@ -1,59 +1,32 @@
-import { Component } from 'react';
 import type { ReactNode } from 'react';
 declare global {
     interface ImportMeta {
         readonly env: Record<string, string>;
     }
 }
-type Elements = Promise<Record<string, ReactNode>> & {
-    prev?: Record<string, ReactNode> | undefined;
-};
-type SetElements = (updater: (prev: Elements) => Elements) => void;
-type OnFetchData = (data: unknown) => void;
-declare const ENTRY = "e";
-declare const SET_ELEMENTS = "s";
-declare const ON_FETCH_DATA = "o";
-type FetchCache = {
-    [ENTRY]?: [input: string, params: unknown, elements: Elements];
-    [SET_ELEMENTS]?: SetElements;
-    [ON_FETCH_DATA]?: OnFetchData | undefined;
-};
-/**
- * callServer callback
- * This is not a public API.
- */
-export declare const callServerRSC: (actionId: string, args?: unknown[], fetchCache?: FetchCache) => Promise<bigint | import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | import("react").AwaitedReactNode>;
-export declare const fetchRSC: (input: string, params?: unknown, fetchCache?: FetchCache) => Elements;
-export declare const prefetchRSC: (input: string, params?: unknown) => void;
-export declare const Root: ({ initialInput, initialParams, fetchCache, unstable_onFetchData, children, }: {
+type Elements = Promise<Record<string, ReactNode>>;
+type SetElements = (updater: Elements | ((prev: Elements) => Elements)) => void;
+type CacheEntry = [
+    input: string,
+    searchParamsString: string,
+    setElements: SetElements,
+    elements: Elements
+];
+declare const fetchCache: [CacheEntry?];
+export declare const fetchRSC: (input: string, searchParamsString: string, setElements: SetElements, cache?: [CacheEntry?]) => Elements;
+export declare const prefetchRSC: (input: string, searchParamsString: string) => void;
+export declare const Root: ({ initialInput, initialSearchParamsString, cache, children, }: {
     initialInput?: string;
-    initialParams?: unknown;
-    fetchCache?: FetchCache;
-    unstable_onFetchData?: (data: unknown) => void;
+    initialSearchParamsString?: string;
+    cache?: typeof fetchCache;
     children: ReactNode;
-}) => import("react").FunctionComponentElement<import("react").ProviderProps<(input: string, params?: unknown) => void>>;
-export declare const useRefetch: () => (input: string, params?: unknown) => void;
-type OuterSlotProps = {
-    elementsPromise: Elements;
-    shouldRenderPrev: ((err: unknown) => boolean) | undefined;
-    renderSlot: (elements: Record<string, ReactNode>) => ReactNode;
-    children?: ReactNode;
-};
-declare class OuterSlot extends Component<OuterSlotProps, {
-    error?: unknown;
-}> {
-    constructor(props: OuterSlotProps);
-    static getDerivedStateFromError(error: unknown): {
-        error: unknown;
-    };
-    render(): ReactNode;
-}
-export declare const Slot: ({ id, children, fallback, unstable_shouldRenderPrev, }: {
+}) => import("react").FunctionComponentElement<import("react").ProviderProps<(input: string, searchParams?: URLSearchParams) => void>>;
+export declare const useRefetch: () => (input: string, searchParams?: URLSearchParams) => void;
+export declare const Slot: ({ id, children, fallback, }: {
     id: string;
     children?: ReactNode;
     fallback?: ReactNode;
-    unstable_shouldRenderPrev?: (err: unknown) => boolean;
-}) => import("react").CElement<OuterSlotProps, OuterSlot>;
+}) => string | number | true | import("react").ReactElement<any, string | import("react").JSXElementConstructor<any>> | Iterable<ReactNode> | import("react").FunctionComponentElement<import("react").ProviderProps<ReactNode>>;
 export declare const Children: () => ReactNode;
 /**
  * ServerRoot for SSR
diff --git a/dist/config.d.ts b/dist/config.d.ts
index 58bb1375394e90256564b9155f60b841ccf2fc43..0327931389650f82e4ec9fa820b70c1dd5ec916c 100644
--- a/dist/config.d.ts
+++ b/dist/config.d.ts
@@ -1,5 +1,4 @@
 import type { Middleware } from './lib/middleware/types.js';
-export type { Middleware };
 export interface Config {
     /**
      * The base path for serve HTTP.
@@ -8,6 +7,7 @@ export interface Config {
     basePath?: string;
     /**
      * The source directory relative to root.
+     * This will be the actual root in the development mode.
      * Defaults to  "src".
      */
     srcDir?: string;
@@ -18,6 +18,38 @@ export interface Config {
      */
     distDir?: string;
     /**
+     * The public directory relative to distDir.
+     * It's different from Vite's build.publicDir config.
+     * Defaults to "public".
+     */
+    publicDir?: string;
+    /**
+     * The assets directory relative to distDir and publicDir.
+     * Defaults to "assets".
+     */
+    assetsDir?: string;
+    /**
+     * The SSR directory relative to distDir.
+     * Defaults to "ssr".
+     */
+    ssrDir?: string;
+    /**
+     * The index.html file for any directories.
+     * Defaults to "index.html".
+     */
+    indexHtml?: string;
+    /**
+     * The client main file relative to srcDir.
+     * Defaults to "main.tsx".
+     */
+    mainJs?: string;
+    /**
+     * The entries.js file relative to srcDir or distDir.
+     * The extension should be `.js`,
+     * but resolved with `.ts`, `.tsx` and `.jsx` in the development mode.
+     * Defaults to "entries.js".
+     */
+    entriesJs?: string;
     /**
      * The list of directries to preserve server module structure.
      * Relative to srcDir.
@@ -30,22 +62,34 @@ export interface Config {
      * Defaults to  "private".
      */
     privateDir?: string;
+    /**
+     * The serve.js file relative distDir.
+     * This file is used for deployment.
+     * Defaults to "serve.js".
+     */
+    serveJs?: string;
     /**
      * Prefix for HTTP requests to indicate RSC requests.
      * Defaults to "RSC".
      */
     rscPath?: string;
+    /**
+     * HTML headers to inject.
+     * Defaults to:
+     * <meta charset="utf-8" />
+     * <meta name="viewport" content="width=device-width, initial-scale=1" />
+     */
+    htmlHead?: string;
     /**
      * Middleware to use
      * Defaults to:
-     * () => [
-     *   import('waku/middleware/dev-server'),
-     *   import('waku/middleware/headers'),
-     *   import('waku/middleware/rsc'),
+     * (cmd: 'dev' | 'start') => [
+     *   ...(cmd === 'dev' ? [import('waku/middleware/dev-server')] : []),
      *   import('waku/middleware/ssr'),
+     *   import('waku/middleware/rsc'),
      * ]
      */
-    middleware?: () => Promise<{
+    middleware?: (cmd: 'dev' | 'start') => Promise<{
         default: Middleware;
     }>[];
 }
diff --git a/dist/dev.d.ts b/dist/dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3ca4d048eb80558871a2fb876b1531caa84410e0
--- /dev/null
+++ b/dist/dev.d.ts
@@ -0,0 +1,3 @@
+export { honoMiddleware as unstable_honoMiddleware } from './lib/old-wrappers/hono-dev.js';
+export { connectMiddleware as unstable_connectMiddleware } from './lib/old-wrappers/connect-dev.js';
+export { build as unstable_build } from './lib/builder/build.js';
diff --git a/dist/dev.js b/dist/dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..3ca4d048eb80558871a2fb876b1531caa84410e0
--- /dev/null
+++ b/dist/dev.js
@@ -0,0 +1,3 @@
+export { honoMiddleware as unstable_honoMiddleware } from './lib/old-wrappers/hono-dev.js';
+export { connectMiddleware as unstable_connectMiddleware } from './lib/old-wrappers/connect-dev.js';
+export { build as unstable_build } from './lib/builder/build.js';
diff --git a/dist/internals.d.ts b/dist/internals.d.ts
deleted file mode 100644
index 20e2bfdc8a09af36a9a01e6f95de0703e6c0f23c..0000000000000000000000000000000000000000
diff --git a/dist/lib/builder/build.d.ts b/dist/lib/builder/build.d.ts
index 0dff6833b10cad88e2621247deb98e8c025e5843..41311f1160be182fcd546b904bf2bf32a0e1dfba 100644
--- a/dist/lib/builder/build.d.ts
+++ b/dist/lib/builder/build.d.ts
@@ -2,6 +2,5 @@ import type { Config } from '../../config.js';
 export declare function build(options: {
     config: Config;
     env?: Record<string, string>;
-    partial?: boolean;
     deploy?: 'vercel-static' | 'vercel-serverless' | 'netlify-static' | 'netlify-functions' | 'cloudflare' | 'partykit' | 'deno' | 'aws-lambda' | undefined;
 }): Promise<void>;
diff --git a/dist/lib/builder/build.js b/dist/lib/builder/build.js
index 5feec962265bc90a53103f4899c665beedd74652..1f4fe0b351413b97d34e96512741d4781f5c3a8e 100644
--- a/dist/lib/builder/build.js
+++ b/dist/lib/builder/build.js
@@ -3,7 +3,8 @@ import { pipeline } from 'node:stream/promises';
 import { build as buildVite, resolveConfig as resolveViteConfig } from 'vite';
 import viteReact from '@vitejs/plugin-react';
 import { unstable_getPlatformObject } from '../../server.js';
-import { resolveConfig, EXTENSIONS } from '../config.js';
+import { resolveConfig } from '../config.js';
+import { EXTENSIONS } from '../constants.js';
 import { decodeFilePathFromAbsolute, extname, filePathToFileURL, fileURLToFilePath, getPathMapping, joinPath } from '../utils/path.js';
 import { appendFile, createWriteStream, existsSync, mkdir, readdir, readFile, rename, unlink, writeFile } from '../utils/node-fs.js';
 import { encodeInput, generatePrefetchCode } from '../renderers/utils.js';
@@ -78,7 +79,8 @@ const analyzeEntries = async (rootDir, config)=>{
             rscManagedPlugin({
                 ...config,
                 addEntriesToInput: true
-            })
+            }),
+            ...deployPlugins(config)
         ],
         ssr: {
             target: 'webworker',
@@ -112,7 +114,8 @@ const analyzeEntries = async (rootDir, config)=>{
                 isClient: true,
                 serverFileSet
             }),
-            rscManagedPlugin(config)
+            rscManagedPlugin(config),
+            ...deployPlugins(config)
         ],
         ssr: {
             target: 'webworker',
@@ -140,7 +143,7 @@ const analyzeEntries = async (rootDir, config)=>{
     };
 };
 // For RSC
-const buildServerBundle = async (rootDir, env, config, clientEntryFiles, serverEntryFiles, serverModuleFiles, isNodeCompatible, partial)=>{
+const buildServerBundle = async (rootDir, env, config, clientEntryFiles, serverEntryFiles, serverModuleFiles, partial)=>{
     const serverBuildOutput = await buildVite({
         plugins: [
             nonjsResolvePlugin(),
@@ -185,7 +188,7 @@ const buildServerBundle = async (rootDir, env, config, clientEntryFiles, serverE
             }),
             ...deployPlugins(config)
         ],
-        ssr: isNodeCompatible ? {
+        ssr: {
             resolve: {
                 conditions: [
                     'react-server'
@@ -194,19 +197,9 @@ const buildServerBundle = async (rootDir, env, config, clientEntryFiles, serverE
                     'react-server'
                 ]
             },
-            noExternal: /^(?!node:)/
-        } : {
-            target: 'webworker',
-            resolve: {
-                conditions: [
-                    'react-server',
-                    'worker'
-                ],
-                externalConditions: [
-                    'react-server',
-                    'worker'
-                ]
-            },
+            external: [
+                'hono/context-storage'
+            ],
             noExternal: /^(?!node:)/
         },
         esbuild: {
@@ -239,7 +232,7 @@ const buildServerBundle = async (rootDir, env, config, clientEntryFiles, serverE
     return serverBuildOutput;
 };
 // For SSR (render client components on server to generate HTML)
-const buildSsrBundle = async (rootDir, env, config, clientEntryFiles, serverEntryFiles, serverBuildOutput, isNodeCompatible, partial)=>{
+const buildSsrBundle = async (rootDir, env, config, clientEntryFiles, serverEntryFiles, serverBuildOutput, partial)=>{
     const cssAssets = serverBuildOutput.output.flatMap(({ type, fileName })=>type === 'asset' && fileName.endsWith('.css') ? [
             fileName
         ] : []);
@@ -265,20 +258,10 @@ const buildSsrBundle = async (rootDir, env, config, clientEntryFiles, serverEntr
                 isClient: true,
                 isBuild: true,
                 serverEntryFiles
-            })
+            }),
+            ...deployPlugins(config)
         ],
-        ssr: isNodeCompatible ? {
-            noExternal: /^(?!node:)/
-        } : {
-            target: 'webworker',
-            resolve: {
-                conditions: [
-                    'worker'
-                ],
-                externalConditions: [
-                    'worker'
-                ]
-            },
+        ssr: {
             noExternal: /^(?!node:)/
         },
         esbuild: {
@@ -340,7 +323,8 @@ const buildClientBundle = async (rootDir, env, config, clientEntryFiles, serverE
                 isClient: true,
                 isBuild: true,
                 serverEntryFiles
-            })
+            }),
+            ...deployPlugins(config)
         ],
         build: {
             emptyOutDir: !partial,
@@ -549,6 +533,7 @@ export const publicIndexHtml = ${JSON.stringify(publicIndexHtml)};
     await appendFile(distEntriesFile, code);
 };
 // For Deploy
+// FIXME Is this a good approach? I wonder if there's something missing.
 const buildDeploy = async (rootDir, config)=>{
     const DUMMY = 'dummy-entry';
     await buildVite({
@@ -599,16 +584,15 @@ export async function build(options) {
     const config = await resolveConfig(options.config);
     const rootDir = (await resolveViteConfig({}, 'build', 'production', 'production')).root;
     const distEntriesFile = joinPath(rootDir, config.distDir, DIST_ENTRIES_JS);
-    const isNodeCompatible = options.deploy !== 'cloudflare' && options.deploy !== 'partykit' && options.deploy !== 'deno';
     const platformObject = unstable_getPlatformObject();
     platformObject.buildOptions ||= {};
     platformObject.buildOptions.deploy = options.deploy;
     platformObject.buildOptions.unstable_phase = 'analyzeEntries';
     const { clientEntryFiles, serverEntryFiles, serverModuleFiles } = await analyzeEntries(rootDir, config);
     platformObject.buildOptions.unstable_phase = 'buildServerBundle';
-    const serverBuildOutput = await buildServerBundle(rootDir, env, config, clientEntryFiles, serverEntryFiles, serverModuleFiles, isNodeCompatible, !!options.partial);
+    const serverBuildOutput = await buildServerBundle(rootDir, env, config, clientEntryFiles, serverEntryFiles, serverModuleFiles, !!options.partial);
     platformObject.buildOptions.unstable_phase = 'buildSsrBundle';
-    await buildSsrBundle(rootDir, env, config, clientEntryFiles, serverEntryFiles, serverBuildOutput, isNodeCompatible, !!options.partial);
+    await buildSsrBundle(rootDir, env, config, clientEntryFiles, serverEntryFiles, serverBuildOutput, !!options.partial);
     platformObject.buildOptions.unstable_phase = 'buildClientBundle';
     const clientBuildOutput = await buildClientBundle(rootDir, env, config, clientEntryFiles, serverEntryFiles, serverBuildOutput, !!options.partial);
     delete platformObject.buildOptions.unstable_phase;
@@ -625,5 +609,7 @@ export async function build(options) {
     platformObject.buildOptions.unstable_phase = 'buildDeploy';
     await buildDeploy(rootDir, config);
     delete platformObject.buildOptions.unstable_phase;
-    await appendFile(distEntriesFile, `export const buildData = ${JSON.stringify(platformObject.buildData)};`);
+    if (existsSync(distEntriesFile)) {
+        await appendFile(distEntriesFile, `export const buildData = ${JSON.stringify(platformObject.buildData)};`);
+    }
 }
diff --git a/dist/lib/builder/constants.d.ts b/dist/lib/builder/constants.d.ts
deleted file mode 100644
index e81598417d0e890d429afa9d292c752b6f2e0837..0000000000000000000000000000000000000000
diff --git a/dist/lib/builder/output-aws-lambda.d.ts b/dist/lib/builder/output-aws-lambda.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..68c2bd27e74c1e4b4f56433c89cf1f2c39f48099
--- /dev/null
+++ b/dist/lib/builder/output-aws-lambda.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitAwsLambdaOutput: (config: ResolvedConfig) => Promise<void>;
diff --git a/dist/lib/builder/output-aws-lambda.js b/dist/lib/builder/output-aws-lambda.js
new file mode 100644
index 0000000000000000000000000000000000000000..89343f18fb34b4e192e32ac140cbcb236cc4559e
--- /dev/null
+++ b/dist/lib/builder/output-aws-lambda.js
@@ -0,0 +1,7 @@
+import path from 'node:path';
+import { writeFileSync } from 'node:fs';
+export const emitAwsLambdaOutput = async (config)=>{
+    writeFileSync(path.join(config.distDir, 'package.json'), JSON.stringify({
+        type: 'module'
+    }, null, 2));
+};
diff --git a/dist/lib/builder/output-cloudflare.d.ts b/dist/lib/builder/output-cloudflare.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..33f8b0408ff68a13520246c268edd98f26829179
--- /dev/null
+++ b/dist/lib/builder/output-cloudflare.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitCloudflareOutput: (rootDir: string, config: ResolvedConfig) => Promise<void>;
diff --git a/dist/lib/builder/output-cloudflare.js b/dist/lib/builder/output-cloudflare.js
new file mode 100644
index 0000000000000000000000000000000000000000..22bb976428166fde46d4e68aff9e5990cf2b9e24
--- /dev/null
+++ b/dist/lib/builder/output-cloudflare.js
@@ -0,0 +1,18 @@
+import path from 'node:path';
+import { existsSync, writeFileSync } from 'node:fs';
+import { DIST_PUBLIC } from './constants.js';
+// XXX this can be very limited. FIXME if anyone has better knowledge.
+export const emitCloudflareOutput = async (rootDir, config, serveJs)=>{
+    const wranglerTomlFile = path.join(rootDir, 'wrangler.toml');
+    if (!existsSync(wranglerTomlFile)) {
+        writeFileSync(wranglerTomlFile, `
+name = "waku-project"
+main = "${config.distDir}/${serveJs}"
+compatibility_date = "2023-12-06"
+compatibility_flags = [ "nodejs_als" ]
+
+[site]
+bucket = "./${config.distDir}/${DIST_PUBLIC}"
+`);
+    }
+};
diff --git a/dist/lib/builder/output-deno.d.ts b/dist/lib/builder/output-deno.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..dba8ce25ba836990f74d20216dccc07884038b28
--- /dev/null
+++ b/dist/lib/builder/output-deno.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitDenoOutput: (rootDir: string, config: ResolvedConfig, ssr: boolean) => Promise<void>;
diff --git a/dist/lib/builder/output-deno.js b/dist/lib/builder/output-deno.js
new file mode 100644
index 0000000000000000000000000000000000000000..b72368c6ea0bf944cc688510c31cdc3082e98218
--- /dev/null
+++ b/dist/lib/builder/output-deno.js
@@ -0,0 +1,25 @@
+import path from 'node:path';
+import { existsSync, writeFileSync } from 'node:fs';
+// XXX this can be very limited. FIXME if anyone has better knowledge.
+export const emitDenoOutput = async (rootDir, config, ssr)=>{
+    const outputDir = path.resolve('.');
+    const relativeRootDir = path.relative(outputDir, rootDir);
+    const entriesFile = path.join(relativeRootDir, config.distDir, config.entriesJs);
+    const publicDir = path.join(relativeRootDir, config.distDir, config.publicDir);
+    if (!existsSync(path.join(outputDir, 'serve.ts'))) {
+        writeFileSync(path.join(outputDir, 'serve.ts'), `
+import { Hono } from "https://deno.land/x/hono/mod.ts";
+import { serveStatic } from "https://deno.land/x/hono/middleware.ts";
+
+const entries = import('./${entriesFile}');
+const { honoMiddleware } = await entries;
+const env = Deno.env.toObject();
+
+const app = new Hono();
+app.use('*', honoMiddleware({ entries, ssr: ${ssr}, env }));
+app.use("*", serveStatic({ root: "${publicDir}" }));
+
+Deno.serve(app.fetch);
+`);
+    }
+};
diff --git a/dist/lib/builder/output-netlify.d.ts b/dist/lib/builder/output-netlify.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f1986cf47fbf099016b2dcc92f7f60a95f2c1b24
--- /dev/null
+++ b/dist/lib/builder/output-netlify.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitNetlifyOutput: (rootDir: string, config: ResolvedConfig, type: 'static' | 'functions') => Promise<void>;
diff --git a/dist/lib/builder/output-netlify.js b/dist/lib/builder/output-netlify.js
new file mode 100644
index 0000000000000000000000000000000000000000..60bdf92add2f4c6661a98b7e5fa34210d20c7ab5
--- /dev/null
+++ b/dist/lib/builder/output-netlify.js
@@ -0,0 +1,31 @@
+import path from 'node:path';
+import { mkdirSync, writeFileSync, existsSync, readFileSync } from 'node:fs';
+import { DIST_PUBLIC } from './constants.js';
+export const emitNetlifyOutput = async (rootDir, config, serveJs, type)=>{
+    if (type === 'functions') {
+        const functionsDir = path.join(rootDir, 'netlify/functions');
+        mkdirSync(functionsDir, {
+            recursive: true
+        });
+        const notFoundFile = path.join(rootDir, config.distDir, DIST_PUBLIC, '404.html');
+        const notFoundHtml = existsSync(notFoundFile) ? readFileSync(notFoundFile, 'utf8') : null;
+        writeFileSync(path.join(functionsDir, 'serve.js'), `
+globalThis.__WAKU_NOT_FOUND_HTML__ = ${JSON.stringify(notFoundHtml)};
+export { default } from '../../${config.distDir}/${serveJs}';
+export const config = {
+  preferStatic: true,
+  path: ['/', '/*'],
+};
+`);
+    }
+    const netlifyTomlFile = path.join(rootDir, 'netlify.toml');
+    if (!existsSync(netlifyTomlFile)) {
+        writeFileSync(netlifyTomlFile, `
+[build]
+  command = "npm run build -- --with-netlify"
+  publish = "${config.distDir}/${DIST_PUBLIC}"
+[functions]
+  included_files = ["${config.privateDir}/**"]
+`);
+    }
+};
diff --git a/dist/lib/builder/output-partykit.d.ts b/dist/lib/builder/output-partykit.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cd5fef3864d79c0a0293b33487437121101de3db
--- /dev/null
+++ b/dist/lib/builder/output-partykit.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitPartyKitOutput: (rootDir: string, config: ResolvedConfig) => Promise<void>;
diff --git a/dist/lib/builder/output-partykit.js b/dist/lib/builder/output-partykit.js
new file mode 100644
index 0000000000000000000000000000000000000000..789f70b2c7268ac10d2f7afe9d7a2876317580d1
--- /dev/null
+++ b/dist/lib/builder/output-partykit.js
@@ -0,0 +1,15 @@
+import path from 'node:path';
+import { existsSync, writeFileSync } from 'node:fs';
+import { DIST_PUBLIC } from './constants.js';
+// XXX this can be very limited. FIXME if anyone has better knowledge.
+export const emitPartyKitOutput = async (rootDir, config, serveJs)=>{
+    const partykitJsonFile = path.join(rootDir, 'partykit.json');
+    if (!existsSync(partykitJsonFile)) {
+        writeFileSync(partykitJsonFile, JSON.stringify({
+            name: 'waku-project',
+            main: `${config.distDir}/${serveJs}`,
+            compatibilityDate: '2023-02-16',
+            serve: `./${config.distDir}/${DIST_PUBLIC}`
+        }, null, 2) + '\n');
+    }
+};
diff --git a/dist/lib/builder/output-vercel.d.ts b/dist/lib/builder/output-vercel.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2700e088d7ab038f7823dfb90a3fc98e93b1ab4e
--- /dev/null
+++ b/dist/lib/builder/output-vercel.d.ts
@@ -0,0 +1,2 @@
+import type { ResolvedConfig } from '../config.js';
+export declare const emitVercelOutput: (rootDir: string, config: ResolvedConfig, type: 'static' | 'serverless') => Promise<void>;
diff --git a/dist/lib/builder/output-vercel.js b/dist/lib/builder/output-vercel.js
new file mode 100644
index 0000000000000000000000000000000000000000..ee12602d3ffb3364bccbccbfcd53ccd4b9ffb02a
--- /dev/null
+++ b/dist/lib/builder/output-vercel.js
@@ -0,0 +1,53 @@
+import path from 'node:path';
+import { cpSync, existsSync, mkdirSync, writeFileSync } from 'node:fs';
+import { DIST_PUBLIC } from './constants.js';
+// https://vercel.com/docs/build-output-api/v3
+export const emitVercelOutput = async (rootDir, config, serveJs, type)=>{
+    const publicDir = path.join(rootDir, config.distDir, DIST_PUBLIC);
+    const outputDir = path.resolve('.vercel', 'output');
+    cpSync(publicDir, path.join(outputDir, 'static'), {
+        recursive: true
+    });
+    if (type === 'serverless') {
+        // for serverless function
+        const serverlessDir = path.join(outputDir, 'functions', config.rscPath + '.func');
+        mkdirSync(path.join(serverlessDir, config.distDir), {
+            recursive: true
+        });
+        cpSync(path.join(rootDir, config.distDir), path.join(serverlessDir, config.distDir), {
+            recursive: true
+        });
+        if (existsSync(path.join(rootDir, config.privateDir))) {
+            cpSync(path.join(rootDir, config.privateDir), path.join(serverlessDir, config.privateDir), {
+                recursive: true,
+                dereference: true
+            });
+        }
+        const vcConfigJson = {
+            runtime: 'nodejs20.x',
+            handler: `${config.distDir}/${serveJs}`,
+            launcherType: 'Nodejs'
+        };
+        writeFileSync(path.join(serverlessDir, '.vc-config.json'), JSON.stringify(vcConfigJson, null, 2));
+        writeFileSync(path.join(serverlessDir, 'package.json'), JSON.stringify({
+            type: 'module'
+        }, null, 2));
+    }
+    const routes = type === 'serverless' ? [
+        {
+            handle: 'filesystem'
+        },
+        {
+            src: config.basePath + '(.*)',
+            dest: config.basePath + config.rscPath + '/'
+        }
+    ] : undefined;
+    const configJson = {
+        version: 3,
+        routes
+    };
+    mkdirSync(outputDir, {
+        recursive: true
+    });
+    writeFileSync(path.join(outputDir, 'config.json'), JSON.stringify(configJson, null, 2));
+};
diff --git a/dist/lib/builder/serve-aws-lambda.d.ts b/dist/lib/builder/serve-aws-lambda.d.ts
index 22cd27907ec4d58f34a5019cd545d9af1af0a23e..c98a8a690eff5bb7f3754b4e7ace2da3007130ae 100644
--- a/dist/lib/builder/serve-aws-lambda.d.ts
+++ b/dist/lib/builder/serve-aws-lambda.d.ts
@@ -1 +1 @@
-export declare const handler: (event: import("hono/aws-lambda").LambdaEvent, lambdaContext?: import("hono/aws-lambda").LambdaContext) => Promise<import("hono/aws-lambda").APIGatewayProxyResult>;
+export declare const handler: (event: import("hono/aws-lambda").LambdaEvent, lambdaContext?: import("hono/aws-lambda").LambdaContext | undefined) => Promise<import("hono/aws-lambda").APIGatewayProxyResult>;
diff --git a/dist/lib/builder/serve-cloudflare.d.ts b/dist/lib/builder/serve-cloudflare.d.ts
index b36c71049a09469b5311f9dc7e7411430b82879f..f47dd283134c70c6304243a1a1cb2fba42a3993e 100644
--- a/dist/lib/builder/serve-cloudflare.d.ts
+++ b/dist/lib/builder/serve-cloudflare.d.ts
@@ -1,14 +1,5 @@
 import { Hono } from 'hono';
-export interface CloudflareEnv {
-    ASSETS: {
-        fetch: (input: RequestInit | URL, init?: RequestInit) => Promise<Response>;
-    };
-}
-export declare const app: Hono<{
-    Bindings: CloudflareEnv & {
-        [k: string]: unknown;
-    };
-}, import("hono/types").BlankSchema, "/">;
+declare const app: Hono<import("hono").Env, import("hono/types").BlankSchema, "/">;
 declare const _default: {
     fetch(request: Request, env: Record<string, string>, ctx: Parameters<typeof app.fetch>[2]): Promise<Response>;
 };
diff --git a/dist/lib/builder/serve-cloudflare.js b/dist/lib/builder/serve-cloudflare.js
index 99164f82bc642d745ec02e79220fc47e61cbed86..5821698044cc5b5bbf536631d280b372de294db8 100644
--- a/dist/lib/builder/serve-cloudflare.js
+++ b/dist/lib/builder/serve-cloudflare.js
@@ -1,16 +1,27 @@
 import { Hono } from 'hono';
+import { serveStatic } from 'hono/cloudflare-workers';
+// @ts-expect-error no types
+// eslint-disable-next-line import/no-unresolved
+import manifest from '__STATIC_CONTENT_MANIFEST';
 import { runner } from '../hono/runner.js';
 const loadEntries = ()=>import(import.meta.env.WAKU_ENTRIES_FILE);
 let serveWaku;
-export const app = new Hono();
+let staticContent;
+const parsedManifest = JSON.parse(manifest);
+const app = new Hono();
+app.use('*', serveStatic({
+    root: './',
+    manifest
+}));
 app.use('*', (c, next)=>serveWaku(c, next));
 app.notFound(async (c)=>{
-    const assetsFetcher = c.env.ASSETS;
-    const url = new URL(c.req.raw.url);
-    const errorHtmlUrl = `${url.origin}/404.html`;
-    const notFoundStaticAssetResponse = await assetsFetcher.fetch(new URL(errorHtmlUrl));
-    if (notFoundStaticAssetResponse && notFoundStaticAssetResponse.status < 400) {
-        return c.body(notFoundStaticAssetResponse.body, 404);
+    const path = parsedManifest['404.html'];
+    const content = path && await staticContent?.get(path, {
+        type: 'arrayBuffer'
+    });
+    if (content) {
+        c.header('Content-Type', 'text/html; charset=utf-8');
+        return c.body(content, 404);
     }
     return c.text('404 Not Found', 404);
 });
@@ -22,6 +33,7 @@ export default {
                 loadEntries,
                 env
             });
+            staticContent = env.__STATIC_CONTENT;
         }
         return app.fetch(request, env, ctx);
     }
diff --git a/dist/lib/builder/serve-partykit.d.ts b/dist/lib/builder/serve-partykit.d.ts
index ee74f702442bcf9cc0984f110c38f11d7f69f86c..75c7b625fb02fd9189595fa86670b1a4e9c61c48 100644
--- a/dist/lib/builder/serve-partykit.d.ts
+++ b/dist/lib/builder/serve-partykit.d.ts
@@ -1,5 +1,5 @@
 import { Hono } from 'hono';
-declare const app: Hono<import("hono/types").BlankEnv, import("hono/types").BlankSchema, "/">;
+declare const app: Hono<import("hono").Env, import("hono/types").BlankSchema, "/">;
 declare const _default: {
     onFetch(request: Request, lobby: any, ctx: Parameters<typeof app.fetch>[2]): Response | Promise<Response>;
 };
diff --git a/dist/lib/builder/serve-vercel.d.ts b/dist/lib/builder/serve-vercel.d.ts
index dbaf4944fa2bb06812ebc40a0b462e37ff66f583..4bca06e77a020d0bc474cab9eff3dc5b0c8b159c 100644
--- a/dist/lib/builder/serve-vercel.d.ts
+++ b/dist/lib/builder/serve-vercel.d.ts
@@ -1,2 +1,3 @@
+/// <reference types="node" resolution-mode="require"/>
 import type { IncomingMessage, ServerResponse } from 'node:http';
 export default function handler(req: IncomingMessage, res: ServerResponse): Promise<void>;
diff --git a/dist/lib/builder.d.ts b/dist/lib/builder.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0430b4165b691f93842086440b6f07f09608e20c
--- /dev/null
+++ b/dist/lib/builder.d.ts
@@ -0,0 +1,3 @@
+export declare function build(options?: {
+    ssr?: boolean;
+}): Promise<void>;
diff --git a/dist/lib/builder.js b/dist/lib/builder.js
new file mode 100644
index 0000000000000000000000000000000000000000..55af710c3e7d9b2ebd124d59d5ec810fc7188786
--- /dev/null
+++ b/dist/lib/builder.js
@@ -0,0 +1,387 @@
+import path from 'node:path';
+import { createReadStream, createWriteStream, existsSync, mkdirSync, readdirSync, symlinkSync, writeFileSync } from 'node:fs';
+import fsPromises from 'node:fs/promises';
+import { createHash } from 'node:crypto';
+import { Readable } from 'node:stream';
+import { pipeline } from 'node:stream/promises';
+import { build as viteBuild } from 'vite';
+import viteReact from '@vitejs/plugin-react';
+import { resolveConfig, viteInlineConfig } from './config.js';
+import { normalizePath } from './utils/path.js';
+import { encodeInput, generatePrefetchCode } from './middleware/rsc/utils.js';
+import { shutdown as shutdownRsc, renderRSC, getBuildConfigRSC } from './middleware/rsc/worker-api.js';
+import { rscIndexPlugin } from './vite-plugin/rsc-index-plugin.js';
+import { rscAnalyzePlugin } from './vite-plugin/rsc-analyze-plugin.js';
+import { rscTransformPlugin } from './vite-plugin/rsc-transform-plugin.js';
+import { patchReactRefresh } from './vite-plugin/patch-react-refresh.js';
+import { renderHtml, shutdown as shutdownSsr } from './middleware/rsc/ssr.js';
+// Upstream issue: https://github.com/rollup/rollup/issues/4699
+const onwarn = (warning, defaultHandler)=>{
+    if (warning.code === 'MODULE_LEVEL_DIRECTIVE' && /"use (client|server)"/.test(warning.message)) {
+        return;
+    } else if (warning.code === 'SOURCEMAP_ERROR' && warning.loc?.file?.endsWith('.tsx') && warning.loc?.column === 0 && warning.loc?.line === 1) {
+        return;
+    }
+    defaultHandler(warning);
+};
+const hash = (fname)=>new Promise((resolve)=>{
+        const sha256 = createHash('sha256');
+        sha256.on('readable', ()=>{
+            const data = sha256.read();
+            if (data) {
+                resolve(data.toString('hex').slice(0, 9));
+            }
+        });
+        createReadStream(fname).pipe(sha256);
+    });
+const analyzeEntries = async (entriesFile)=>{
+    const commonFileSet = new Set();
+    const clientFileSet = new Set();
+    const serverFileSet = new Set();
+    await viteBuild({
+        ...await viteInlineConfig(),
+        plugins: [
+            rscAnalyzePlugin(commonFileSet, clientFileSet, serverFileSet)
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                externalConditions: [
+                    'react-server',
+                    'workerd'
+                ]
+            },
+            noExternal: /^(?!node:)/
+        },
+        build: {
+            write: false,
+            ssr: true,
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile
+                }
+            }
+        }
+    });
+    const commonEntryFiles = Object.fromEntries(await Promise.all(Array.from(commonFileSet).map(async (fname, i)=>[
+            `com${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const clientEntryFiles = Object.fromEntries(await Promise.all(Array.from(clientFileSet).map(async (fname, i)=>[
+            `rsc${i}-${await hash(fname)}`,
+            fname
+        ])));
+    const serverEntryFiles = Object.fromEntries(Array.from(serverFileSet).map((fname, i)=>[
+            `rsf${i}`,
+            fname
+        ]));
+    return {
+        commonEntryFiles,
+        clientEntryFiles,
+        serverEntryFiles
+    };
+};
+const buildServerBundle = async (config, entriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles)=>{
+    const serverBuildOutput = await viteBuild({
+        ...await viteInlineConfig(),
+        plugins: [
+            rscTransformPlugin(true)
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                externalConditions: [
+                    'react-server',
+                    'workerd'
+                ]
+            },
+            noExternal: /^(?!node:)/
+        },
+        publicDir: false,
+        build: {
+            ssr: true,
+            ssrEmitAssets: true,
+            outDir: path.join(config.rootDir, config.distDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    entries: entriesFile,
+                    'rsdw-server': 'react-server-dom-webpack/server.edge',
+                    'waku-client': 'waku/client',
+                    ...commonEntryFiles,
+                    ...clientEntryFiles,
+                    ...serverEntryFiles
+                },
+                output: {
+                    entryFileNames: (chunkInfo)=>{
+                        if ([
+                            'waku-client'
+                        ].includes(chunkInfo.name) || commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name] || serverEntryFiles[chunkInfo.name]) {
+                            return config.assetsDir + '/[name].js';
+                        }
+                        return '[name].js';
+                    }
+                }
+            }
+        }
+    });
+    if (!('output' in serverBuildOutput)) {
+        throw new Error('Unexpected vite server build output');
+    }
+    return serverBuildOutput;
+};
+const buildClientBundle = async (config, commonEntryFiles, clientEntryFiles, serverBuildOutput)=>{
+    const indexHtmlFile = path.join(config.rootDir, config.srcDir, config.indexHtml);
+    const cssAssets = serverBuildOutput.output.flatMap(({ type, fileName })=>type === 'asset' && fileName.endsWith('.css') ? [
+            fileName
+        ] : []);
+    const clientBuildOutput = await viteBuild({
+        ...await viteInlineConfig(),
+        root: path.join(config.rootDir, config.srcDir),
+        plugins: [
+            patchReactRefresh(viteReact()),
+            rscIndexPlugin(cssAssets)
+        ],
+        build: {
+            outDir: path.join(config.rootDir, config.distDir, config.publicDir),
+            rollupOptions: {
+                onwarn,
+                input: {
+                    main: indexHtmlFile,
+                    react: 'react',
+                    'rd-server': 'react-dom/server.edge',
+                    'rsdw-client': 'react-server-dom-webpack/client.edge',
+                    'waku-client': 'waku/client',
+                    ...commonEntryFiles,
+                    ...clientEntryFiles
+                },
+                preserveEntrySignatures: 'exports-only',
+                output: {
+                    entryFileNames: (chunkInfo)=>{
+                        if ([
+                            'react',
+                            'rd-server',
+                            'rsdw-client',
+                            'waku-client'
+                        ].includes(chunkInfo.name) || commonEntryFiles[chunkInfo.name] || clientEntryFiles[chunkInfo.name]) {
+                            return config.assetsDir + '/[name].js';
+                        }
+                        return config.assetsDir + '/[name]-[hash].js';
+                    }
+                }
+            }
+        }
+    });
+    if (!('output' in clientBuildOutput)) {
+        throw new Error('Unexpected vite client build output');
+    }
+    for (const cssAsset of cssAssets){
+        const from = path.join(config.rootDir, config.distDir, cssAsset);
+        const to = path.join(config.rootDir, config.distDir, config.publicDir, cssAsset);
+        await fsPromises.rename(from, to);
+    }
+    return clientBuildOutput;
+};
+const emitRscFiles = async (config)=>{
+    const buildConfig = await getBuildConfigRSC(config);
+    const clientModuleMap = new Map();
+    const addClientModule = (input, id)=>{
+        let idSet = clientModuleMap.get(input);
+        if (!idSet) {
+            idSet = new Set();
+            clientModuleMap.set(input, idSet);
+        }
+        idSet.add(id);
+    };
+    const getClientModules = (input)=>{
+        const idSet = clientModuleMap.get(input);
+        return Array.from(idSet || []);
+    };
+    const rscFileSet = new Set(); // XXX could be implemented better
+    await Promise.all(Object.entries(buildConfig).map(async ([, { entries, context }])=>{
+        for (const [input] of entries || []){
+            const destFile = path.join(config.rootDir, config.distDir, config.publicDir, config.rscPath, encodeInput(normalizePath(input)));
+            if (!rscFileSet.has(destFile)) {
+                rscFileSet.add(destFile);
+                await fsPromises.mkdir(path.dirname(destFile), {
+                    recursive: true
+                });
+                const [readable] = await renderRSC({
+                    input,
+                    method: 'GET',
+                    headers: {},
+                    config,
+                    command: 'build',
+                    context,
+                    moduleIdCallback: (id)=>addClientModule(input, id)
+                });
+                await pipeline(Readable.fromWeb(readable), createWriteStream(destFile));
+            }
+        }
+    }));
+    return {
+        buildConfig,
+        getClientModules,
+        rscFiles: Array.from(rscFileSet)
+    };
+};
+const emitHtmlFiles = async (config, buildConfig, getClientModules, ssr)=>{
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const publicIndexHtmlFile = path.join(config.rootDir, config.distDir, config.publicDir, config.indexHtml);
+    const publicIndexHtml = await fsPromises.readFile(publicIndexHtmlFile, {
+        encoding: 'utf8'
+    });
+    const htmlFiles = await Promise.all(Object.entries(buildConfig).map(async ([pathStr, { entries, customCode, context }])=>{
+        const destFile = path.join(config.rootDir, config.distDir, config.publicDir, pathStr, pathStr.endsWith('/') ? 'index.html' : '');
+        let htmlStr;
+        if (existsSync(destFile)) {
+            htmlStr = await fsPromises.readFile(destFile, {
+                encoding: 'utf8'
+            });
+        } else {
+            await fsPromises.mkdir(path.dirname(destFile), {
+                recursive: true
+            });
+            htmlStr = publicIndexHtml;
+        }
+        const inputsForPrefetch = new Set();
+        const moduleIdsForPrefetch = new Set();
+        for (const [input, skipPrefetch] of entries || []){
+            if (!skipPrefetch) {
+                inputsForPrefetch.add(input);
+                for (const id of getClientModules(input)){
+                    moduleIdsForPrefetch.add(id);
+                }
+            }
+        }
+        const code = generatePrefetchCode(basePrefix, inputsForPrefetch, moduleIdsForPrefetch) + (customCode || '');
+        if (code) {
+            // HACK is this too naive to inject script code?
+            htmlStr = htmlStr.replace(/<\/head>/, `<script>${code}</script></head>`);
+        }
+        const htmlResult = ssr && await renderHtml(config, 'build', pathStr, htmlStr, context);
+        if (htmlResult) {
+            const [htmlReadable] = htmlResult;
+            await pipeline(Readable.fromWeb(htmlReadable), createWriteStream(destFile));
+        } else {
+            await fsPromises.writeFile(destFile, htmlStr);
+        }
+        return destFile;
+    }));
+    return {
+        htmlFiles
+    };
+};
+const emitVercelOutput = (config, clientBuildOutput, rscFiles, htmlFiles)=>{
+    const clientFiles = clientBuildOutput.output.map(({ fileName })=>path.join(config.rootDir, config.distDir, config.publicDir, fileName));
+    const srcDir = path.join(config.rootDir, config.distDir, config.publicDir);
+    const dstDir = path.join(config.rootDir, config.distDir, '.vercel', 'output');
+    for (const file of [
+        ...clientFiles,
+        ...rscFiles,
+        ...htmlFiles
+    ]){
+        const dstFile = path.join(dstDir, 'static', path.relative(srcDir, file));
+        if (!existsSync(dstFile)) {
+            mkdirSync(path.dirname(dstFile), {
+                recursive: true
+            });
+            symlinkSync(path.relative(path.dirname(dstFile), file), dstFile);
+        }
+    }
+    // for serverless function
+    const serverlessDir = path.join(dstDir, 'functions', config.rscPath + '.func');
+    mkdirSync(path.join(serverlessDir, config.distDir), {
+        recursive: true
+    });
+    symlinkSync(path.relative(serverlessDir, path.join(config.rootDir, 'node_modules')), path.join(serverlessDir, 'node_modules'));
+    for (const file of readdirSync(path.join(config.rootDir, config.distDir))){
+        if ([
+            '.vercel'
+        ].includes(file)) {
+            continue;
+        }
+        symlinkSync(path.relative(path.join(serverlessDir, config.distDir), path.join(config.rootDir, config.distDir, file)), path.join(serverlessDir, config.distDir, file));
+    }
+    const vcConfigJson = {
+        runtime: 'nodejs18.x',
+        handler: 'serve.js',
+        launcherType: 'Nodejs'
+    };
+    writeFileSync(path.join(serverlessDir, '.vc-config.json'), JSON.stringify(vcConfigJson, null, 2));
+    writeFileSync(path.join(serverlessDir, 'package.json'), JSON.stringify({
+        type: 'module'
+    }, null, 2));
+    writeFileSync(path.join(serverlessDir, 'serve.js'), `
+export default async function handler(req, res) {
+  const { rsc } = await import("waku");
+  rsc({ command: "start" })(req, res, () => {
+    throw new Error("not handled");
+  });
+}
+`);
+    const overrides = Object.fromEntries([
+        ...rscFiles.filter((file)=>!path.extname(file)).map((file)=>[
+                path.relative(srcDir, file),
+                {
+                    contentType: 'text/plain'
+                }
+            ]),
+        ...htmlFiles.filter((file)=>!path.extname(file)).map((file)=>[
+                path.relative(srcDir, file),
+                {
+                    contentType: 'text/html'
+                }
+            ])
+    ]);
+    const basePrefix = config.basePath + config.rscPath + '/';
+    const routes = [
+        {
+            src: basePrefix + '(.*)',
+            dest: basePrefix
+        }
+    ];
+    const configJson = {
+        version: 3,
+        overrides,
+        routes
+    };
+    mkdirSync(dstDir, {
+        recursive: true
+    });
+    writeFileSync(path.join(dstDir, 'config.json'), JSON.stringify(configJson, null, 2));
+};
+const resolveFileName = (fname)=>{
+    for (const ext of [
+        '.js',
+        '.ts',
+        '.tsx',
+        '.jsx'
+    ]){
+        const resolvedName = fname.slice(0, -path.extname(fname).length) + ext;
+        if (existsSync(resolvedName)) {
+            return resolvedName;
+        }
+    }
+    return fname; // returning the default one
+};
+export async function build(options) {
+    const config = await resolveConfig(options.config);
+    const entriesFile = resolveFileName(path.join(config.rootDir, config.srcDir, config.entriesJs));
+    const { commonEntryFiles, clientEntryFiles, serverEntryFiles } = await analyzeEntries(entriesFile);
+    const serverBuildOutput = await buildServerBundle(config, entriesFile, commonEntryFiles, clientEntryFiles, serverEntryFiles);
+    const clientBuildOutput = await buildClientBundle(config, commonEntryFiles, clientEntryFiles, serverBuildOutput);
+    const { buildConfig, getClientModules, rscFiles } = await emitRscFiles(config);
+    const { htmlFiles } = await emitHtmlFiles(config, buildConfig, getClientModules, !!options?.ssr);
+    // https://vercel.com/docs/build-output-api/v3
+    emitVercelOutput(config, clientBuildOutput, rscFiles, htmlFiles);
+    await shutdownSsr();
+    await shutdownRsc();
+}
diff --git a/dist/lib/config.d.ts b/dist/lib/config.d.ts
index a24bd79f7f5596254544d5f52a983e29f1cccf1e..ba894ee8320cc8479f813bd5a7e30a7789917f7e 100644
--- a/dist/lib/config.d.ts
+++ b/dist/lib/config.d.ts
@@ -7,12 +7,19 @@ export declare function resolveConfig(config: Config): Promise<{
     basePath: string;
     srcDir: string;
     distDir: string;
+    publicDir: string;
+    assetsDir: string;
+    ssrDir: string;
+    indexHtml: string;
+    mainJs: string;
+    entriesJs: string;
     preserveModuleDirs: string[];
     privateDir: string;
+    serveJs: string;
     rscPath: string;
-    middleware: () => Promise<{
+    htmlHead: string;
+    middleware: (cmd: "dev" | "start") => Promise<{
         default: import("./middleware/types.js").Middleware;
     }>[];
 }>;
-export declare const EXTENSIONS: string[];
 export {};
diff --git a/dist/lib/config.js b/dist/lib/config.js
index 38cd1f996d2c304922a5402bfd18a07100cbbfe6..0b0b95a5f24c86d49d0eaa70eaf1befda39dacee 100644
--- a/dist/lib/config.js
+++ b/dist/lib/config.js
@@ -19,15 +19,8 @@ export async function resolveConfig(config) {
         privateDir: 'private',
         rscPath: 'RSC',
         middleware: DEFAULT_MIDDLEWARE,
+        unstable_honoEnhancer: undefined,
         ...config
     };
     return resolvedConfig;
 }
-export const EXTENSIONS = [
-    '.js',
-    '.ts',
-    '.tsx',
-    '.jsx',
-    '.mjs',
-    '.cjs'
-];
diff --git a/dist/lib/constants.js b/dist/lib/constants.js
new file mode 100644
index 0000000000000000000000000000000000000000..7ff4be4156a94fbc5fb542ec98fe01fed8416725
--- /dev/null
+++ b/dist/lib/constants.js
@@ -0,0 +1,10 @@
+export const EXTENSIONS = [
+    '.js',
+    '.ts',
+    '.tsx',
+    '.jsx',
+    '.mjs',
+    '.cjs'
+];
+export const SRC_MAIN = 'main';
+export const SRC_ENTRIES = 'entries';
diff --git a/dist/lib/handlers/dev-worker-api.d.ts b/dist/lib/handlers/dev-worker-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4061a13eb56f27738433972045db44c12d60417e
--- /dev/null
+++ b/dist/lib/handlers/dev-worker-api.d.ts
@@ -0,0 +1,64 @@
+/// <reference types="node" resolution-mode="require"/>
+import type { Worker as WorkerType } from 'node:worker_threads';
+import type { ResolvedConfig } from '../config.js';
+import type { HotUpdatePayload } from '../plugins/vite-plugin-rsc-hmr.js';
+export type RenderRequest = {
+    input: string;
+    searchParamsString: string;
+    method: 'GET' | 'POST';
+    contentType: string | undefined;
+    config: ResolvedConfig;
+    context: unknown;
+    stream?: ReadableStream | undefined;
+    moduleIdCallback?: (id: string) => void;
+};
+export type BuildOutput = {
+    rscFiles: string[];
+    htmlFiles: string[];
+};
+export type MessageReq = ({
+    id: number;
+    type: 'render';
+    hasModuleIdCallback: boolean;
+} & Omit<RenderRequest, 'moduleIdCallback'>) | {
+    id: number;
+    type: 'getSsrConfig';
+    config: ResolvedConfig;
+    pathname: string;
+    searchParamsString: string;
+};
+export type MessageRes = {
+    type: 'hot-update';
+    payload: HotUpdatePayload;
+} | {
+    id: number;
+    type: 'start';
+    context: unknown;
+    stream: ReadableStream;
+} | {
+    id: number;
+    type: 'err';
+    err: unknown;
+    statusCode?: number;
+} | {
+    id: number;
+    type: 'moduleId';
+    moduleId: string;
+} | {
+    id: number;
+    type: 'ssrConfig';
+    input: string;
+    searchParamsString?: string | undefined;
+    body: ReadableStream;
+} | {
+    id: number;
+    type: 'noSsrConfig';
+};
+export declare function initializeWorker(config: ResolvedConfig): void;
+export declare function registerHotUpdateCallback(fn: (payload: HotUpdatePayload) => void): Promise<() => WorkerType>;
+export declare function renderRscWithWorker<Context>(rr: RenderRequest): Promise<readonly [ReadableStream, Context]>;
+export declare function getSsrConfigWithWorker(config: ResolvedConfig, pathname: string, searchParams: URLSearchParams): Promise<{
+    input: string;
+    searchParams?: URLSearchParams;
+    body: ReadableStream;
+} | null>;
diff --git a/dist/lib/handlers/dev-worker-api.js b/dist/lib/handlers/dev-worker-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..116136e617da79d275bfccdcebb18d9a52b3ee69
--- /dev/null
+++ b/dist/lib/handlers/dev-worker-api.js
@@ -0,0 +1,145 @@
+const messageCallbacks = new Map();
+let workerPromise;
+export function initializeWorker(config) {
+    if (workerPromise) {
+        throw new Error('Worker already initialized');
+    }
+    workerPromise = new Promise((resolve, reject)=>{
+        Promise.all([
+            import('node:worker_threads').catch((e)=>{
+                throw e;
+            }),
+            import('node:module').catch((e)=>{
+                throw e;
+            })
+        ]).then(([{ Worker, setEnvironmentData }, { default: module }])=>{
+            const HAS_MODULE_REGISTER = typeof module.register === 'function';
+            setEnvironmentData('__WAKU_PRIVATE_ENV__', globalThis.__WAKU_PRIVATE_ENV__);
+            setEnvironmentData('CONFIG_SRC_DIR', config.srcDir);
+            setEnvironmentData('CONFIG_ENTRIES_JS', config.entriesJs);
+            const worker = new Worker(new URL('dev-worker-impl.js', import.meta.url), {
+                execArgv: [
+                    ...HAS_MODULE_REGISTER ? [] : [
+                        '--experimental-loader',
+                        'waku/node-loader'
+                    ],
+                    '--conditions',
+                    'react-server',
+                    'workerd'
+                ]
+            });
+            worker.on('message', (mesg)=>{
+                if ('id' in mesg) {
+                    messageCallbacks.get(mesg.id)?.(mesg);
+                }
+            });
+            resolve(worker);
+        }).catch((e)=>reject(e));
+    });
+}
+const getWorker = ()=>{
+    if (!workerPromise) {
+        throw new Error('Worker not initialized');
+    }
+    return workerPromise;
+};
+export async function registerHotUpdateCallback(fn) {
+    const worker = await getWorker();
+    const listener = (mesg)=>{
+        if (mesg.type === 'hot-update') {
+            fn(mesg.payload);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+let nextId = 1;
+export async function renderRscWithWorker(rr) {
+    const worker = await getWorker();
+    const id = nextId++;
+    let started = false;
+    return new Promise((resolve, reject)=>{
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'start') {
+                if (!started) {
+                    started = true;
+                    const bridge = new TransformStream({
+                        flush () {
+                            messageCallbacks.delete(id);
+                        }
+                    });
+                    resolve([
+                        mesg.stream.pipeThrough(bridge),
+                        mesg.context
+                    ]);
+                } else {
+                    throw new Error('already started');
+                }
+            } else if (mesg.type === 'moduleId') {
+                rr.moduleIdCallback?.(mesg.moduleId);
+            } else if (mesg.type === 'err') {
+                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                if (!started) {
+                    reject(err);
+                }
+                messageCallbacks.delete(id);
+            }
+        });
+        const { ssr: _removed, ...copiedConfig } = rr.config; // HACK type
+        const copied = {
+            ...rr,
+            config: copiedConfig
+        };
+        delete copied.stream;
+        delete copied.moduleIdCallback;
+        const mesg = {
+            id,
+            type: 'render',
+            hasModuleIdCallback: !!rr.moduleIdCallback,
+            stream: rr.stream,
+            ...copied
+        };
+        worker.postMessage(mesg, rr.stream ? [
+            rr.stream
+        ] : undefined);
+    });
+}
+export async function getSsrConfigWithWorker(config, pathname, searchParams) {
+    const worker = await getWorker();
+    const id = nextId++;
+    return new Promise((resolve, reject)=>{
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'ssrConfig') {
+                resolve({
+                    input: mesg.input,
+                    ...mesg.searchParamsString ? {
+                        searchParams: new URLSearchParams(mesg.searchParamsString)
+                    } : {},
+                    body: mesg.body
+                });
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'noSsrConfig') {
+                resolve(null);
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                reject(err);
+                messageCallbacks.delete(id);
+            }
+        });
+        const mesg = {
+            id,
+            type: 'getSsrConfig',
+            config,
+            pathname,
+            searchParamsString: searchParams.toString()
+        };
+        worker.postMessage(mesg);
+    });
+}
diff --git a/dist/lib/handlers/dev-worker-impl.d.ts b/dist/lib/handlers/dev-worker-impl.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/lib/handlers/dev-worker-impl.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/lib/handlers/dev-worker-impl.js b/dist/lib/handlers/dev-worker-impl.js
new file mode 100644
index 0000000000000000000000000000000000000000..632a046edfbded558f10817aabb54b599718d881
--- /dev/null
+++ b/dist/lib/handlers/dev-worker-impl.js
@@ -0,0 +1,193 @@
+// This file can depend on Node.js
+import { pathToFileURL } from 'node:url';
+import { parentPort, getEnvironmentData } from 'node:worker_threads';
+import { Server } from 'node:http';
+import { createServer as createViteServer } from 'vite';
+import viteReact from '@vitejs/plugin-react';
+import { joinPath, fileURLToFilePath, encodeFilePathToAbsolute } from '../utils/path.js';
+import { deepFreeze, hasStatusCode } from '../renderers/utils.js';
+import { renderRsc, getSsrConfig } from '../renderers/rsc-renderer.js';
+import { nonjsResolvePlugin } from '../plugins/vite-plugin-nonjs-resolve.js';
+import { rscTransformPlugin } from '../plugins/vite-plugin-rsc-transform.js';
+import { rscEnvPlugin } from '../plugins/vite-plugin-rsc-env.js';
+import { rscDelegatePlugin } from '../plugins/vite-plugin-rsc-delegate.js';
+import { mergeUserViteConfig } from '../utils/merge-vite-config.js';
+const { default: module } = await import('node:module');
+const HAS_MODULE_REGISTER = typeof module.register === 'function';
+if (HAS_MODULE_REGISTER) {
+    module.register('waku/node-loader', pathToFileURL('./'));
+}
+globalThis.__WAKU_PRIVATE_ENV__ = getEnvironmentData('__WAKU_PRIVATE_ENV__');
+const configSrcDir = getEnvironmentData('CONFIG_SRC_DIR');
+const configEntriesJs = getEnvironmentData('CONFIG_ENTRIES_JS');
+const resolveClientEntryForDev = (id, config)=>{
+    const filePath = id.startsWith('file://') ? fileURLToFilePath(id) : id;
+    // HACK this relies on Vite's internal implementation detail.
+    return config.basePath + '@fs' + encodeFilePathToAbsolute(filePath);
+};
+const handleRender = async (mesg)=>{
+    const { id, type: _removed, hasModuleIdCallback, ...rest } = mesg;
+    const rr = rest;
+    try {
+        if (hasModuleIdCallback) {
+            rr.moduleIdCallback = (moduleId)=>{
+                const mesg = {
+                    id,
+                    type: 'moduleId',
+                    moduleId
+                };
+                parentPort.postMessage(mesg);
+            };
+        }
+        const readable = await renderRsc({
+            config: rr.config,
+            input: rr.input,
+            searchParams: new URLSearchParams(rr.searchParamsString),
+            method: rr.method,
+            context: rr.context,
+            body: rr.stream,
+            contentType: rr.contentType,
+            moduleIdCallback: rr.moduleIdCallback,
+            isDev: true,
+            customImport: loadServerFile,
+            resolveClientEntry: (id)=>resolveClientEntryForDev(id, rr.config),
+            entries: await loadEntries(rr.config)
+        });
+        const mesg = {
+            id,
+            type: 'start',
+            context: rr.context,
+            stream: readable
+        };
+        parentPort.postMessage(mesg, [
+            readable
+        ]);
+        deepFreeze(rr.context);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err: `${err}`
+        };
+        if (hasStatusCode(err)) {
+            mesg.statusCode = err.statusCode;
+        }
+        parentPort.postMessage(mesg);
+    }
+};
+const handleGetSsrConfig = async (mesg)=>{
+    const { id, config, pathname, searchParamsString } = mesg;
+    const searchParams = new URLSearchParams(searchParamsString);
+    try {
+        const ssrConfig = await getSsrConfig({
+            config,
+            pathname,
+            searchParams,
+            isDev: true,
+            resolveClientEntry: (id)=>resolveClientEntryForDev(id, config),
+            entries: await loadEntries(config)
+        });
+        const mesg = ssrConfig ? {
+            id,
+            type: 'ssrConfig',
+            ...ssrConfig
+        } : {
+            id,
+            type: 'noSsrConfig'
+        };
+        parentPort.postMessage(mesg, ssrConfig ? [
+            ssrConfig.body
+        ] : undefined);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err: `${err}`
+        };
+        if (hasStatusCode(err)) {
+            mesg.statusCode = err.statusCode;
+        }
+        parentPort.postMessage(mesg);
+    }
+};
+const dummyServer = new Server(); // FIXME we hope to avoid this hack
+const mergedViteConfig = await mergeUserViteConfig({
+    plugins: [
+        viteReact(),
+        rscEnvPlugin({}),
+        {
+            name: 'rsc-index-plugin'
+        },
+        {
+            name: 'rsc-hmr-plugin',
+            enforce: 'post'
+        },
+        nonjsResolvePlugin(),
+        rscTransformPlugin({
+            isBuild: false
+        }),
+        rscDelegatePlugin((payload)=>{
+            const mesg = {
+                type: 'hot-update',
+                payload
+            };
+            parentPort.postMessage(mesg);
+        })
+    ],
+    optimizeDeps: {
+        include: [
+            'react-server-dom-webpack/client',
+            'react-dom'
+        ],
+        exclude: [
+            'waku'
+        ],
+        entries: [
+            `${configSrcDir}/${configEntriesJs}`.replace(/\.js$/, '.*')
+        ]
+    },
+    ssr: {
+        resolve: {
+            conditions: [
+                'react-server',
+                'workerd'
+            ],
+            externalConditions: [
+                'react-server',
+                'workerd'
+            ]
+        },
+        external: [],
+        // FIXME We want to externalize waku, but it fails on windows.
+        noExternal: [
+            'waku'
+        ]
+    },
+    appType: 'custom',
+    server: {
+        middlewareMode: true,
+        hmr: {
+            server: dummyServer
+        }
+    }
+});
+const vitePromise = createViteServer(mergedViteConfig).then(async (vite)=>{
+    await vite.ws.close();
+    return vite;
+});
+const loadServerFile = async (fileURL)=>{
+    const vite = await vitePromise;
+    return vite.ssrLoadModule(fileURLToFilePath(fileURL));
+};
+const loadEntries = async (config)=>{
+    const vite = await vitePromise;
+    const filePath = joinPath(vite.config.root, config.srcDir, config.entriesJs);
+    return vite.ssrLoadModule(filePath);
+};
+parentPort.on('message', (mesg)=>{
+    if (mesg.type === 'render') {
+        handleRender(mesg);
+    } else if (mesg.type === 'getSsrConfig') {
+        handleGetSsrConfig(mesg);
+    }
+});
diff --git a/dist/lib/handlers/handler-dev.d.ts b/dist/lib/handlers/handler-dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..16eab40a59cb2467285006ab857d582a4eecebc6
--- /dev/null
+++ b/dist/lib/handlers/handler-dev.d.ts
@@ -0,0 +1,16 @@
+import type { Config } from '../../config.js';
+import type { BaseReq, BaseRes, Handler } from './types.js';
+export declare const CLIENT_MODULE_MAP: {
+    react: string;
+    'rd-server': string;
+    'rsdw-client': string;
+    'waku-client': string;
+};
+export type CLIENT_MODULE_KEY = keyof typeof CLIENT_MODULE_MAP;
+export declare function createHandler<Req extends BaseReq, Res extends BaseRes>(options: {
+    config?: Config;
+    ssr?: boolean;
+    env?: Record<string, string>;
+    unstable_prehook?: (req: Req, res: Res) => Record<string, unknown>;
+    unstable_posthook?: (req: Req, res: Res, context: Record<string, unknown>) => void;
+}): Handler<Req, Res>;
diff --git a/dist/lib/handlers/handler-dev.js b/dist/lib/handlers/handler-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..f6f67b2789fa323e545498e1d511bcf9550dce0c
--- /dev/null
+++ b/dist/lib/handlers/handler-dev.js
@@ -0,0 +1,253 @@
+import { Readable, Writable } from 'node:stream';
+import { createServer as createViteServer } from 'vite';
+import viteReact from '@vitejs/plugin-react';
+import { resolveConfig } from '../config.js';
+import { joinPath, fileURLToFilePath, decodeFilePathFromAbsolute } from '../utils/path.js';
+import { endStream } from '../utils/stream.js';
+import { renderHtml } from '../renderers/html-renderer.js';
+import { decodeInput, hasStatusCode } from '../renderers/utils.js';
+import { initializeWorker, registerHotUpdateCallback, renderRscWithWorker, getSsrConfigWithWorker } from '../renderers/dev-worker-api.js';
+import { patchReactRefresh } from '../plugins/patch-react-refresh.js';
+import { rscIndexPlugin } from '../plugins/vite-plugin-rsc-index.js';
+import { rscHmrPlugin, hotUpdate } from '../plugins/vite-plugin-rsc-hmr.js';
+import { rscEnvPlugin } from '../plugins/vite-plugin-rsc-env.js';
+import { rscPrivatePlugin } from '../plugins/vite-plugin-rsc-private.js';
+import { mergeUserViteConfig } from '../utils/merge-vite-config.js';
+export const CLIENT_MODULE_MAP = {
+    react: 'react',
+    'rd-server': 'react-dom/server.edge',
+    'rsdw-client': 'react-server-dom-webpack/client.edge',
+    'waku-client': 'waku/client'
+};
+export function createHandler(options) {
+    const { ssr, unstable_prehook, unstable_posthook } = options;
+    if (!unstable_prehook && unstable_posthook) {
+        throw new Error('prehook is required if posthook is provided');
+    }
+    globalThis.__WAKU_PRIVATE_ENV__ = options.env || {};
+    const configPromise = resolveConfig(options.config || {});
+    const vitePromise = configPromise.then(async (config)=>{
+        const mergedViteConfig = await mergeUserViteConfig({
+            base: config.basePath,
+            plugins: [
+                patchReactRefresh(viteReact()),
+                rscEnvPlugin({
+                    config
+                }),
+                rscPrivatePlugin(config),
+                rscIndexPlugin(config),
+                rscHmrPlugin(),
+                {
+                    name: 'nonjs-resolve-plugin'
+                },
+                {
+                    name: 'rsc-transform-plugin'
+                },
+                {
+                    name: 'rsc-delegate-plugin'
+                }
+            ],
+            optimizeDeps: {
+                include: [
+                    'react-server-dom-webpack/client',
+                    'react-dom'
+                ],
+                exclude: [
+                    'waku'
+                ],
+                entries: [
+                    `${config.srcDir}/${config.entriesJs}`.replace(/\.js$/, '.*')
+                ]
+            },
+            ssr: {
+                external: [
+                    'waku',
+                    'waku/client',
+                    'waku/server',
+                    'waku/router/client',
+                    'waku/router/server'
+                ]
+            },
+            server: {
+                middlewareMode: true
+            }
+        });
+        const vite = await createViteServer(mergedViteConfig);
+        initializeWorker(config);
+        registerHotUpdateCallback((payload)=>hotUpdate(vite, payload));
+        return vite;
+    });
+    const loadServerFile = async (fileURL)=>{
+        const vite = await vitePromise;
+        return vite.ssrLoadModule(fileURLToFilePath(fileURL));
+    };
+    const transformIndexHtml = async (pathname)=>{
+        const vite = await vitePromise;
+        const encoder = new TextEncoder();
+        const decoder = new TextDecoder();
+        let headSent = false;
+        return new TransformStream({
+            transform (chunk, controller) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                if (!headSent) {
+                    headSent = true;
+                    let data = decoder.decode(chunk);
+                    // FIXME without removing async, Vite will move it
+                    // to the proxy cache, which breaks __WAKU_PUSH__.
+                    data = data.replace(/<script type="module" async>/, '<script>');
+                    return new Promise((resolve, reject)=>{
+                        vite.transformIndexHtml(pathname, data).then((result)=>{
+                            controller.enqueue(encoder.encode(result));
+                            resolve();
+                        }).catch(reject);
+                    });
+                }
+                controller.enqueue(chunk);
+            },
+            flush () {
+                if (!headSent) {
+                    throw new Error('head not yet sent');
+                }
+            }
+        });
+    };
+    const willBeHandledByVite = async (pathname)=>{
+        const vite = await vitePromise;
+        try {
+            const result = await vite.transformRequest(pathname);
+            return !!result;
+        } catch  {
+            return false;
+        }
+    };
+    return async (req, res, next)=>{
+        const [{ middleware: _removed, ...config }, vite] = await Promise.all([
+            configPromise,
+            vitePromise
+        ]);
+        const basePrefix = config.basePath + config.rscPath + '/';
+        const handleError = async (err)=>{
+            if (hasStatusCode(err)) {
+                res.setStatus(err.statusCode);
+            } else {
+                console.info('Cannot render RSC', err);
+                res.setStatus(500);
+            }
+            await endStream(res.stream, String(err));
+        };
+        let context;
+        try {
+            context = unstable_prehook?.(req, res);
+        } catch (e) {
+            await handleError(e);
+            return;
+        }
+        if (req.url.pathname.startsWith(basePrefix)) {
+            const { method, contentType } = req;
+            if (method !== 'GET' && method !== 'POST') {
+                throw new Error(`Unsupported method '${method}'`);
+            }
+            try {
+                const input = decodeInput(req.url.pathname.slice(basePrefix.length));
+                const readable = await renderRscWithWorker({
+                    input,
+                    searchParams: req.url.searchParams,
+                    method,
+                    contentType,
+                    config,
+                    context,
+                    body: req.stream
+                });
+                unstable_posthook?.(req, res, context);
+                await readable.pipeTo(res.stream);
+            } catch (e) {
+                await handleError(e);
+            }
+            return;
+        }
+        if (ssr && !await willBeHandledByVite(req.url.pathname)) {
+            try {
+                const readable = await renderHtml({
+                    config,
+                    pathname: req.url.pathname,
+                    searchParams: req.url.searchParams,
+                    htmlHead: config.htmlHead,
+                    renderRscForHtml: async (input, searchParams)=>{
+                        const readable = await renderRscWithWorker({
+                            input,
+                            searchParams,
+                            method: 'GET',
+                            contentType: undefined,
+                            config,
+                            context
+                        });
+                        return readable;
+                    },
+                    getSsrConfigForHtml: (pathname, searchParams)=>getSsrConfigWithWorker({
+                            config,
+                            pathname,
+                            searchParams
+                        }),
+                    loadClientModule: (key)=>import(CLIENT_MODULE_MAP[key]),
+                    isDev: true,
+                    rootDir: vite.config.root,
+                    loadServerFile
+                });
+                if (readable) {
+                    unstable_posthook?.(req, res, context);
+                    res.setHeader('content-type', 'text/html; charset=utf-8');
+                    await readable.pipeThrough(await transformIndexHtml(req.url.pathname)).pipeTo(res.stream);
+                    return;
+                }
+            } catch (e) {
+                await handleError(e);
+                return;
+            }
+        }
+        // HACK re-export "?v=..." URL to avoid dual module hazard.
+        const viteUrl = req.url.toString().slice(req.url.origin.length);
+        const fname = viteUrl.startsWith(config.basePath + '@fs/') ? decodeFilePathFromAbsolute(viteUrl.slice(config.basePath.length + '@fs'.length)) : joinPath(vite.config.root, viteUrl);
+        for (const item of vite.moduleGraph.idToModuleMap.values()){
+            if (item.file === fname && item.url !== viteUrl && !item.url.includes('?html-proxy')) {
+                const { code } = await vite.transformRequest(item.url);
+                res.setHeader('Content-Type', 'application/javascript');
+                res.setStatus(200);
+                let exports = `export * from "${item.url}";`;
+                // `export *` does not re-export `default`
+                if (code.includes('export default')) {
+                    exports += `export { default } from "${item.url}";`;
+                }
+                await endStream(res.stream, exports);
+                return;
+            }
+        }
+        const viteReq = Readable.fromWeb(req.stream);
+        viteReq.method = req.method;
+        viteReq.url = viteUrl;
+        viteReq.headers = {
+            'content-type': req.contentType
+        };
+        const viteRes = Writable.fromWeb(res.stream);
+        Object.defineProperty(viteRes, 'statusCode', {
+            set (code) {
+                res.setStatus(code);
+            }
+        });
+        const headers = new Map();
+        viteRes.setHeader = (name, value)=>{
+            headers.set(name, value);
+            res.setHeader(name, value);
+        };
+        viteRes.getHeader = (name)=>headers.get(name);
+        viteRes.writeHead = (code, headers)=>{
+            res.setStatus(code);
+            for (const [name, value] of Object.entries(headers || {})){
+                viteRes.setHeader(name, value);
+            }
+        };
+        vite.middlewares(viteReq, viteRes, next);
+        return;
+    };
+}
diff --git a/dist/lib/handlers/handler-prd.d.ts b/dist/lib/handlers/handler-prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82f225dedf4c43101f0815d629e13f7df5c7cb52
--- /dev/null
+++ b/dist/lib/handlers/handler-prd.d.ts
@@ -0,0 +1,12 @@
+import type { EntriesPrd } from '../../server.js';
+import type { Config } from '../../config.js';
+import type { BaseReq, BaseRes, Handler } from './types.js';
+export declare const CLIENT_PREFIX = "client/";
+export declare function createHandler<Req extends BaseReq, Res extends BaseRes>(options: {
+    config?: Config;
+    ssr?: boolean;
+    env?: Record<string, string>;
+    unstable_prehook?: (req: Req, res: Res) => Record<string, unknown>;
+    unstable_posthook?: (req: Req, res: Res, context: Record<string, unknown>) => void;
+    loadEntries: () => Promise<EntriesPrd>;
+}): Handler<Req, Res>;
diff --git a/dist/lib/handlers/handler-prd.js b/dist/lib/handlers/handler-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..ae521c7d7499eab7093b9bbbad6f078c592996ec
--- /dev/null
+++ b/dist/lib/handlers/handler-prd.js
@@ -0,0 +1,111 @@
+import { resolveConfig } from '../config.js';
+import { getPathMapping } from '../utils/path.js';
+import { endStream } from '../utils/stream.js';
+import { renderHtml } from '../renderers/html-renderer.js';
+import { decodeInput, hasStatusCode, deepFreeze } from '../renderers/utils.js';
+import { renderRsc, getSsrConfig } from '../renderers/rsc-renderer.js';
+export const CLIENT_PREFIX = 'client/';
+export function createHandler(options) {
+    const { config, ssr, unstable_prehook, unstable_posthook, loadEntries } = options;
+    if (!unstable_prehook && unstable_posthook) {
+        throw new Error('prehook is required if posthook is provided');
+    }
+    globalThis.__WAKU_PRIVATE_ENV__ = options.env || {};
+    const configPromise = resolveConfig(config || {});
+    const entries = loadEntries();
+    return async (req, res, next)=>{
+        const config = await configPromise;
+        const basePrefix = config.basePath + config.rscPath + '/';
+        const handleError = async (err)=>{
+            if (hasStatusCode(err)) {
+                res.setStatus(err.statusCode);
+            } else {
+                console.info('Cannot render RSC', err);
+                res.setStatus(500);
+            }
+            await endStream(res.stream);
+        };
+        let context;
+        try {
+            context = unstable_prehook?.(req, res);
+        } catch (e) {
+            await handleError(e);
+            return;
+        }
+        if (req.url.pathname.startsWith(basePrefix)) {
+            const { method, contentType } = req;
+            if (method !== 'GET' && method !== 'POST') {
+                throw new Error(`Unsupported method '${method}'`);
+            }
+            try {
+                const input = decodeInput(req.url.pathname.slice(basePrefix.length));
+                const readable = await renderRsc({
+                    config,
+                    input,
+                    searchParams: req.url.searchParams,
+                    method,
+                    context,
+                    body: req.stream,
+                    contentType
+                }, {
+                    isDev: false,
+                    entries: await entries
+                });
+                unstable_posthook?.(req, res, context);
+                deepFreeze(context);
+                await readable.pipeTo(res.stream);
+                return;
+            } catch (e) {
+                await handleError(e);
+                return;
+            }
+        }
+        if (ssr) {
+            try {
+                const resolvedEntries = await entries;
+                const { dynamicHtmlPaths } = resolvedEntries;
+                const htmlHead = dynamicHtmlPaths.find(([pathSpec])=>getPathMapping(pathSpec, req.url.pathname))?.[1];
+                if (htmlHead) {
+                    const readable = await renderHtml({
+                        config,
+                        pathname: req.url.pathname,
+                        searchParams: req.url.searchParams,
+                        htmlHead,
+                        renderRscForHtml: (input, searchParams)=>renderRsc({
+                                config,
+                                input,
+                                searchParams,
+                                method: 'GET',
+                                context
+                            }, {
+                                isDev: false,
+                                entries: resolvedEntries
+                            }),
+                        getSsrConfigForHtml: (pathname, searchParams)=>getSsrConfig({
+                                config,
+                                pathname,
+                                searchParams
+                            }, {
+                                isDev: false,
+                                entries: resolvedEntries
+                            }),
+                        loadClientModule: (key)=>resolvedEntries.loadModule(CLIENT_PREFIX + key),
+                        isDev: false,
+                        loadModule: resolvedEntries.loadModule
+                    });
+                    if (readable) {
+                        unstable_posthook?.(req, res, context);
+                        deepFreeze(context);
+                        res.setHeader('content-type', 'text/html; charset=utf-8');
+                        await readable.pipeTo(res.stream);
+                        return;
+                    }
+                }
+            } catch (e) {
+                await handleError(e);
+                return;
+            }
+        }
+        next();
+    };
+}
diff --git a/dist/lib/handlers/types.d.ts b/dist/lib/handlers/types.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5cfdc0feda55e64fe689a5a30b95b59f70915297
--- /dev/null
+++ b/dist/lib/handlers/types.d.ts
@@ -0,0 +1,12 @@
+export type BaseReq = {
+    stream: ReadableStream;
+    url: URL;
+    method: string;
+    contentType: string | undefined;
+};
+export type BaseRes = {
+    stream: WritableStream;
+    setHeader: (name: string, value: string) => void;
+    setStatus: (code: number) => void;
+};
+export type Handler<Req extends BaseReq, Res extends BaseRes> = (req: Req, res: Res, next: (err?: unknown) => void) => void;
diff --git a/dist/lib/handlers/types.js b/dist/lib/handlers/types.js
new file mode 100644
index 0000000000000000000000000000000000000000..2234b9cae16d695815aaabd8b93e789203d63dea
--- /dev/null
+++ b/dist/lib/handlers/types.js
@@ -0,0 +1 @@
+export { };
diff --git a/dist/lib/hono/runner.js b/dist/lib/hono/runner.js
index 0b164660649c2515b307df1202e1bae51bbe43a0..c8884c6adab29906073ce6177397bdbae9f37281 100644
--- a/dist/lib/hono/runner.js
+++ b/dist/lib/hono/runner.js
@@ -1,11 +1,10 @@
 import { resolveConfig } from '../config.js';
-// Experimental Unstable API
-const HONO_CONTEXT = '__hono_context';
 const createEmptyReadableStream = ()=>new ReadableStream({
         start (controller) {
             controller.close();
         }
     });
+// Middleware runner (Is there a better name?)
 export const runner = (options)=>{
     const entriesPromise = options.cmd === 'start' ? options.loadEntries() : 'Error: loadEntries are not available';
     const configPromise = options.cmd === 'start' ? entriesPromise.then((entries)=>entries.loadConfig().then((config)=>resolveConfig(config))) : resolveConfig(options.config);
@@ -19,9 +18,7 @@ export const runner = (options)=>{
                 headers: c.req.header()
             },
             res: {},
-            context: {
-                [HONO_CONTEXT]: c
-            }
+            context: {}
         };
         const handlers = await handlersPromise;
         const run = async (index)=>{
diff --git a/dist/lib/middleware/connect-dev.d.ts b/dist/lib/middleware/connect-dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..02956fedc5b3a4d461360812655fdc15d5649171
--- /dev/null
+++ b/dist/lib/middleware/connect-dev.d.ts
@@ -0,0 +1,3 @@
+/// <reference types="node" resolution-mode="require"/>
+import { createHandler } from '../handlers/handler-dev.js';
+export declare function connectMiddleware(...args: Parameters<typeof createHandler>): (connectReq: import("http").IncomingMessage, connectRes: import("http").ServerResponse<import("http").IncomingMessage>, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/middleware/connect-dev.js b/dist/lib/middleware/connect-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b0b41af7dffd0bc11060b22ada74829225e920a
--- /dev/null
+++ b/dist/lib/middleware/connect-dev.js
@@ -0,0 +1,5 @@
+import { connectWrapper } from './connect-utils.js';
+import { createHandler } from '../handlers/handler-dev.js';
+export function connectMiddleware(...args) {
+    return connectWrapper(createHandler(...args));
+}
diff --git a/dist/lib/middleware/connect-prd.d.ts b/dist/lib/middleware/connect-prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c82b619bed61ebd8f69c064522503df921a2aa64
--- /dev/null
+++ b/dist/lib/middleware/connect-prd.d.ts
@@ -0,0 +1,3 @@
+/// <reference types="node" resolution-mode="require"/>
+import { createHandler } from '../handlers/handler-prd.js';
+export declare function connectMiddleware(...args: Parameters<typeof createHandler>): (connectReq: import("http").IncomingMessage, connectRes: import("http").ServerResponse<import("http").IncomingMessage>, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/middleware/connect-prd.js b/dist/lib/middleware/connect-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..36235c05fbf4111973bcc3ccd3972973c1ca9c99
--- /dev/null
+++ b/dist/lib/middleware/connect-prd.js
@@ -0,0 +1,5 @@
+import { connectWrapper } from './connect-utils.js';
+import { createHandler } from '../handlers/handler-prd.js';
+export function connectMiddleware(...args) {
+    return connectWrapper(createHandler(...args));
+}
diff --git a/dist/lib/middleware/connect-utils.d.ts b/dist/lib/middleware/connect-utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..992568e9a1e4a60012de0a3ce5f2b8d74267be3f
--- /dev/null
+++ b/dist/lib/middleware/connect-utils.d.ts
@@ -0,0 +1,8 @@
+/// <reference types="node" resolution-mode="require"/>
+import type { IncomingMessage, ServerResponse } from 'node:http';
+import type { BaseReq, BaseRes, Handler } from '../handlers/types.js';
+export declare const connectWrapper: (m: Handler<BaseReq & {
+    orig: IncomingMessage;
+}, BaseRes & {
+    orig: ServerResponse;
+}>) => (connectReq: IncomingMessage, connectRes: ServerResponse, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/middleware/connect-utils.js b/dist/lib/middleware/connect-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd3bdb204722671cbe60fe9889b5ab6add4ba49d
--- /dev/null
+++ b/dist/lib/middleware/connect-utils.js
@@ -0,0 +1,19 @@
+export const connectWrapper = (m)=>{
+    return async (connectReq, connectRes, next)=>{
+        const { Readable, Writable } = await import('node:stream');
+        const req = {
+            stream: Readable.toWeb(connectReq),
+            method: connectReq.method || '',
+            url: new URL(connectReq.url || '', `http://${connectReq.headers.host}`),
+            contentType: connectReq.headers['content-type'],
+            orig: connectReq
+        };
+        const res = {
+            stream: Writable.toWeb(connectRes),
+            setStatus: (code)=>connectRes.statusCode = code,
+            setHeader: (name, value)=>connectRes.setHeader(name, value),
+            orig: connectRes
+        };
+        m(req, res, next);
+    };
+};
diff --git a/dist/lib/middleware/connectWrapper.js b/dist/lib/middleware/connectWrapper.js
new file mode 100644
index 0000000000000000000000000000000000000000..b50dd3745091c6fbbf7e3272395c15c676cfdc80
--- /dev/null
+++ b/dist/lib/middleware/connectWrapper.js
@@ -0,0 +1,19 @@
+export function connectWrapper(m) {
+    return async (connectReq, connectRes, next)=>{
+        const { Readable, Writable } = await import('node:stream');
+        const req = {
+            stream: Readable.toWeb(connectReq),
+            method: connectReq.method || '',
+            url: new URL(connectReq.url || '', `http://${connectReq.headers.host}`).toString(),
+            headers: connectReq.headers,
+            orig: connectReq
+        };
+        const res = {
+            stream: Writable.toWeb(connectRes),
+            setStatus: (code)=>connectRes.statusCode = code,
+            setHeader: (name, value)=>connectRes.setHeader(name, value),
+            orig: connectRes
+        };
+        m(req, res, next);
+    };
+}
diff --git a/dist/lib/middleware/dev-server-impl.d.ts b/dist/lib/middleware/dev-server-impl.d.ts
deleted file mode 100644
index 2dbc2de3a76facc66b02ef7b39bab48de3a465e6..0000000000000000000000000000000000000000
diff --git a/dist/lib/middleware/dev-server-impl.js b/dist/lib/middleware/dev-server-impl.js
index 7f580bf7d4c4cd3fed7994304993ccbd000255e8..923d8164b86cb8059eaa59b2fb17f6d3e1b7a87c 100644
--- a/dist/lib/middleware/dev-server-impl.js
+++ b/dist/lib/middleware/dev-server-impl.js
@@ -4,7 +4,8 @@ import { AsyncLocalStorage } from 'node:async_hooks';
 import { createServer as createViteServer } from 'vite';
 import viteReact from '@vitejs/plugin-react';
 import { resolveConfig } from '../config.js';
-import { joinPath, fileURLToFilePath, encodeFilePathToAbsolute, decodeFilePathFromAbsolute } from '../utils/path.js';
+import { SRC_MAIN, SRC_ENTRIES } from '../constants.js';
+import { joinPath, fileURLToFilePath, encodeFilePathToAbsolute, decodeFilePathFromAbsolute, filePathToFileURL } from '../utils/path.js';
 import { patchReactRefresh } from '../plugins/patch-react-refresh.js';
 import { nonjsResolvePlugin } from '../plugins/vite-plugin-nonjs-resolve.js';
 import { devCommonJsPlugin } from '../plugins/vite-plugin-dev-commonjs.js';
@@ -14,8 +15,7 @@ import { rscIndexPlugin } from '../plugins/vite-plugin-rsc-index.js';
 import { rscHmrPlugin, hotUpdate } from '../plugins/vite-plugin-rsc-hmr.js';
 import { rscEnvPlugin } from '../plugins/vite-plugin-rsc-env.js';
 import { rscPrivatePlugin } from '../plugins/vite-plugin-rsc-private.js';
-import { // HACK depending on these constants is not ideal
-SRC_ENTRIES, SRC_MAIN, rscManagedPlugin } from '../plugins/vite-plugin-rsc-managed.js';
+import { rscManagedPlugin } from '../plugins/vite-plugin-rsc-managed.js';
 import { rscDelegatePlugin } from '../plugins/vite-plugin-rsc-delegate.js';
 import { mergeUserViteConfig } from '../utils/merge-vite-config.js';
 // TODO there is huge room for refactoring in this file
@@ -136,7 +136,7 @@ const createMainViteServer = (env, configPromise)=>{
             // HACK node_modules should be externalized
             const file = fileURLToFilePath(idOrFileURL);
             const fileWithAbsolutePath = file.startsWith('/') ? file : joinPath(vite.config.root, file);
-            return import(/* @vite-ignore */ fileWithAbsolutePath);
+            return import(/* @vite-ignore */ filePathToFileURL(fileWithAbsolutePath));
         }
         return vite.ssrLoadModule(idOrFileURL.startsWith('file://') ? fileURLToFilePath(idOrFileURL) : idOrFileURL);
     };
@@ -241,6 +241,9 @@ const createRscViteServer = (env, configPromise)=>{
                         'react-server'
                     ]
                 },
+                external: [
+                    'hono/context-storage'
+                ],
                 noExternal: /^(?!node:)/,
                 optimizeDeps: {
                     include: [
diff --git a/dist/lib/middleware/dev-server.d.ts b/dist/lib/middleware/dev-server.d.ts
index 9675922b7ba491164d5504d2996d609ba85c6987..2dbc2de3a76facc66b02ef7b39bab48de3a465e6 100644
--- a/dist/lib/middleware/dev-server.d.ts
+++ b/dist/lib/middleware/dev-server.d.ts
@@ -1,7 +1,2 @@
 import type { Middleware } from './types.js';
-declare global {
-    interface ImportMeta {
-        readonly env: Record<string, string>;
-    }
-}
 export declare const devServer: Middleware;
diff --git a/dist/lib/middleware/headers.d.ts b/dist/lib/middleware/headers.d.ts
deleted file mode 100644
index 4861308e3625c76a222d77f161ae193190cbb08e..0000000000000000000000000000000000000000
diff --git a/dist/lib/middleware/hono-dev.d.ts b/dist/lib/middleware/hono-dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..655cee33529beccee99d93cf9cf318adc967294f
--- /dev/null
+++ b/dist/lib/middleware/hono-dev.d.ts
@@ -0,0 +1,3 @@
+import type { Env, Input } from 'hono';
+import { createHandler } from '../handlers/handler-dev.js';
+export declare function honoMiddleware<E extends Env = never, P extends string = string, I extends Input = Record<string, never>>(...args: Parameters<typeof createHandler>): import("hono").MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/middleware/hono-dev.js b/dist/lib/middleware/hono-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..aea0280cd1ffe13fe4de87d578de09fdad5d18f2
--- /dev/null
+++ b/dist/lib/middleware/hono-dev.js
@@ -0,0 +1,5 @@
+import { honoWrapper } from './hono-utils.js';
+import { createHandler } from '../handlers/handler-dev.js';
+export function honoMiddleware(...args) {
+    return honoWrapper(createHandler(...args));
+}
diff --git a/dist/lib/middleware/hono-prd.d.ts b/dist/lib/middleware/hono-prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82dfd4a0fd52527d57cfb8db76cca8c31bfb6bb4
--- /dev/null
+++ b/dist/lib/middleware/hono-prd.d.ts
@@ -0,0 +1,3 @@
+import type { Env, Input } from 'hono';
+import { createHandler } from '../handlers/handler-prd.js';
+export declare function honoMiddleware<E extends Env = never, P extends string = string, I extends Input = Record<string, never>>(...args: Parameters<typeof createHandler>): import("hono").MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/middleware/hono-prd.js b/dist/lib/middleware/hono-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..e00a45a36d8619fc1c994b888d2f2d6c285d9d44
--- /dev/null
+++ b/dist/lib/middleware/hono-prd.js
@@ -0,0 +1,5 @@
+import { honoWrapper } from './hono-utils.js';
+import { createHandler } from '../handlers/handler-prd.js';
+export function honoMiddleware(...args) {
+    return honoWrapper(createHandler(...args));
+}
diff --git a/dist/lib/middleware/hono-utils.d.ts b/dist/lib/middleware/hono-utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a69dc063a573c6f21622b08129e86db5e10b8b5d
--- /dev/null
+++ b/dist/lib/middleware/hono-utils.d.ts
@@ -0,0 +1,7 @@
+import type { MiddlewareHandler, Context, Env, Input } from 'hono';
+import type { BaseReq, BaseRes, Handler } from '../handlers/types.js';
+export declare const honoWrapper: <E extends Env, P extends string, I extends Input>(m: Handler<BaseReq & {
+    c: Context<E, P, I>;
+}, BaseRes & {
+    c: Context<E, P, I>;
+}>) => MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/middleware/hono-utils.js b/dist/lib/middleware/hono-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..d97dfa2dbfc9229d9c455ddc94caf17bff0c7626
--- /dev/null
+++ b/dist/lib/middleware/hono-utils.js
@@ -0,0 +1,60 @@
+const createEmptyReadableStream = ()=>new ReadableStream({
+        start (controller) {
+            controller.close();
+        }
+    });
+const createStreamPair = (callback)=>{
+    let controller;
+    const readable = new ReadableStream({
+        start (c) {
+            controller = c;
+        },
+        cancel () {
+            controller = undefined;
+        }
+    });
+    let hasData = false;
+    const writable = new WritableStream({
+        write (chunk) {
+            if (!controller) {
+                return;
+            }
+            controller.enqueue(chunk);
+            if (!hasData) {
+                hasData = true;
+                callback(readable);
+            }
+        },
+        close () {
+            if (!controller) {
+                return;
+            }
+            controller.close();
+            if (!hasData) {
+                callback(null);
+            }
+        }
+    });
+    return writable;
+};
+export const honoWrapper = (m)=>{
+    return (c, next)=>new Promise((resolve)=>{
+            const req = {
+                stream: c.req.raw.body || createEmptyReadableStream(),
+                method: c.req.method,
+                url: new URL(c.req.url),
+                contentType: c.req.header('content-type'),
+                c
+            };
+            const writable = createStreamPair((readable)=>{
+                resolve(c.body(readable));
+            });
+            const res = {
+                stream: writable,
+                setStatus: (code)=>c.status(code),
+                setHeader: (name, value)=>c.header(name, value),
+                c
+            };
+            m(req, res, ()=>next().then(resolve));
+        });
+};
diff --git a/dist/lib/middleware/honoWrapper.js b/dist/lib/middleware/honoWrapper.js
new file mode 100644
index 0000000000000000000000000000000000000000..ae390bde3a942a405588b5bc441929db079fb7f7
--- /dev/null
+++ b/dist/lib/middleware/honoWrapper.js
@@ -0,0 +1,54 @@
+const createEmptyReadableStream = ()=>new ReadableStream({
+        start (controller) {
+            controller.close();
+        }
+    });
+const createStreamPair = (callback)=>{
+    let controller;
+    const readable = new ReadableStream({
+        start (c) {
+            controller = c;
+        }
+    });
+    let hasData = false;
+    const writable = new WritableStream({
+        write (chunk) {
+            controller.enqueue(chunk);
+            if (!hasData) {
+                hasData = true;
+                callback(readable);
+            }
+        },
+        close () {
+            controller.close();
+            if (!hasData) {
+                callback(null);
+            }
+        }
+    });
+    return writable;
+};
+export function honoWrapper(m) {
+    return (c, next)=>new Promise((resolve)=>{
+            const req = {
+                stream: c.req.raw.body || createEmptyReadableStream(),
+                method: c.req.method,
+                url: c.req.url,
+                headers: Object.fromEntries(Array.from(c.req.raw.headers.entries()).map(([k, v])=>[
+                        k,
+                        v
+                    ])),
+                c
+            };
+            const writable = createStreamPair((readable)=>{
+                resolve(c.body(readable));
+            });
+            const res = {
+                stream: writable,
+                setStatus: (code)=>c.status(code),
+                setHeader: (name, value)=>c.header(name, value),
+                c
+            };
+            m(req, res, ()=>next().then(resolve));
+        });
+}
diff --git a/dist/lib/middleware/rsc/ssr.d.ts b/dist/lib/middleware/rsc/ssr.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b55d5870af462ba38597570f3d58faeb28946188
--- /dev/null
+++ b/dist/lib/middleware/rsc/ssr.d.ts
@@ -0,0 +1,5 @@
+import type { Readable } from 'node:stream';
+import { resolveConfig } from '../../config.js';
+export declare const shutdown: () => Promise<void>;
+export declare const loadServerFile: (fname: string, command: 'dev' | 'build' | 'start') => Promise<any>;
+export declare const renderHtml: <Context>(config: Awaited<ReturnType<typeof resolveConfig>>, command: 'dev' | 'build' | 'start', pathStr: string, htmlStr: string, context: Context) => Promise<readonly [Readable, Context] | null>;
diff --git a/dist/lib/middleware/rsc/ssr.js b/dist/lib/middleware/rsc/ssr.js
new file mode 100644
index 0000000000000000000000000000000000000000..65f7526592b21f3cf8d5bbeb85688af9c44e404b
--- /dev/null
+++ b/dist/lib/middleware/rsc/ssr.js
@@ -0,0 +1,311 @@
+import path from 'node:path'; // TODO no node dependency
+import url from 'node:url'; // TODO no node dependency
+import { viteInlineConfig } from '../../config.js';
+import { concatUint8Arrays } from '../../utils/stream.js';
+import { normalizePath } from '../../utils/path.js';
+import { renderRSC } from './worker-api.js';
+import { hasStatusCode } from './utils.js';
+const loadReact = async (config, command)=>{
+    if (command !== 'dev') {
+        return (await import(url.pathToFileURL(path.join(config.rootDir, config.distDir, config.publicDir, config.assetsDir, 'react.js')).toString())).default;
+    }
+    return import('react');
+};
+const loadRDServer = async (config, command)=>{
+    if (command !== 'dev') {
+        return (await import(url.pathToFileURL(path.join(config.rootDir, config.distDir, config.publicDir, config.assetsDir, 'rd-server.js')).toString())).default;
+    }
+    return import('react-dom/server.edge');
+};
+const loadRSDWClient = async (config, command)=>{
+    if (command !== 'dev') {
+        return (await import(url.pathToFileURL(path.join(config.rootDir, config.distDir, config.publicDir, config.assetsDir, 'rsdw-client.js')).toString())).default;
+    }
+    return import('react-server-dom-webpack/client.edge');
+};
+const loadWakuClient = async (config, command)=>{
+    if (command !== 'dev') {
+        return import(url.pathToFileURL(path.join(config.rootDir, config.distDir, config.publicDir, config.assetsDir, 'waku-client.js')).toString());
+    }
+    return import('waku/client');
+};
+// HACK for react-server-dom-webpack without webpack
+const moduleCache = new Map();
+globalThis.__webpack_chunk_load__ ||= async (id)=>{
+    const [filePath, command] = id.split('#');
+    const m = await loadServerFile(filePath, command || 'start');
+    moduleCache.set(id, m);
+};
+globalThis.__webpack_require__ ||= (id)=>moduleCache.get(id);
+let lastViteServer;
+const getViteServer = async ()=>{
+    if (lastViteServer) {
+        return lastViteServer;
+    }
+    const { Server } = await import('node:http');
+    const dummyServer = new Server(); // FIXME we hope to avoid this hack
+    const { createServer: viteCreateServer } = await import('vite');
+    const { nonjsResolvePlugin } = await import('../../vite-plugin/nonjs-resolve-plugin.js');
+    const viteServer = await viteCreateServer({
+        ...await viteInlineConfig(),
+        plugins: [
+            nonjsResolvePlugin()
+        ],
+        ssr: {
+            external: [
+                'waku'
+            ]
+        },
+        appType: 'custom',
+        server: {
+            middlewareMode: true,
+            hmr: {
+                server: dummyServer
+            }
+        }
+    });
+    await viteServer.watcher.close(); // TODO watch: null
+    await viteServer.ws.close();
+    lastViteServer = viteServer;
+    return viteServer;
+};
+export const shutdown = async ()=>{
+    if (lastViteServer) {
+        await lastViteServer.close();
+        lastViteServer = undefined;
+    }
+};
+const loadServerFile = async (fname, command)=>{
+    if (command !== 'dev') {
+        return import(fname);
+    }
+    const vite = await getViteServer();
+    return vite.ssrLoadModule(fname);
+};
+const getEntriesFile = (config, command)=>{
+    const filePath = path.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir, config.entriesJs);
+    return command === 'dev' ? filePath : url.pathToFileURL(filePath).toString();
+};
+const fakeFetchCode = `
+Promise.resolve({
+  ok: true,
+  body: new ReadableStream({
+    start(c) {
+      const f = (s) => new TextEncoder().encode(decodeURI(s));
+      globalThis.__WAKU_PUSH__ = (s) => s ? c.enqueue(f(s)) : c.close();
+    }
+  })
+})
+`.split('\n').map((line)=>line.trim()).join('');
+const injectRscPayload = (readable, input)=>{
+    const chunks = [];
+    let closed = false;
+    let notify;
+    const copied = readable.pipeThrough(new TransformStream({
+        transform (chunk, controller) {
+            if (!(chunk instanceof Uint8Array)) {
+                throw new Error('Unknown chunk type');
+            }
+            chunks.push(chunk);
+            notify?.();
+            controller.enqueue(chunk);
+        },
+        flush () {
+            closed = true;
+            notify?.();
+        }
+    }));
+    const modifyHead = (data)=>{
+        const matchPrefetched = data.match(// HACK This is very brittle
+        /(.*)<script>\nglobalThis\.__WAKU_PREFETCHED__ = {\n(.*?)\n};(.*)/s);
+        let prefetchedLines = [];
+        if (matchPrefetched) {
+            prefetchedLines = matchPrefetched[2].split('\n');
+            data = matchPrefetched[1] + '<script>\n' + matchPrefetched[3];
+        }
+        const closingHeadIndex = data.indexOf('</head>');
+        if (closingHeadIndex === -1) {
+            throw new Error('closing head not found');
+        }
+        data = data.slice(0, closingHeadIndex) + `
+<script>
+globalThis.__WAKU_PREFETCHED__ = {
+${prefetchedLines.filter((line)=>!line.startsWith(`  '${input}':`)).join('\n')}
+  '${input}': ${fakeFetchCode},
+};
+globalThis.__WAKU_SSR_ENABLED__ = true;
+</script>
+` + data.slice(closingHeadIndex);
+        return data;
+    };
+    const encoder = new TextEncoder();
+    const decoder = new TextDecoder();
+    const getScripts = ()=>{
+        const scripts = chunks.splice(0).map((chunk)=>`
+<script>globalThis.__WAKU_PUSH__("${encodeURI(decoder.decode(chunk))}")</script>`);
+        if (closed) {
+            scripts.push(`
+<script>globalThis.__WAKU_PUSH__()</script>`);
+        }
+        return scripts.join('');
+    };
+    const interleave = (preamble, intermediate, postamble)=>{
+        let preambleSent = false;
+        return new TransformStream({
+            transform (chunk, controller) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                if (!preambleSent) {
+                    preambleSent = true;
+                    controller.enqueue(concatUint8Arrays([
+                        encoder.encode(modifyHead(preamble)),
+                        chunk,
+                        encoder.encode(intermediate)
+                    ]));
+                    notify = ()=>controller.enqueue(encoder.encode(getScripts()));
+                    notify();
+                    return;
+                }
+                controller.enqueue(chunk);
+            },
+            flush (controller) {
+                if (!preambleSent) {
+                    throw new Error('preamble not yet sent');
+                }
+                if (!closed) {
+                    return new Promise((resolve)=>{
+                        notify = ()=>{
+                            controller.enqueue(encoder.encode(getScripts()));
+                            if (closed) {
+                                controller.enqueue(encoder.encode(postamble));
+                                resolve();
+                            }
+                        };
+                    });
+                }
+                controller.enqueue(encoder.encode(postamble));
+            }
+        });
+    };
+    return [
+        copied,
+        interleave
+    ];
+};
+// HACK for now, do we want to use HTML parser?
+const rectifyHtml = ()=>{
+    const pending = [];
+    const decoder = new TextDecoder();
+    return new TransformStream({
+        transform (chunk, controller) {
+            if (!(chunk instanceof Uint8Array)) {
+                throw new Error('Unknown chunk type');
+            }
+            pending.push(chunk);
+            if (/<\/\w+>$/.test(decoder.decode(chunk))) {
+                controller.enqueue(concatUint8Arrays(pending.splice(0)));
+            }
+        },
+        flush (controller) {
+            if (!pending.length) {
+                controller.enqueue(concatUint8Arrays(pending.splice(0)));
+            }
+        }
+    });
+};
+export const renderHtml = async (config, command, pathStr, htmlStr, context)=>{
+    const [{ createElement }, { renderToReadableStream }, { createFromReadableStream }, { ServerRoot, Slot }] = await Promise.all([
+        loadReact(config, command),
+        loadRDServer(config, command),
+        loadRSDWClient(config, command),
+        loadWakuClient(config, command)
+    ]);
+    const entriesFile = getEntriesFile(config, command);
+    const { default: { getSsrConfig } } = await loadServerFile(entriesFile, command);
+    const ssrConfig = await getSsrConfig?.(pathStr);
+    if (!ssrConfig) {
+        return null;
+    }
+    let stream;
+    let nextCtx;
+    try {
+        [stream, nextCtx] = await renderRSC({
+            input: ssrConfig.input,
+            method: 'GET',
+            headers: {},
+            config,
+            command,
+            context
+        });
+    } catch (e) {
+        if (hasStatusCode(e) && e.statusCode === 404) {
+            return null;
+        }
+        throw e;
+    }
+    const { splitHTML } = config.ssr;
+    const moduleMap = new Proxy({}, {
+        get (_target, filePath) {
+            return new Proxy({}, {
+                get (_target, name) {
+                    const file = filePath.slice(config.basePath.length);
+                    if (command === 'dev') {
+                        const filePath = normalizePath(file.startsWith('@fs/') ? // remove '@fs'(3) on Unix and '@fs/'(4) on Windows
+                        file.slice(path.sep === '/' ? 3 : 4) : path.join(config.rootDir, config.srcDir, file));
+                        // FIXME This is ugly. We need to refactor it.
+                        const wakuDist = normalizePath(path.join(url.fileURLToPath(import.meta.url), '..', '..', '..', '..'));
+                        if (filePath.startsWith(wakuDist)) {
+                            const id = 'waku' + filePath.slice(wakuDist.length).replace(/\.\w+$/, '');
+                            return {
+                                id,
+                                chunks: [
+                                    id
+                                ],
+                                name
+                            };
+                        }
+                        const id = url.pathToFileURL(filePath).toString().slice('file://'.length) + '#dev';
+                        return {
+                            id,
+                            chunks: [
+                                id
+                            ],
+                            name
+                        };
+                    }
+                    // command !== 'dev'
+                    const id = url.pathToFileURL(path.join(config.rootDir, config.distDir, config.publicDir, file)).toString();
+                    return {
+                        id,
+                        chunks: [
+                            id
+                        ],
+                        name
+                    };
+                }
+            });
+        }
+    });
+    const [copied, interleave] = injectRscPayload(stream, ssrConfig.input);
+    const elements = createFromReadableStream(copied, {
+        ssrManifest: {
+            moduleMap,
+            moduleLoading: null
+        }
+    });
+    const readable = (await renderToReadableStream(createElement(ServerRoot, {
+        elements
+    }, ssrConfig.unstable_render({
+        createElement,
+        Slot
+    })), {
+        onError (err) {
+            console.error(err);
+        }
+    })).pipeThrough(rectifyHtml()).pipeThrough(interleave(...splitHTML(htmlStr)));
+    return [
+        readable,
+        nextCtx
+    ];
+};
diff --git a/dist/lib/middleware/rsc/utils.d.ts b/dist/lib/middleware/rsc/utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8d71e89dd62efd39fc712eeaa55672306f22f618
--- /dev/null
+++ b/dist/lib/middleware/rsc/utils.d.ts
@@ -0,0 +1,8 @@
+export declare const encodeInput: (input: string) => string;
+export declare const decodeInput: (encodedInput: string) => string;
+export declare const hasStatusCode: (x: unknown) => x is {
+    statusCode: number;
+};
+export declare const codeToInject = "\nglobalThis.__waku_module_cache__ = new Map();\nglobalThis.__webpack_chunk_load__ = (id) => import(id).then((m) => globalThis.__waku_module_cache__.set(id, m));\nglobalThis.__webpack_require__ = (id) => globalThis.__waku_module_cache__.get(id);";
+export declare const generatePrefetchCode: (basePrefix: string, inputs: Iterable<string>, moduleIds: Iterable<string>) => string;
+export declare const deepFreeze: (x: unknown) => void;
diff --git a/dist/lib/middleware/rsc/utils.js b/dist/lib/middleware/rsc/utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..be59ce563b9df45aad8894f0ddbcec2d973b020a
--- /dev/null
+++ b/dist/lib/middleware/rsc/utils.js
@@ -0,0 +1,79 @@
+// This file should not include Node specific code.
+export const encodeInput = (input)=>{
+    if (input === '') {
+        return '_';
+    } else if (!input.startsWith('_')) {
+        return input;
+    }
+    throw new Error("Input must not start with '_'");
+};
+export const decodeInput = (encodedInput)=>{
+    if (encodedInput === '_') {
+        return '';
+    } else if (!encodedInput.startsWith('_')) {
+        return encodedInput;
+    }
+    throw new Error('Invalid encoded input');
+};
+export const hasStatusCode = (x)=>typeof x?.statusCode === 'number';
+export const codeToInject = `
+globalThis.__waku_module_cache__ = new Map();
+globalThis.__webpack_chunk_load__ = (id) => import(id).then((m) => globalThis.__waku_module_cache__.set(id, m));
+globalThis.__webpack_require__ = (id) => globalThis.__waku_module_cache__.get(id);`;
+export const generatePrefetchCode = (basePrefix, inputs, moduleIds)=>{
+    const inputsArray = Array.from(inputs);
+    let code = '';
+    if (inputsArray.length) {
+        code += `
+globalThis.__WAKU_PREFETCHED__ = {
+${inputsArray.map((input)=>`  '${input}': fetch('${basePrefix}${encodeInput(input)}')`).join(',\n')}
+};`;
+    }
+    for (const moduleId of moduleIds){
+        code += `
+import('${moduleId}');`;
+    }
+    return code;
+};
+export const deepFreeze = (x)=>{
+    if (typeof x === 'object' && x !== null) {
+        Object.freeze(x);
+        for (const value of Object.values(x)){
+            deepFreeze(value);
+        }
+    }
+};
+// TODO is this correct? better to use a library?
+export const parseFormData = (body, contentType)=>{
+    const boundary = contentType.split('boundary=')[1];
+    const parts = body.split(`--${boundary}`);
+    const formData = new FormData();
+    for (const part of parts){
+        if (part.trim() === '' || part === '--') continue;
+        const [rawHeaders, content] = part.split('\r\n\r\n', 2);
+        const headers = rawHeaders.split('\r\n').reduce((acc, currentHeader)=>{
+            const [key, value] = currentHeader.split(': ');
+            acc[key.toLowerCase()] = value;
+            return acc;
+        }, {});
+        const contentDisposition = headers['content-disposition'];
+        const nameMatch = /name="([^"]+)"/.exec(contentDisposition);
+        const filenameMatch = /filename="([^"]+)"/.exec(contentDisposition);
+        if (nameMatch) {
+            const name = nameMatch[1];
+            if (filenameMatch) {
+                const filename = filenameMatch[1];
+                const type = headers['content-type'] || 'application/octet-stream';
+                const blob = new Blob([
+                    content
+                ], {
+                    type
+                });
+                formData.append(name, blob, filename);
+            } else {
+                formData.append(name, content.trim());
+            }
+        }
+    }
+    return formData;
+};
diff --git a/dist/lib/middleware/rsc/worker-api.d.ts b/dist/lib/middleware/rsc/worker-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6b47594c5186559c91668f4e515a90481a091063
--- /dev/null
+++ b/dist/lib/middleware/rsc/worker-api.d.ts
@@ -0,0 +1,77 @@
+/// <reference types="node" resolution-mode="require"/>
+import type { Readable } from 'node:stream';
+import { Worker } from 'node:worker_threads';
+import type { GetBuildConfig } from '../../../server.js';
+export type RenderRequest = {
+    input: string;
+    method: 'GET' | 'POST';
+    headers: Record<string, string | string[] | undefined>;
+    command: 'dev' | 'build' | 'start';
+    context: unknown;
+    stream?: Readable;
+    moduleIdCallback?: (id: string) => void;
+};
+export type BuildOutput = {
+    rscFiles: string[];
+    htmlFiles: string[];
+};
+export type MessageReq = {
+    type: 'shutdown';
+} | ({
+    id: number;
+    type: 'render';
+    hasModuleIdCallback: boolean;
+} & Omit<RenderRequest, 'stream' | 'moduleIdCallback'>) | {
+    id: number;
+    type: 'buf';
+    buf: ArrayBuffer;
+    offset: number;
+    len: number;
+} | {
+    id: number;
+    type: 'end';
+} | {
+    id: number;
+    type: 'err';
+    err: unknown;
+} | {
+    id: number;
+    type: 'getBuildConfig';
+};
+export type MessageRes = {
+    type: 'full-reload';
+} | {
+    type: 'hot-import';
+    source: string;
+} | {
+    id: number;
+    type: 'start';
+    context: unknown;
+} | {
+    id: number;
+    type: 'buf';
+    buf: ArrayBuffer;
+    offset: number;
+    len: number;
+} | {
+    id: number;
+    type: 'end';
+} | {
+    id: number;
+    type: 'err';
+    err: unknown;
+    statusCode?: number;
+} | {
+    id: number;
+    type: 'moduleId';
+    moduleId: string;
+} | {
+    id: number;
+    type: 'buildConfig';
+    output: Awaited<ReturnType<GetBuildConfig>>;
+};
+export declare function registerReloadCallback(fn: (type: 'full-reload') => void): () => Worker;
+export declare function registerImportCallback(fn: (source: string) => void): () => Worker;
+export declare function shutdown(): Promise<void>;
+export declare function renderRSC<Context>(rr: RenderRequest): Promise<readonly [Readable, Context]>;
+export declare function getBuildConfigRSC(): ReturnType<GetBuildConfig>;
diff --git a/dist/lib/middleware/rsc/worker-api.js b/dist/lib/middleware/rsc/worker-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..8dd8a357d969d1d5c079eebfd2dcf9a8a4232674
--- /dev/null
+++ b/dist/lib/middleware/rsc/worker-api.js
@@ -0,0 +1,203 @@
+import { Worker } from 'node:worker_threads'; // TODO no node dependency
+const messageCallbacks = new Map();
+let lastCommand;
+let lastWorker;
+const getWorker = (command)=>{
+    if (lastWorker) {
+        if (lastCommand !== command) {
+            throw new Error('cannot create worker with different command');
+        }
+        return lastWorker;
+    }
+    const IS_NODE_18 = Number(process.versions.node.split('.')[0]) < 20;
+    const worker = new Worker(new URL('worker-impl.js', import.meta.url), {
+        execArgv: command !== 'dev' ? [] : [
+            ...IS_NODE_18 ? [
+                '--experimental-loader',
+                'waku/node-loader'
+            ] : [],
+            '--conditions',
+            'react-server'
+        ]
+    });
+    worker.on('message', (mesg)=>{
+        if ('id' in mesg) {
+            messageCallbacks.get(mesg.id)?.(mesg);
+        }
+    });
+    lastCommand = command;
+    lastWorker = worker;
+    return worker;
+};
+export function registerReloadCallback(fn) {
+    const worker = getWorker('dev');
+    const listener = (mesg)=>{
+        if (mesg.type === 'full-reload') {
+            fn(mesg.type);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+export function registerImportCallback(fn) {
+    const worker = getWorker('dev');
+    const listener = (mesg)=>{
+        if (mesg.type === 'hot-import') {
+            fn(mesg.source);
+        }
+    };
+    worker.on('message', listener);
+    return ()=>worker.off('message', listener);
+}
+export function shutdown() {
+    const worker = lastWorker;
+    if (!worker) {
+        throw new Error('No worker to shutdown');
+    }
+    return new Promise((resolve)=>{
+        worker.on('close', resolve);
+        const mesg = {
+            type: 'shutdown'
+        };
+        worker.postMessage(mesg);
+    });
+}
+let nextId = 1;
+export function renderRSC(rr) {
+    const worker = getWorker(rr.command);
+    const id = nextId++;
+    const pipe = async ()=>{
+        if (rr.stream) {
+            const reader = rr.stream.getReader();
+            try {
+                let result;
+                do {
+                    result = await reader.read();
+                    if (result.value) {
+                        const buf = result.value;
+                        let mesg;
+                        if (buf instanceof ArrayBuffer) {
+                            mesg = {
+                                id,
+                                type: 'buf',
+                                buf,
+                                offset: 0,
+                                len: buf.byteLength
+                            };
+                        } else if (buf instanceof Uint8Array) {
+                            mesg = {
+                                id,
+                                type: 'buf',
+                                buf: buf.buffer,
+                                offset: buf.byteOffset,
+                                len: buf.byteLength
+                            };
+                        } else {
+                            throw new Error('Unexepected buffer type');
+                        }
+                        worker.postMessage(mesg, [
+                            mesg.buf
+                        ]);
+                    }
+                }while (!result.done)
+            } catch (err) {
+                const mesg = {
+                    id,
+                    type: 'err',
+                    err
+                };
+                worker.postMessage(mesg);
+            }
+        }
+        const mesg = {
+            id,
+            type: 'end'
+        };
+        worker.postMessage(mesg);
+    };
+    let started = false;
+    return new Promise((resolve, reject)=>{
+        let controller;
+        const stream = new ReadableStream({
+            start (c) {
+                controller = c;
+            }
+        });
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'start') {
+                if (!started) {
+                    started = true;
+                    resolve([
+                        stream,
+                        mesg.context
+                    ]);
+                } else {
+                    throw new Error('already started');
+                }
+            } else if (mesg.type === 'buf') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                controller.enqueue(new Uint8Array(mesg.buf, mesg.offset, mesg.len));
+            } else if (mesg.type === 'moduleId') {
+                rr.moduleIdCallback?.(mesg.moduleId);
+            } else if (mesg.type === 'end') {
+                if (!started) {
+                    throw new Error('not yet started');
+                }
+                controller.close();
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                if (!started) {
+                    reject(err);
+                } else {
+                    controller.error(err);
+                }
+                messageCallbacks.delete(id);
+            }
+        });
+        // eslint-disable-next-line @typescript-eslint/no-unused-vars
+        const { ssr: _removed, ...copiedConfig } = rr.config; // HACK type
+        const copied = {
+            ...rr,
+            config: copiedConfig
+        };
+        delete copied.stream;
+        delete copied.moduleIdCallback;
+        const mesg = {
+            id,
+            type: 'render',
+            hasModuleIdCallback: !!rr.moduleIdCallback,
+            ...copied
+        };
+        worker.postMessage(mesg);
+        pipe();
+    });
+}
+export function getBuildConfigRSC(config) {
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const { ssr: _removed, ...copiedConfig } = config;
+    const worker = getWorker('build');
+    return new Promise((resolve, reject)=>{
+        const id = nextId++;
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'buildConfig') {
+                resolve(mesg.output);
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                reject(mesg.err);
+                messageCallbacks.delete(id);
+            }
+        });
+        const mesg = {
+            id,
+            type: 'getBuildConfig',
+            config: copiedConfig
+        };
+        worker.postMessage(mesg);
+    });
+}
diff --git a/dist/lib/middleware/rsc/worker-impl.d.ts b/dist/lib/middleware/rsc/worker-impl.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/lib/middleware/rsc/worker-impl.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/lib/middleware/rsc/worker-impl.js b/dist/lib/middleware/rsc/worker-impl.js
new file mode 100644
index 0000000000000000000000000000000000000000..390819de34179804d68e1c4bde3dbe1db8848b15
--- /dev/null
+++ b/dist/lib/middleware/rsc/worker-impl.js
@@ -0,0 +1,371 @@
+import path from 'node:path'; // TODO no node dependency
+import url from 'node:url'; // TODO no node dependency
+import { parentPort } from 'node:worker_threads'; // TODO no node dependency
+import { viteInlineConfig } from '../../config.js';
+import { normalizePath } from '../../utils/path.js';
+import { hasStatusCode, deepFreeze, parseFormData } from './utils.js';
+let nodeLoaderRegistered = false;
+const loadRSDWServer = async (config, command)=>{
+    if (command !== 'dev') {
+        return (await import(url.pathToFileURL(path.join(config.rootDir, config.distDir, 'rsdw-server.js')).toString())).default;
+    }
+    if (!nodeLoaderRegistered) {
+        nodeLoaderRegistered = true;
+        const IS_NODE_20 = Number(process.versions.node.split('.')[0]) >= 20;
+        if (IS_NODE_20) {
+            const { default: { register } } = await import('node:module');
+            register('waku/node-loader', url.pathToFileURL('./'));
+        }
+    }
+    return import('react-server-dom-webpack/server.edge');
+};
+const controllerMap = new Map();
+const handleRender = async (mesg)=>{
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars
+    const { id, type, hasModuleIdCallback, ...rest } = mesg;
+    const rr = rest;
+    try {
+        const stream = new ReadableStream({
+            start (controller) {
+                controllerMap.set(id, controller);
+            }
+        });
+        rr.stream = stream;
+        if (hasModuleIdCallback) {
+            rr.moduleIdCallback = (moduleId)=>{
+                const mesg = {
+                    id,
+                    type: 'moduleId',
+                    moduleId
+                };
+                parentPort.postMessage(mesg);
+            };
+        }
+        const readable = await renderRSC(rr);
+        const mesg = {
+            id,
+            type: 'start',
+            context: rr.context
+        };
+        parentPort.postMessage(mesg);
+        deepFreeze(rr.context);
+        const writable = new WritableStream({
+            write (chunk) {
+                if (!(chunk instanceof Uint8Array)) {
+                    throw new Error('Unknown chunk type');
+                }
+                const mesg = {
+                    id,
+                    type: 'buf',
+                    buf: chunk.buffer,
+                    offset: chunk.byteOffset,
+                    len: chunk.byteLength
+                };
+                parentPort.postMessage(mesg, [
+                    mesg.buf
+                ]);
+            },
+            close () {
+                const mesg = {
+                    id,
+                    type: 'end'
+                };
+                parentPort.postMessage(mesg);
+            }
+        });
+        readable.pipeTo(writable);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err
+        };
+        if (hasStatusCode(err)) {
+            mesg.statusCode = err.statusCode;
+        }
+        parentPort.postMessage(mesg);
+    }
+};
+const handleGetBuildConfig = async (mesg)=>{
+    const { id, config } = mesg;
+    try {
+        const output = await getBuildConfigRSC(config);
+        const mesg = {
+            id,
+            type: 'buildConfig',
+            output
+        };
+        parentPort.postMessage(mesg);
+    } catch (err) {
+        const mesg = {
+            id,
+            type: 'err',
+            err
+        };
+        parentPort.postMessage(mesg);
+    }
+};
+let lastViteServer;
+const getViteServer = async ()=>{
+    if (lastViteServer) {
+        return lastViteServer;
+    }
+    const { Server } = await import('node:http');
+    const dummyServer = new Server(); // FIXME we hope to avoid this hack
+    const { createServer: viteCreateServer } = await import('vite');
+    const { rscTransformPlugin } = await import('../../vite-plugin/rsc-transform-plugin.js');
+    const { rscReloadPlugin } = await import('../../vite-plugin/rsc-reload-plugin.js');
+    const { rscDelegatePlugin } = await import('../../vite-plugin/rsc-delegate-plugin.js');
+    const viteServer = await viteCreateServer({
+        ...await viteInlineConfig(),
+        plugins: [
+            rscTransformPlugin(false),
+            rscReloadPlugin((type)=>{
+                const mesg = {
+                    type
+                };
+                parentPort.postMessage(mesg);
+            }),
+            rscDelegatePlugin((source)=>{
+                const mesg = {
+                    type: 'hot-import',
+                    source
+                };
+                parentPort.postMessage(mesg);
+            })
+        ],
+        ssr: {
+            resolve: {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                externalConditions: [
+                    'react-server',
+                    'workerd'
+                ]
+            },
+            external: [
+                'react',
+                'react-server-dom-webpack',
+                'waku'
+            ],
+            noExternal: /^(?!node:)/
+        },
+        appType: 'custom',
+        server: {
+            middlewareMode: true,
+            hmr: {
+                server: dummyServer
+            }
+        }
+    });
+    await viteServer.ws.close();
+    lastViteServer = viteServer;
+    return viteServer;
+};
+const shutdown = async ()=>{
+    if (lastViteServer) {
+        await lastViteServer.close();
+        lastViteServer = undefined;
+    }
+    parentPort.close();
+};
+const loadServerFile = async (fname, command)=>{
+    if (command !== 'dev') {
+        return import(fname);
+    }
+    const vite = await getViteServer();
+    return vite.ssrLoadModule(fname);
+};
+parentPort.on('message', (mesg)=>{
+    if (mesg.type === 'shutdown') {
+        shutdown();
+    } else if (mesg.type === 'render') {
+        handleRender(mesg);
+    } else if (mesg.type === 'getBuildConfig') {
+        handleGetBuildConfig(mesg);
+    } else if (mesg.type === 'buf') {
+        const controller = controllerMap.get(mesg.id);
+        controller.enqueue(new Uint8Array(mesg.buf, mesg.offset, mesg.len));
+    } else if (mesg.type === 'end') {
+        const controller = controllerMap.get(mesg.id);
+        controller.close();
+    } else if (mesg.type === 'err') {
+        const controller = controllerMap.get(mesg.id);
+        const err = mesg.err instanceof Error ? mesg.err : new Error(String(mesg.err));
+        controller.error(err);
+    }
+});
+const getEntriesFile = (config, command)=>{
+    const filePath = path.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir, config.entriesJs);
+    return normalizePath(command === 'dev' ? filePath : url.pathToFileURL(filePath).toString());
+};
+const resolveClientEntry = (filePath, config, command)=>{
+    filePath = filePath.startsWith('file:///') ? url.fileURLToPath(filePath) : filePath;
+    const root = path.join(config.rootDir, command === 'dev' ? config.srcDir : config.distDir);
+    if (!filePath.startsWith(root)) {
+        if (command === 'dev') {
+            // HACK this relies on Vite's internal implementation detail.
+            return normalizePath(config.basePath + '@fs/' + filePath.replace(/^\//, ''));
+        } else {
+            throw new Error('Resolving client module outside root is unsupported for now');
+        }
+    }
+    return normalizePath(config.basePath + path.relative(root, filePath));
+};
+// HACK Patching stream is very fragile.
+const transformRsfId = (prefixToRemove)=>{
+    const encoder = new TextEncoder();
+    const decoder = new TextDecoder();
+    let data = '';
+    return new TransformStream({
+        transform (chunk, controller) {
+            if (!(chunk instanceof Uint8Array)) {
+                throw new Error('Unknown chunk type');
+            }
+            data += decoder.decode(chunk);
+            if (!data.endsWith('\n')) {
+                return;
+            }
+            const lines = data.split('\n');
+            data = '';
+            for(let i = 0; i < lines.length; ++i){
+                const match = lines[i].match(new RegExp(`^([0-9]+):{"id":"(?:file:///?)?${prefixToRemove}(.*?)"(.*)$`));
+                if (match) {
+                    lines[i] = `${match[1]}:{"id":"${match[2]}"${match[3]}`;
+                }
+            }
+            controller.enqueue(encoder.encode(lines.join('\n')));
+        }
+    });
+};
+async function renderRSC(rr) {
+    const config = rr.config;
+    const { renderToReadableStream, decodeReply } = await loadRSDWServer(config, rr.command);
+    const { runWithAsyncLocalStorage } = await loadServerFile('waku/server', rr.command);
+    const entriesFile = getEntriesFile(config, rr.command);
+    const { default: { renderEntries } } = await loadServerFile(entriesFile, rr.command);
+    const rsfPrefix = path.posix.join(config.rootDir, rr.command === 'dev' ? config.srcDir : config.distDir) + '/';
+    const render = async (input)=>{
+        const elements = await renderEntries(input);
+        if (elements === null) {
+            const err = new Error('No function component found');
+            err.statusCode = 404; // HACK our convention for NotFound
+            throw err;
+        }
+        if (Object.keys(elements).some((key)=>key.startsWith('_'))) {
+            throw new Error('"_" prefix is reserved');
+        }
+        return elements;
+    };
+    const bundlerConfig = new Proxy({}, {
+        get (_target, encodedId) {
+            const [filePath, name] = encodedId.split('#');
+            const id = resolveClientEntry(filePath, config, rr.command);
+            rr?.moduleIdCallback?.(id);
+            return {
+                id,
+                chunks: [
+                    id
+                ],
+                name,
+                async: true
+            };
+        }
+    });
+    if (rr.method === 'POST') {
+        const rsfId = decodeURIComponent(rr.input);
+        let args = [];
+        const contentType = rr.headers['content-type'];
+        let body = '';
+        if (rr.stream) {
+            const decoder = new TextDecoder();
+            const reader = rr.stream.getReader();
+            let result;
+            do {
+                result = await reader.read();
+                if (result.value) {
+                    if (!(result.value instanceof Uint8Array)) {
+                        throw new Error('Unexepected buffer type');
+                    }
+                    body += decoder.decode(result.value);
+                }
+            }while (!result.done)
+        }
+        if (typeof contentType === 'string' && contentType.startsWith('multipart/form-data')) {
+            // XXX This doesn't support streaming unlike busboy
+            const formData = parseFormData(body, contentType);
+            args = await decodeReply(formData);
+        } else if (body) {
+            args = await decodeReply(body);
+        }
+        const [fileId, name] = rsfId.split('#');
+        const filePath = fileId.startsWith('/') ? fileId : rsfPrefix + fileId;
+        const fname = rr.command === 'dev' ? filePath : url.pathToFileURL(filePath).toString();
+        const mod = await loadServerFile(fname, rr.command);
+        let elements = Promise.resolve({});
+        const rerender = (input)=>{
+            elements = Promise.all([
+                elements,
+                render(input)
+            ]).then(([oldElements, newElements])=>({
+                    ...oldElements,
+                    ...newElements
+                }));
+        };
+        return runWithAsyncLocalStorage({
+            getContext: ()=>rr.context,
+            rerender
+        }, async ()=>{
+            const data = await (mod[name] || mod)(...args);
+            return renderToReadableStream({
+                ...await elements,
+                _value: data
+            }, bundlerConfig).pipeThrough(transformRsfId(rsfPrefix));
+        });
+    }
+    return runWithAsyncLocalStorage({
+        getContext: ()=>rr.context,
+        rerender: ()=>{
+            throw new Error('Cannot rerender');
+        }
+    }, async ()=>{
+        const elements = await render(rr.input);
+        return renderToReadableStream(elements, bundlerConfig).pipeThrough(transformRsfId(rsfPrefix));
+    });
+}
+async function getBuildConfigRSC(config) {
+    const entriesFile = getEntriesFile(config, 'build');
+    const { default: { getBuildConfig } } = await loadServerFile(entriesFile, 'build');
+    if (!getBuildConfig) {
+        console.warn("getBuildConfig is undefined. It's recommended for optimization and sometimes required.");
+        return {};
+    }
+    const unstable_collectClientModules = async (input)=>{
+        const idSet = new Set();
+        const readable = await renderRSC({
+            input,
+            method: 'GET',
+            headers: {},
+            config,
+            command: 'build',
+            context: null,
+            moduleIdCallback: (id)=>idSet.add(id)
+        });
+        await new Promise((resolve, reject)=>{
+            const writable = new WritableStream({
+                close () {
+                    resolve();
+                },
+                abort (reason) {
+                    reject(reason);
+                }
+            });
+            readable.pipeTo(writable);
+        });
+        return Array.from(idSet);
+    };
+    const output = await getBuildConfig(unstable_collectClientModules);
+    return output;
+}
diff --git a/dist/lib/middleware/ssr.d.ts b/dist/lib/middleware/ssr.d.ts
index 7294808b150da581bbecdd259a8a0ed7f8dbb5fa..70a1bd616f8cf189cfaba4af2a06440f31c8b1ca 100644
--- a/dist/lib/middleware/ssr.d.ts
+++ b/dist/lib/middleware/ssr.d.ts
@@ -1,2 +1,10 @@
 import type { Middleware } from './types.js';
+export declare const CLIENT_MODULE_MAP: {
+    react: string;
+    'rd-server': string;
+    'rsdw-client': string;
+    'waku-client': string;
+};
+export type CLIENT_MODULE_KEY = keyof typeof CLIENT_MODULE_MAP;
+export declare const CLIENT_PREFIX = "client/";
 export declare const ssr: Middleware;
diff --git a/dist/lib/middleware/types.d.ts b/dist/lib/middleware/types.d.ts
index edfd3e0ae71c9ecde5e4a6e46c0d52642b1ded87..c793a54921f5a33e17c3650e30dfc8c3ab2079f2 100644
--- a/dist/lib/middleware/types.d.ts
+++ b/dist/lib/middleware/types.d.ts
@@ -1,9 +1,6 @@
 import type { Config } from '../../config.js';
-import type { EntriesDev, EntriesPrd } from '../../server.js';
-export type ClonableModuleNode = {
-    url: string;
-    file: string;
-};
+import type { EntriesPrd } from '../../server.js';
+import type { renderRscWithWorker, getSsrConfigWithWorker } from '../renderers/dev-worker-api.js';
 export type HandlerReq = {
     body: ReadableStream;
     url: URL;
@@ -12,22 +9,21 @@ export type HandlerReq = {
 };
 export type HandlerRes = {
     body?: ReadableStream;
-    headers?: Record<string, string | string[]>;
+    headers?: Record<string, string>;
     status?: number;
 };
+export type RscContext = Record<string, unknown>;
 export type HandlerContext = {
     readonly req: HandlerReq;
     readonly res: HandlerRes;
-    readonly context: Record<string, unknown>;
-    unstable_devServer?: {
+    readonly context: RscContext;
+    devServer?: {
         rootDir: string;
-        resolveClientEntry: (id: string) => string;
-        loadServerModuleRsc: (idOrFileURL: string) => Promise<Record<string, any>>;
-        loadEntriesDev: (config: {
-            srcDir: string;
-        }) => Promise<EntriesDev>;
-        loadServerModuleMain: (idOrFileURL: string) => Promise<Record<string, any>>;
+        renderRscWithWorker: typeof renderRscWithWorker;
+        getSsrConfigWithWorker: typeof getSsrConfigWithWorker;
+        loadServerFile: (fileURL: string) => Promise<Record<string, any>>;
         transformIndexHtml: (pathname: string) => Promise<TransformStream<any, any>>;
+        willBeHandledLater: (pathname: string) => Promise<boolean>;
     };
 };
 export type Handler = (ctx: HandlerContext, next: () => Promise<void>) => Promise<void>;
diff --git a/dist/lib/old-wrappers/connect-dev.d.ts b/dist/lib/old-wrappers/connect-dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..02956fedc5b3a4d461360812655fdc15d5649171
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-dev.d.ts
@@ -0,0 +1,3 @@
+/// <reference types="node" resolution-mode="require"/>
+import { createHandler } from '../handlers/handler-dev.js';
+export declare function connectMiddleware(...args: Parameters<typeof createHandler>): (connectReq: import("http").IncomingMessage, connectRes: import("http").ServerResponse<import("http").IncomingMessage>, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/old-wrappers/connect-dev.js b/dist/lib/old-wrappers/connect-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..8b0b41af7dffd0bc11060b22ada74829225e920a
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-dev.js
@@ -0,0 +1,5 @@
+import { connectWrapper } from './connect-utils.js';
+import { createHandler } from '../handlers/handler-dev.js';
+export function connectMiddleware(...args) {
+    return connectWrapper(createHandler(...args));
+}
diff --git a/dist/lib/old-wrappers/connect-prd.d.ts b/dist/lib/old-wrappers/connect-prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c82b619bed61ebd8f69c064522503df921a2aa64
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-prd.d.ts
@@ -0,0 +1,3 @@
+/// <reference types="node" resolution-mode="require"/>
+import { createHandler } from '../handlers/handler-prd.js';
+export declare function connectMiddleware(...args: Parameters<typeof createHandler>): (connectReq: import("http").IncomingMessage, connectRes: import("http").ServerResponse<import("http").IncomingMessage>, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/old-wrappers/connect-prd.js b/dist/lib/old-wrappers/connect-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..36235c05fbf4111973bcc3ccd3972973c1ca9c99
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-prd.js
@@ -0,0 +1,5 @@
+import { connectWrapper } from './connect-utils.js';
+import { createHandler } from '../handlers/handler-prd.js';
+export function connectMiddleware(...args) {
+    return connectWrapper(createHandler(...args));
+}
diff --git a/dist/lib/old-wrappers/connect-utils.d.ts b/dist/lib/old-wrappers/connect-utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..992568e9a1e4a60012de0a3ce5f2b8d74267be3f
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-utils.d.ts
@@ -0,0 +1,8 @@
+/// <reference types="node" resolution-mode="require"/>
+import type { IncomingMessage, ServerResponse } from 'node:http';
+import type { BaseReq, BaseRes, Handler } from '../handlers/types.js';
+export declare const connectWrapper: (m: Handler<BaseReq & {
+    orig: IncomingMessage;
+}, BaseRes & {
+    orig: ServerResponse;
+}>) => (connectReq: IncomingMessage, connectRes: ServerResponse, next: (err?: unknown) => void) => Promise<void>;
diff --git a/dist/lib/old-wrappers/connect-utils.js b/dist/lib/old-wrappers/connect-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..bd3bdb204722671cbe60fe9889b5ab6add4ba49d
--- /dev/null
+++ b/dist/lib/old-wrappers/connect-utils.js
@@ -0,0 +1,19 @@
+export const connectWrapper = (m)=>{
+    return async (connectReq, connectRes, next)=>{
+        const { Readable, Writable } = await import('node:stream');
+        const req = {
+            stream: Readable.toWeb(connectReq),
+            method: connectReq.method || '',
+            url: new URL(connectReq.url || '', `http://${connectReq.headers.host}`),
+            contentType: connectReq.headers['content-type'],
+            orig: connectReq
+        };
+        const res = {
+            stream: Writable.toWeb(connectRes),
+            setStatus: (code)=>connectRes.statusCode = code,
+            setHeader: (name, value)=>connectRes.setHeader(name, value),
+            orig: connectRes
+        };
+        m(req, res, next);
+    };
+};
diff --git a/dist/lib/old-wrappers/hono-dev.d.ts b/dist/lib/old-wrappers/hono-dev.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..655cee33529beccee99d93cf9cf318adc967294f
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-dev.d.ts
@@ -0,0 +1,3 @@
+import type { Env, Input } from 'hono';
+import { createHandler } from '../handlers/handler-dev.js';
+export declare function honoMiddleware<E extends Env = never, P extends string = string, I extends Input = Record<string, never>>(...args: Parameters<typeof createHandler>): import("hono").MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/old-wrappers/hono-dev.js b/dist/lib/old-wrappers/hono-dev.js
new file mode 100644
index 0000000000000000000000000000000000000000..aea0280cd1ffe13fe4de87d578de09fdad5d18f2
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-dev.js
@@ -0,0 +1,5 @@
+import { honoWrapper } from './hono-utils.js';
+import { createHandler } from '../handlers/handler-dev.js';
+export function honoMiddleware(...args) {
+    return honoWrapper(createHandler(...args));
+}
diff --git a/dist/lib/old-wrappers/hono-prd.d.ts b/dist/lib/old-wrappers/hono-prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..82dfd4a0fd52527d57cfb8db76cca8c31bfb6bb4
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-prd.d.ts
@@ -0,0 +1,3 @@
+import type { Env, Input } from 'hono';
+import { createHandler } from '../handlers/handler-prd.js';
+export declare function honoMiddleware<E extends Env = never, P extends string = string, I extends Input = Record<string, never>>(...args: Parameters<typeof createHandler>): import("hono").MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/old-wrappers/hono-prd.js b/dist/lib/old-wrappers/hono-prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..e00a45a36d8619fc1c994b888d2f2d6c285d9d44
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-prd.js
@@ -0,0 +1,5 @@
+import { honoWrapper } from './hono-utils.js';
+import { createHandler } from '../handlers/handler-prd.js';
+export function honoMiddleware(...args) {
+    return honoWrapper(createHandler(...args));
+}
diff --git a/dist/lib/old-wrappers/hono-utils.d.ts b/dist/lib/old-wrappers/hono-utils.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..a69dc063a573c6f21622b08129e86db5e10b8b5d
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-utils.d.ts
@@ -0,0 +1,7 @@
+import type { MiddlewareHandler, Context, Env, Input } from 'hono';
+import type { BaseReq, BaseRes, Handler } from '../handlers/types.js';
+export declare const honoWrapper: <E extends Env, P extends string, I extends Input>(m: Handler<BaseReq & {
+    c: Context<E, P, I>;
+}, BaseRes & {
+    c: Context<E, P, I>;
+}>) => MiddlewareHandler<E, P, I>;
diff --git a/dist/lib/old-wrappers/hono-utils.js b/dist/lib/old-wrappers/hono-utils.js
new file mode 100644
index 0000000000000000000000000000000000000000..d97dfa2dbfc9229d9c455ddc94caf17bff0c7626
--- /dev/null
+++ b/dist/lib/old-wrappers/hono-utils.js
@@ -0,0 +1,60 @@
+const createEmptyReadableStream = ()=>new ReadableStream({
+        start (controller) {
+            controller.close();
+        }
+    });
+const createStreamPair = (callback)=>{
+    let controller;
+    const readable = new ReadableStream({
+        start (c) {
+            controller = c;
+        },
+        cancel () {
+            controller = undefined;
+        }
+    });
+    let hasData = false;
+    const writable = new WritableStream({
+        write (chunk) {
+            if (!controller) {
+                return;
+            }
+            controller.enqueue(chunk);
+            if (!hasData) {
+                hasData = true;
+                callback(readable);
+            }
+        },
+        close () {
+            if (!controller) {
+                return;
+            }
+            controller.close();
+            if (!hasData) {
+                callback(null);
+            }
+        }
+    });
+    return writable;
+};
+export const honoWrapper = (m)=>{
+    return (c, next)=>new Promise((resolve)=>{
+            const req = {
+                stream: c.req.raw.body || createEmptyReadableStream(),
+                method: c.req.method,
+                url: new URL(c.req.url),
+                contentType: c.req.header('content-type'),
+                c
+            };
+            const writable = createStreamPair((readable)=>{
+                resolve(c.body(readable));
+            });
+            const res = {
+                stream: writable,
+                setStatus: (code)=>c.status(code),
+                setHeader: (name, value)=>c.header(name, value),
+                c
+            };
+            m(req, res, ()=>next().then(resolve));
+        });
+};
diff --git a/dist/lib/plugins/vite-plugin-deploy-aws-lambda.d.ts b/dist/lib/plugins/vite-plugin-deploy-aws-lambda.d.ts
deleted file mode 100644
index b45730c18cf25b27bdb28fe94104bfd79b238bd3..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-aws-lambda.js b/dist/lib/plugins/vite-plugin-deploy-aws-lambda.js
index b2187a2e03e9eb944754d18bc952b8e3f71e933a..ad30a2d7ecec56ce79083a5898e750f525e6b15d 100644
--- a/dist/lib/plugins/vite-plugin-deploy-aws-lambda.js
+++ b/dist/lib/plugins/vite-plugin-deploy-aws-lambda.js
@@ -1,11 +1,8 @@
 import path from 'node:path';
 import { existsSync, writeFileSync } from 'node:fs';
 import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS, SRC_ENTRIES } from '../constants.js';
 import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
 import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
 const resolveFileName = (fname)=>{
diff --git a/dist/lib/plugins/vite-plugin-deploy-cloudflare.d.ts b/dist/lib/plugins/vite-plugin-deploy-cloudflare.d.ts
deleted file mode 100644
index 788073857b46e5c8584ea2c668279783fb71de7d..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-cloudflare.js b/dist/lib/plugins/vite-plugin-deploy-cloudflare.js
index 052ee8ec1c7c9617fc7acd1640026bea4f5b6c40..ea250a79a5ccbd169287bd1e7c7c1b68b9cfbd71 100644
--- a/dist/lib/plugins/vite-plugin-deploy-cloudflare.js
+++ b/dist/lib/plugins/vite-plugin-deploy-cloudflare.js
@@ -1,23 +1,48 @@
 import path from 'node:path';
-import { existsSync, mkdirSync, readdirSync, renameSync, rmSync, writeFileSync } from 'node:fs';
-import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
+import { appendFileSync, existsSync, mkdirSync, readdirSync, renameSync, rmSync, writeFileSync } from 'node:fs';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
-import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
-import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
-const resolveFileName = (fname)=>{
-    for (const ext of EXTENSIONS){
-        const resolvedName = fname.slice(0, -extname(fname).length) + ext;
-        if (existsSync(resolvedName)) {
-            return resolvedName;
-        }
+import { SRC_ENTRIES } from '../constants.js';
+import { DIST_ENTRIES_JS, DIST_PUBLIC } from '../builder/constants.js';
+const SERVE_JS = 'serve-cloudflare.js';
+const getServeJsContent = (srcEntriesFile)=>`
+import { runner, importHono } from 'waku/unstable_hono';
+
+const { Hono } = await importHono();
+let contextStorage;
+try {
+ ({ contextStorage } = await import('hono/context-storage'));
+} catch {}
+
+const loadEntries = () => import('${srcEntriesFile}');
+let serveWaku;
+
+const app = new Hono();
+if (contextStorage) {
+  app.use(contextStorage());
+}
+app.use('*', (c, next) => serveWaku(c, next));
+app.notFound(async (c) => {
+  const assetsFetcher = c.env.ASSETS;
+  const url = new URL(c.req.raw.url);
+  const errorHtmlUrl = url.origin + '/404.html';
+  const notFoundStaticAssetResponse = await assetsFetcher.fetch(
+    new URL(errorHtmlUrl),
+  );
+  if (notFoundStaticAssetResponse && notFoundStaticAssetResponse.status < 400) {
+    return c.body(notFoundStaticAssetResponse.body, 404);
+  }
+  return c.text('404 Not Found', 404);
+});
+
+export default {
+  async fetch(request, env, ctx) {
+    if (!serveWaku) {
+      serveWaku = runner({ cmd: 'start', loadEntries, env });
     }
-    return fname; // returning the default one
+    return app.fetch(request, env, ctx);
+  },
 };
-const srcServeFile = decodeFilePathFromAbsolute(joinPath(fileURLToFilePath(import.meta.url), '../../builder/serve-cloudflare.js'));
+`;
 const getFiles = (dir, files = [])=>{
     const entries = readdirSync(dir, {
         withFileTypes: true
@@ -38,6 +63,7 @@ const HEADERS_NAME = '_headers';
 export function deployCloudflarePlugin(opts) {
     const platformObject = unstable_getPlatformObject();
     let rootDir;
+    let entriesFile;
     return {
         name: 'deploy-cloudflare-plugin',
         config (viteConfig) {
@@ -45,19 +71,37 @@ export function deployCloudflarePlugin(opts) {
             if (unstable_phase !== 'buildServerBundle' || deploy !== 'cloudflare') {
                 return;
             }
-            // FIXME This seems too hacky (The use of viteConfig.root, '.', path.resolve and resolveFileName)
-            const entriesFile = normalizePath(resolveFileName(path.resolve(viteConfig.root || '.', opts.srcDir, SRC_ENTRIES + '.jsx')));
             const { input } = viteConfig.build?.rollupOptions ?? {};
             if (input && !(typeof input === 'string') && !(input instanceof Array)) {
-                input[DIST_SERVE_JS.replace(/\.js$/, '')] = srcServeFile;
+                input[SERVE_JS.replace(/\.js$/, '')] = `${opts.srcDir}/${SERVE_JS}`;
             }
-            viteConfig.define = {
-                ...viteConfig.define,
-                'import.meta.env.WAKU_ENTRIES_FILE': JSON.stringify(entriesFile)
-            };
         },
         configResolved (config) {
             rootDir = config.root;
+            entriesFile = `${rootDir}/${opts.srcDir}/${SRC_ENTRIES}`;
+            const { deploy, unstable_phase } = platformObject.buildOptions || {};
+            if (unstable_phase !== 'buildServerBundle' && unstable_phase !== 'buildSsrBundle' || deploy !== 'cloudflare') {
+                return;
+            }
+            config.ssr.target = 'webworker';
+            config.ssr.resolve ||= {};
+            config.ssr.resolve.conditions ||= [];
+            config.ssr.resolve.conditions.push('worker');
+            config.ssr.resolve.externalConditions ||= [];
+            config.ssr.resolve.externalConditions.push('worker');
+        },
+        resolveId (source) {
+            if (source === `${opts.srcDir}/${SERVE_JS}`) {
+                return source;
+            }
+        },
+        load (id) {
+            if (id === `${opts.srcDir}/${SERVE_JS}`) {
+                return getServeJsContent(entriesFile);
+            }
+            if (id === 'hono/context-storage') {
+                return '';
+            }
         },
         closeBundle () {
             const { deploy, unstable_phase } = platformObject.buildOptions || {};
@@ -78,7 +122,7 @@ export function deployCloudflarePlugin(opts) {
             const workerEntrypoint = path.join(outDir, WORKER_JS_NAME, 'index.js');
             if (!existsSync(workerEntrypoint)) {
                 writeFileSync(workerEntrypoint, `
-import server from './${DIST_SERVE_JS}'
+import server from './${SERVE_JS}'
 
 export default {
   ...server
@@ -128,12 +172,13 @@ export default {
                 recursive: true,
                 force: true
             });
+            appendFileSync(path.join(outDir, WORKER_JS_NAME, DIST_ENTRIES_JS), `export const buildData = ${JSON.stringify(platformObject.buildData)};`);
             const wranglerTomlFile = path.join(rootDir, 'wrangler.toml');
             if (!existsSync(wranglerTomlFile)) {
                 writeFileSync(wranglerTomlFile, `
 # See https://developers.cloudflare.com/pages/functions/wrangler-configuration/
 name = "waku-project"
-compatibility_date = "2024-04-03"
+compatibility_date = "2024-09-02"
 compatibility_flags = [ "nodejs_als" ]
 pages_build_output_dir = "./dist"
 `);
diff --git a/dist/lib/plugins/vite-plugin-deploy-deno.d.ts b/dist/lib/plugins/vite-plugin-deploy-deno.d.ts
deleted file mode 100644
index f2c719f7c0abdd42ba31503bc5f31eeec621ccc1..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-deno.js b/dist/lib/plugins/vite-plugin-deploy-deno.js
index bf45ee4a6e0d5c0fa404d401ca929e5d6ba31dcf..c1680c71aa26749f23ae3b863fd17ed1847ba222 100644
--- a/dist/lib/plugins/vite-plugin-deploy-deno.js
+++ b/dist/lib/plugins/vite-plugin-deploy-deno.js
@@ -1,25 +1,36 @@
-import path from 'node:path';
-import { existsSync } from 'node:fs';
-import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
-import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
-import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
-const resolveFileName = (fname)=>{
-    for (const ext of EXTENSIONS){
-        const resolvedName = fname.slice(0, -extname(fname).length) + ext;
-        if (existsSync(resolvedName)) {
-            return resolvedName;
-        }
-    }
-    return fname; // returning the default one
-};
-const srcServeFile = decodeFilePathFromAbsolute(joinPath(fileURLToFilePath(import.meta.url), '../../builder/serve-deno.js'));
+import { SRC_ENTRIES } from '../constants.js';
+import { DIST_PUBLIC } from '../builder/constants.js';
+const SERVE_JS = 'serve-deno.js';
+const getServeJsContent = (distDir, distPublic, srcEntriesFile)=>`
+import { Hono } from 'https://deno.land/x/hono/mod.ts';
+import { serveStatic } from 'https://deno.land/x/hono/middleware.ts';
+import { runner } from 'waku/unstable_hono';
+
+const distDir = '${distDir}';
+const publicDir = '${distPublic}';
+const loadEntries = () => import('${srcEntriesFile}');
+const env = Deno.env.toObject();
+
+const app = new Hono();
+// app.use(contextStorage()); // Hono v4.6 is not available on deno.land
+app.use('*', serveStatic({ root: distDir + '/' + publicDir }));
+app.use('*', runner({ cmd: 'start', loadEntries, env }));
+app.notFound(async (c) => {
+  const file = distDir + '/' + publicDir + '/404.html';
+  const info = await Deno.stat(file);
+  if (info.isFile) {
+    c.header('Content-Type', 'text/html; charset=utf-8');
+    return c.body(await Deno.readFile(file), 404);
+  }
+  return c.text('404 Not Found', 404);
+});
+
+Deno.serve(app.fetch);
+`;
 export function deployDenoPlugin(opts) {
     const platformObject = unstable_getPlatformObject();
+    let entriesFile;
     return {
         name: 'deploy-deno-plugin',
         config (viteConfig) {
@@ -27,18 +38,33 @@ export function deployDenoPlugin(opts) {
             if (unstable_phase !== 'buildServerBundle' || deploy !== 'deno') {
                 return;
             }
-            // FIXME This seems too hacky (The use of viteConfig.root, '.', path.resolve and resolveFileName)
-            const entriesFile = normalizePath(resolveFileName(path.resolve(viteConfig.root || '.', opts.srcDir, SRC_ENTRIES + '.jsx')));
             const { input } = viteConfig.build?.rollupOptions ?? {};
             if (input && !(typeof input === 'string') && !(input instanceof Array)) {
-                input[DIST_SERVE_JS.replace(/\.js$/, '')] = srcServeFile;
+                input[SERVE_JS.replace(/\.js$/, '')] = `${opts.srcDir}/${SERVE_JS}`;
+            }
+        },
+        configResolved (config) {
+            entriesFile = `${config.root}/${opts.srcDir}/${SRC_ENTRIES}`;
+            const { deploy, unstable_phase } = platformObject.buildOptions || {};
+            if (unstable_phase !== 'buildServerBundle' && unstable_phase !== 'buildSsrBundle' || deploy !== 'deno') {
+                return;
+            }
+            config.ssr.target = 'webworker';
+            config.ssr.resolve ||= {};
+            config.ssr.resolve.conditions ||= [];
+            config.ssr.resolve.conditions.push('worker');
+            config.ssr.resolve.externalConditions ||= [];
+            config.ssr.resolve.externalConditions.push('worker');
+        },
+        resolveId (source) {
+            if (source === `${opts.srcDir}/${SERVE_JS}`) {
+                return source;
+            }
+        },
+        load (id) {
+            if (id === `${opts.srcDir}/${SERVE_JS}`) {
+                return getServeJsContent(opts.distDir, DIST_PUBLIC, entriesFile);
             }
-            viteConfig.define = {
-                ...viteConfig.define,
-                'import.meta.env.WAKU_ENTRIES_FILE': JSON.stringify(entriesFile),
-                'import.meta.env.WAKU_CONFIG_DIST_DIR': JSON.stringify(opts.distDir),
-                'import.meta.env.WAKU_CONFIG_PUBLIC_DIR': JSON.stringify(DIST_PUBLIC)
-            };
         }
     };
 }
diff --git a/dist/lib/plugins/vite-plugin-deploy-netlify.d.ts b/dist/lib/plugins/vite-plugin-deploy-netlify.d.ts
deleted file mode 100644
index 50715d534e9bdbe025e2e4dcbc9dde48b7598d0a..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-netlify.js b/dist/lib/plugins/vite-plugin-deploy-netlify.js
index 4a0cecf0f8d88644c85c90fa5d385c3615620f25..fca02e8110a017c6666c3df762ea0b723eabf232 100644
--- a/dist/lib/plugins/vite-plugin-deploy-netlify.js
+++ b/dist/lib/plugins/vite-plugin-deploy-netlify.js
@@ -1,26 +1,39 @@
 import path from 'node:path';
 import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
-import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
-import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
-import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
-const resolveFileName = (fname)=>{
-    for (const ext of EXTENSIONS){
-        const resolvedName = fname.slice(0, -extname(fname).length) + ext;
-        if (existsSync(resolvedName)) {
-            return resolvedName;
-        }
-    }
-    return fname; // returning the default one
-};
-const srcServeFile = decodeFilePathFromAbsolute(joinPath(fileURLToFilePath(import.meta.url), '../../builder/serve-netlify.js'));
+import { SRC_ENTRIES } from '../constants.js';
+import { DIST_PUBLIC } from '../builder/constants.js';
+const SERVE_JS = 'serve-netlify.js';
+const getServeJsContent = (srcEntriesFile)=>`
+import { runner, importHono } from 'waku/unstable_hono';
+
+const { Hono } = await importHono();
+let contextStorage;
+try {
+ ({ contextStorage } = await import('hono/context-storage'));
+} catch {}
+
+const loadEntries = () => import('${srcEntriesFile}');
+
+const app = new Hono();
+if (contextStorage) {
+  app.use(contextStorage());
+}
+app.use('*', runner({ cmd: 'start', loadEntries, env: process.env }));
+app.notFound((c) => {
+  const notFoundHtml = globalThis.__WAKU_NOT_FOUND_HTML__;
+  if (typeof notFoundHtml === 'string') {
+    return c.html(notFoundHtml, 404);
+  }
+  return c.text('404 Not Found', 404);
+});
+
+export default async (req, context) => app.fetch(req, { context });
+`;
 export function deployNetlifyPlugin(opts) {
     const platformObject = unstable_getPlatformObject();
     let rootDir;
+    let entriesFile;
     return {
         name: 'deploy-netlify-plugin',
         config (viteConfig) {
@@ -28,19 +41,27 @@ export function deployNetlifyPlugin(opts) {
             if (unstable_phase !== 'buildServerBundle' || deploy !== 'netlify-functions' && deploy !== 'netlify-static') {
                 return;
             }
-            // FIXME This seems too hacky (The use of viteConfig.root, '.', path.resolve and resolveFileName)
-            const entriesFile = normalizePath(resolveFileName(path.resolve(viteConfig.root || '.', opts.srcDir, SRC_ENTRIES + '.jsx')));
             const { input } = viteConfig.build?.rollupOptions ?? {};
             if (input && !(typeof input === 'string') && !(input instanceof Array)) {
-                input[DIST_SERVE_JS.replace(/\.js$/, '')] = srcServeFile;
+                input[SERVE_JS.replace(/\.js$/, '')] = `${opts.srcDir}/${SERVE_JS}`;
             }
-            viteConfig.define = {
-                ...viteConfig.define,
-                'import.meta.env.WAKU_ENTRIES_FILE': JSON.stringify(entriesFile)
-            };
         },
         configResolved (config) {
             rootDir = config.root;
+            entriesFile = `${rootDir}/${opts.srcDir}/${SRC_ENTRIES}`;
+        },
+        resolveId (source) {
+            if (source === `${opts.srcDir}/${SERVE_JS}`) {
+                return source;
+            }
+        },
+        load (id) {
+            if (id === `${opts.srcDir}/${SERVE_JS}`) {
+                return getServeJsContent(entriesFile);
+            }
+            if (id === 'hono/context-storage') {
+                return '';
+            }
         },
         closeBundle () {
             const { deploy, unstable_phase } = platformObject.buildOptions || {};
@@ -56,7 +77,7 @@ export function deployNetlifyPlugin(opts) {
                 const notFoundHtml = existsSync(notFoundFile) ? readFileSync(notFoundFile, 'utf8') : null;
                 writeFileSync(path.join(functionsDir, 'serve.js'), `
 globalThis.__WAKU_NOT_FOUND_HTML__ = ${JSON.stringify(notFoundHtml)};
-export { default } from '../../${opts.distDir}/${DIST_SERVE_JS}';
+export { default } from '../../${opts.distDir}/${SERVE_JS}';
 export const config = {
   preferStatic: true,
   path: ['/', '/*'],
diff --git a/dist/lib/plugins/vite-plugin-deploy-partykit.d.ts b/dist/lib/plugins/vite-plugin-deploy-partykit.d.ts
deleted file mode 100644
index 2dca6832ee3210d8ba59dd0ebe0067362125badd..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-partykit.js b/dist/lib/plugins/vite-plugin-deploy-partykit.js
index 5c8c9e308a39041c53f33c74123d60faf98f3635..7a24d92d0817d34b63d878a2b6322c9f44cacf42 100644
--- a/dist/lib/plugins/vite-plugin-deploy-partykit.js
+++ b/dist/lib/plugins/vite-plugin-deploy-partykit.js
@@ -1,11 +1,8 @@
 import path from 'node:path';
 import { existsSync, writeFileSync } from 'node:fs';
 import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS, SRC_ENTRIES } from '../constants.js';
 import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
 import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
 const resolveFileName = (fname)=>{
@@ -41,6 +38,16 @@ export function deployPartykitPlugin(opts) {
         },
         configResolved (config) {
             rootDir = config.root;
+            const { deploy, unstable_phase } = platformObject.buildOptions || {};
+            if (unstable_phase !== 'buildServerBundle' && unstable_phase !== 'buildSsrBundle' || deploy !== 'cloudflare') {
+                return;
+            }
+            config.ssr.target = 'webworker';
+            config.ssr.resolve ||= {};
+            config.ssr.resolve.conditions ||= [];
+            config.ssr.resolve.conditions.push('worker');
+            config.ssr.resolve.externalConditions ||= [];
+            config.ssr.resolve.externalConditions.push('worker');
         },
         closeBundle () {
             const { deploy, unstable_phase } = platformObject.buildOptions || {};
diff --git a/dist/lib/plugins/vite-plugin-deploy-vercel.d.ts b/dist/lib/plugins/vite-plugin-deploy-vercel.d.ts
deleted file mode 100644
index e6252767dec8db5c029613645475543788f2ccaa..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-deploy-vercel.js b/dist/lib/plugins/vite-plugin-deploy-vercel.js
index 37bda7b178cb663a40d926ccdf35d1391e65405c..5b8621c86dcd4e761480b84bcfadf0204a6d2698 100644
--- a/dist/lib/plugins/vite-plugin-deploy-vercel.js
+++ b/dist/lib/plugins/vite-plugin-deploy-vercel.js
@@ -1,26 +1,45 @@
 import path from 'node:path';
 import { cpSync, existsSync, mkdirSync, writeFileSync } from 'node:fs';
-import { normalizePath } from 'vite';
-// HACK: Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
 import { unstable_getPlatformObject } from '../../server.js';
-import { EXTENSIONS } from '../config.js';
-import { decodeFilePathFromAbsolute, extname, fileURLToFilePath, joinPath } from '../utils/path.js';
-import { DIST_SERVE_JS, DIST_PUBLIC } from '../builder/constants.js';
-const resolveFileName = (fname)=>{
-    for (const ext of EXTENSIONS){
-        const resolvedName = fname.slice(0, -extname(fname).length) + ext;
-        if (existsSync(resolvedName)) {
-            return resolvedName;
-        }
-    }
-    return fname; // returning the default one
-};
-const srcServeFile = decodeFilePathFromAbsolute(joinPath(fileURLToFilePath(import.meta.url), '../../builder/serve-vercel.js'));
+import { SRC_ENTRIES } from '../constants.js';
+import { DIST_PUBLIC } from '../builder/constants.js';
+const SERVE_JS = 'serve-vercel.js';
+const getServeJsContent = (distDir, distPublic, srcEntriesFile)=>`
+import path from 'node:path';
+import { existsSync, readFileSync } from 'node:fs';
+import { runner, importHono, importHonoNodeServer } from 'waku/unstable_hono';
+
+const { Hono } = await importHono();
+const { getRequestListener } = await importHonoNodeServer();
+let contextStorage;
+try {
+ ({ contextStorage } = await import('hono/context-storage'));
+} catch {}
+
+const distDir = '${distDir}';
+const publicDir = '${distPublic}';
+const loadEntries = () => import('${srcEntriesFile}');
+
+const app = new Hono();
+if (contextStorage) {
+  app.use(contextStorage());
+}
+app.use('*', runner({ cmd: 'start', loadEntries, env: process.env }));
+app.notFound((c) => {
+  // FIXME better implementation using node stream?
+  const file = path.join(distDir, publicDir, '404.html');
+  if (existsSync(file)) {
+    return c.html(readFileSync(file, 'utf8'), 404);
+  }
+  return c.text('404 Not Found', 404);
+});
+
+export default getRequestListener(app.fetch);
+`;
 export function deployVercelPlugin(opts) {
     const platformObject = unstable_getPlatformObject();
     let rootDir;
+    let entriesFile;
     return {
         name: 'deploy-vercel-plugin',
         config (viteConfig) {
@@ -28,21 +47,27 @@ export function deployVercelPlugin(opts) {
             if (unstable_phase !== 'buildServerBundle' || deploy !== 'vercel-serverless' && deploy !== 'vercel-static') {
                 return;
             }
-            // FIXME This seems too hacky (The use of viteConfig.root, '.', path.resolve and resolveFileName)
-            const entriesFile = normalizePath(resolveFileName(path.resolve(viteConfig.root || '.', opts.srcDir, SRC_ENTRIES + '.jsx')));
             const { input } = viteConfig.build?.rollupOptions ?? {};
             if (input && !(typeof input === 'string') && !(input instanceof Array)) {
-                input[DIST_SERVE_JS.replace(/\.js$/, '')] = srcServeFile;
+                input[SERVE_JS.replace(/\.js$/, '')] = `${opts.srcDir}/${SERVE_JS}`;
             }
-            viteConfig.define = {
-                ...viteConfig.define,
-                'import.meta.env.WAKU_ENTRIES_FILE': JSON.stringify(entriesFile),
-                'import.meta.env.WAKU_CONFIG_DIST_DIR': JSON.stringify(opts.distDir),
-                'import.meta.env.WAKU_CONFIG_PUBLIC_DIR': JSON.stringify(DIST_PUBLIC)
-            };
         },
         configResolved (config) {
             rootDir = config.root;
+            entriesFile = `${rootDir}/${opts.srcDir}/${SRC_ENTRIES}`;
+        },
+        resolveId (source) {
+            if (source === `${opts.srcDir}/${SERVE_JS}`) {
+                return source;
+            }
+        },
+        load (id) {
+            if (id === `${opts.srcDir}/${SERVE_JS}`) {
+                return getServeJsContent(opts.distDir, DIST_PUBLIC, entriesFile);
+            }
+            if (id === 'hono/context-storage') {
+                return '';
+            }
         },
         closeBundle () {
             const { deploy, unstable_phase } = platformObject.buildOptions || {};
@@ -71,7 +96,7 @@ export function deployVercelPlugin(opts) {
                 }
                 const vcConfigJson = {
                     runtime: 'nodejs20.x',
-                    handler: `${opts.distDir}/${DIST_SERVE_JS}`,
+                    handler: `${opts.distDir}/${SERVE_JS}`,
                     launcherType: 'Nodejs'
                 };
                 writeFileSync(path.join(serverlessDir, '.vc-config.json'), JSON.stringify(vcConfigJson, null, 2));
diff --git a/dist/lib/plugins/vite-plugin-dev-commonjs.d.ts b/dist/lib/plugins/vite-plugin-dev-commonjs.d.ts
deleted file mode 100644
index cc5e8173da31cdad2bcedd57efc93a625c4acff0..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-nonjs-resolve.js b/dist/lib/plugins/vite-plugin-nonjs-resolve.js
index 7153ec1087c9fd97e27131a19dd7673cdc9e0144..3e716fcb8bd7bcb031160e2b610f401c1de0bd07 100644
--- a/dist/lib/plugins/vite-plugin-nonjs-resolve.js
+++ b/dist/lib/plugins/vite-plugin-nonjs-resolve.js
@@ -1,4 +1,4 @@
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS } from '../constants.js';
 import { extname } from '../utils/path.js';
 export function nonjsResolvePlugin() {
     return {
diff --git a/dist/lib/plugins/vite-plugin-rsc-analyze.d.ts b/dist/lib/plugins/vite-plugin-rsc-analyze.d.ts
index b1c59498ff3087538d511b8a3e7c423af611cf46..30f8251bae32fd3b1bb18949851b992a8a35599e 100644
--- a/dist/lib/plugins/vite-plugin-rsc-analyze.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-analyze.d.ts
@@ -1,10 +1,2 @@
 import type { Plugin } from 'vite';
-export declare function rscAnalyzePlugin(opts: {
-    isClient: true;
-    serverFileSet: Set<string>;
-} | {
-    isClient: false;
-    clientFileSet: Set<string>;
-    serverFileSet: Set<string>;
-    fileHashMap: Map<string, string>;
-}): Plugin;
+export declare function rscAnalyzePlugin(clientFileSet: Set<string>, serverFileSet: Set<string>): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-analyze.js b/dist/lib/plugins/vite-plugin-rsc-analyze.js
index fbbb2085df2a7397d0847d95508699b915c9eab4..782274fe367a91101dea7a382b4a7a8369eca420 100644
--- a/dist/lib/plugins/vite-plugin-rsc-analyze.js
+++ b/dist/lib/plugins/vite-plugin-rsc-analyze.js
@@ -1,5 +1,5 @@
 import * as swc from '@swc/core';
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS } from '../constants.js';
 import { extname } from '../utils/path.js';
 import { parseOpts } from '../utils/swc.js';
 // HACK: Is it common to depend on another plugin like this?
diff --git a/dist/lib/plugins/vite-plugin-rsc-delegate.js b/dist/lib/plugins/vite-plugin-rsc-delegate.js
index 4321c35b5ee94325e38e67991714e60e4eb4d3fd..908cea2b78c4911b20eac45fc369933edafea377 100644
--- a/dist/lib/plugins/vite-plugin-rsc-delegate.js
+++ b/dist/lib/plugins/vite-plugin-rsc-delegate.js
@@ -1,5 +1,5 @@
 import * as swc from '@swc/core';
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS } from '../constants.js';
 import { extname } from '../utils/path.js';
 import { parseOpts } from '../utils/swc.js';
 const isClientEntry = (id, code)=>{
diff --git a/dist/lib/plugins/vite-plugin-rsc-entries.d.ts b/dist/lib/plugins/vite-plugin-rsc-entries.d.ts
index f919fcac565b43ac418337bd12a44007c05d227f..83a082d9a40e58ee52e8d35fd070a36b7739388c 100644
--- a/dist/lib/plugins/vite-plugin-rsc-entries.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-entries.d.ts
@@ -1,6 +1,5 @@
 import type { Plugin } from 'vite';
 export declare function rscEntriesPlugin(opts: {
-    srcDir: string;
-    ssrDir: string;
+    entriesFile: string;
     moduleMap: Record<string, string>;
 }): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-entries.js b/dist/lib/plugins/vite-plugin-rsc-entries.js
index 8ab6da631861a17e2df9a4e7ee11414a830c97d6..9ff5ac69f9d020c024c19ac7147eb4d6f84bf5da 100644
--- a/dist/lib/plugins/vite-plugin-rsc-entries.js
+++ b/dist/lib/plugins/vite-plugin-rsc-entries.js
@@ -1,9 +1,7 @@
 import { existsSync } from 'node:fs';
 import path from 'node:path';
 import { normalizePath } from 'vite';
-// HACK Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
+import { SRC_ENTRIES } from '../constants.js';
 import { extname, joinPath } from '../utils/path.js';
 const stripExt = (fname)=>{
     const ext = extname(fname);
diff --git a/dist/lib/plugins/vite-plugin-rsc-env.d.ts b/dist/lib/plugins/vite-plugin-rsc-env.d.ts
index da856430ee271c054926699b9147fb9df06bc64f..29cec13864895a2475e728397303259ab4470cf5 100644
--- a/dist/lib/plugins/vite-plugin-rsc-env.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-env.d.ts
@@ -1,7 +1,5 @@
 import type { Plugin } from 'vite';
-export declare function rscEnvPlugin({ isDev, env, config, }: {
-    isDev: boolean;
-    env: Record<string, string>;
+export declare function rscEnvPlugin({ config, }: {
     config?: {
         basePath: string;
         rscPath: string;
diff --git a/dist/lib/plugins/vite-plugin-rsc-index.d.ts b/dist/lib/plugins/vite-plugin-rsc-index.d.ts
index 11f274dd56db8aba118d4cde254da7faa8328629..e26ad61b081657a3777b8d1e92771c18078d5dbd 100644
--- a/dist/lib/plugins/vite-plugin-rsc-index.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-index.d.ts
@@ -1,7 +1,9 @@
 import type { Plugin } from 'vite';
-export declare const DEFAULT_HTML_HEAD: string;
-export declare function rscIndexPlugin(opts: {
+export declare function rscIndexPlugin(config: {
     basePath: string;
     srcDir: string;
+    mainJs: string;
+    htmlHead: string;
+    indexHtml: string;
     cssAssets?: string[];
 }): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-index.js b/dist/lib/plugins/vite-plugin-rsc-index.js
index 527dffd3d684f0f1bcb29dcd937d696cdc82eaf4..fb4999a559433781495391b06bb4d0f6a90382b2 100644
--- a/dist/lib/plugins/vite-plugin-rsc-index.js
+++ b/dist/lib/plugins/vite-plugin-rsc-index.js
@@ -1,6 +1,4 @@
-// HACK Depending on a different plugin isn't ideal.
-// Maybe we could put in vite config object?
-import { SRC_MAIN } from './vite-plugin-rsc-managed.js';
+import { SRC_MAIN } from '../constants.js';
 export const DEFAULT_HTML_HEAD = `
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1" />
diff --git a/dist/lib/plugins/vite-plugin-rsc-managed.d.ts b/dist/lib/plugins/vite-plugin-rsc-managed.d.ts
deleted file mode 100644
index f4a249a0d7e89cc147bda687b11a22e034cf7da4..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-rsc-managed.js b/dist/lib/plugins/vite-plugin-rsc-managed.js
index 4faf2a335109748b6bd070676399d26f6f627fdd..489d31272c0774b25d7365e9874d3233565a85c8 100644
--- a/dist/lib/plugins/vite-plugin-rsc-managed.js
+++ b/dist/lib/plugins/vite-plugin-rsc-managed.js
@@ -1,7 +1,5 @@
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS, SRC_MAIN, SRC_ENTRIES } from '../constants.js';
 import { extname, joinPath } from '../utils/path.js';
-export const SRC_MAIN = 'main';
-export const SRC_ENTRIES = 'entries';
 const stripExt = (fname)=>{
     const ext = extname(fname);
     return ext ? fname.slice(0, -ext.length) : fname;
diff --git a/dist/lib/plugins/vite-plugin-rsc-private.d.ts b/dist/lib/plugins/vite-plugin-rsc-private.d.ts
index f0c464af703b50b99d918f2af58a2a64fe7e33a7..c24b4032a93b6a636ee3b97d82d24f6f0302e965 100644
--- a/dist/lib/plugins/vite-plugin-rsc-private.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-private.d.ts
@@ -1,6 +1,4 @@
 import type { Plugin } from 'vite';
-import type { HotUpdatePayload } from './vite-plugin-rsc-hmr.js';
-export declare function rscPrivatePlugin({ privateDir, hotUpdateCallback, }: {
+export declare function rscPrivatePlugin({ privateDir, }: {
     privateDir: string;
-    hotUpdateCallback?: (payload: HotUpdatePayload) => void;
 }): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-reload.d.ts b/dist/lib/plugins/vite-plugin-rsc-reload.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e8fb1b03115c5f36f17572e48ddb870c9cfec34d
--- /dev/null
+++ b/dist/lib/plugins/vite-plugin-rsc-reload.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscReloadPlugin(moduleImports: Set<string>, fn: (type: 'full-reload') => void): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-reload.js b/dist/lib/plugins/vite-plugin-rsc-reload.js
new file mode 100644
index 0000000000000000000000000000000000000000..e1ce0465749f44a6e617a62017db9ac40b158985
--- /dev/null
+++ b/dist/lib/plugins/vite-plugin-rsc-reload.js
@@ -0,0 +1,43 @@
+import path from 'node:path';
+import * as swc from '@swc/core';
+export function rscReloadPlugin(moduleImports, fn) {
+    let enabled = false;
+    const isClientEntry = (id, code)=>{
+        const ext = path.extname(id);
+        if ([
+            '.ts',
+            '.tsx',
+            '.js',
+            '.jsx'
+        ].includes(ext)) {
+            const mod = swc.parseSync(code, {
+                syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                tsx: ext === '.tsx'
+            });
+            for (const item of mod.body){
+                if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral' && item.expression.value === 'use client') {
+                    return true;
+                }
+            }
+        }
+        return false;
+    };
+    return {
+        name: 'rsc-reload-plugin',
+        configResolved (config) {
+            if (config.mode === 'development') {
+                enabled = true;
+            }
+        },
+        async handleHotUpdate (ctx) {
+            if (!enabled) {
+                return [];
+            }
+            if (ctx.modules.length && !isClientEntry(ctx.file, await ctx.read()) && !moduleImports.has(ctx.file)) {
+                fn('full-reload');
+            } else {
+                return [];
+            }
+        }
+    };
+}
diff --git a/dist/lib/plugins/vite-plugin-rsc-rsdw.d.ts b/dist/lib/plugins/vite-plugin-rsc-rsdw.d.ts
deleted file mode 100644
index 66ffc81cb4410c5bdc3354105a6c0507d31af57a..0000000000000000000000000000000000000000
diff --git a/dist/lib/plugins/vite-plugin-rsc-serve.d.ts b/dist/lib/plugins/vite-plugin-rsc-serve.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9b1cf904481dffc28706cef37660d62b22e105d5
--- /dev/null
+++ b/dist/lib/plugins/vite-plugin-rsc-serve.d.ts
@@ -0,0 +1,10 @@
+import type { Plugin } from 'vite';
+export declare function rscServePlugin(opts: {
+    serveJs: string;
+    distDir: string;
+    publicDir: string;
+    indexHtml: string;
+    entriesFile: string;
+    srcServeFile: string;
+    serve: 'vercel' | 'netlify' | 'cloudflare' | 'partykit' | 'deno' | 'aws-lambda';
+}): Plugin;
diff --git a/dist/lib/plugins/vite-plugin-rsc-serve.js b/dist/lib/plugins/vite-plugin-rsc-serve.js
new file mode 100644
index 0000000000000000000000000000000000000000..271fcc3ed6742aeb13a3b832c073156d757b98b6
--- /dev/null
+++ b/dist/lib/plugins/vite-plugin-rsc-serve.js
@@ -0,0 +1,49 @@
+import { existsSync } from 'node:fs';
+import path from 'node:path';
+import { normalizePath } from 'vite';
+// HACK: Depending on a different plugin isn't ideal.
+// Maybe we could put in vite config object?
+import { SRC_ENTRIES } from './vite-plugin-rsc-managed.js';
+import { EXTENSIONS } from '../config.js';
+import { extname } from '../utils/path.js';
+const resolveFileName = (fname)=>{
+    for (const ext of EXTENSIONS){
+        const resolvedName = fname.slice(0, -extname(fname).length) + ext;
+        if (existsSync(resolvedName)) {
+            return resolvedName;
+        }
+    }
+    return fname; // returning the default one
+};
+export function rscServePlugin(opts) {
+    return {
+        name: 'rsc-serve-plugin',
+        config (viteConfig) {
+            // FIXME This seems too hacky (The use of viteConfig.root, '.', path.resolve and resolveFileName)
+            const entriesFile = normalizePath(resolveFileName(path.resolve(viteConfig.root || '.', opts.srcDir, SRC_ENTRIES + '.jsx')));
+            const { input } = viteConfig.build?.rollupOptions ?? {};
+            if (input && !(typeof input === 'string') && !(input instanceof Array)) {
+                input[opts.distServeJs.replace(/\.js$/, '')] = opts.srcServeFile;
+            }
+            viteConfig.define = {
+                ...viteConfig.define,
+                'import.meta.env.WAKU_ENTRIES_FILE': JSON.stringify(entriesFile),
+                'import.meta.env.WAKU_CONFIG_DIST_DIR': JSON.stringify(opts.distDir),
+                'import.meta.env.WAKU_CONFIG_PUBLIC_DIR': JSON.stringify(opts.distPublic)
+            };
+            if (opts.serve === 'cloudflare' || opts.serve === 'partykit') {
+                viteConfig.build ||= {};
+                viteConfig.build.rollupOptions ||= {};
+                viteConfig.build.rollupOptions.external ||= [];
+                if (Array.isArray(viteConfig.build.rollupOptions.external)) {
+                    viteConfig.build.rollupOptions.external.push('hono');
+                    if (opts.serve === 'cloudflare') {
+                        viteConfig.build.rollupOptions.external.push('hono/cloudflare-workers', '__STATIC_CONTENT_MANIFEST');
+                    }
+                } else {
+                    throw new Error('Unsupported: build.rollupOptions.external is not an array');
+                }
+            }
+        }
+    };
+}
diff --git a/dist/lib/plugins/vite-plugin-rsc-transform.d.ts b/dist/lib/plugins/vite-plugin-rsc-transform.d.ts
index c76b3b852e2a7219d4efddf9a6faf047cb71fbe0..9dd50e5d4e78fd1100c6ce93dec285574c95aa01 100644
--- a/dist/lib/plugins/vite-plugin-rsc-transform.d.ts
+++ b/dist/lib/plugins/vite-plugin-rsc-transform.d.ts
@@ -1,16 +1,7 @@
 import type { Plugin } from 'vite';
 export declare function rscTransformPlugin(opts: {
-    isClient: true;
     isBuild: false;
 } | {
-    isClient: true;
-    isBuild: true;
-    serverEntryFiles: Record<string, string>;
-} | {
-    isClient: false;
-    isBuild: false;
-} | {
-    isClient: false;
     isBuild: true;
     clientEntryFiles: Record<string, string>;
     serverEntryFiles: Record<string, string>;
diff --git a/dist/lib/plugins/vite-plugin-rsc-transform.js b/dist/lib/plugins/vite-plugin-rsc-transform.js
index c55e7daa644aec27a53ffa0a014148e5e9908ee4..760a348e5ecf15dccb278b7e8a769904f2b1885d 100644
--- a/dist/lib/plugins/vite-plugin-rsc-transform.js
+++ b/dist/lib/plugins/vite-plugin-rsc-transform.js
@@ -1,5 +1,5 @@
 import * as swc from '@swc/core';
-import { EXTENSIONS } from '../config.js';
+import { EXTENSIONS } from '../constants.js';
 import { extname } from '../utils/path.js';
 import { parseOpts } from '../utils/swc.js';
 const collectExportNames = (mod)=>{
diff --git a/dist/lib/renderers/dev-worker-api.d.ts b/dist/lib/renderers/dev-worker-api.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6dd60f0a42b19255db27d260beb025e5542d155d
--- /dev/null
+++ b/dist/lib/renderers/dev-worker-api.d.ts
@@ -0,0 +1,56 @@
+import type { ResolvedConfig } from '../config.js';
+import type { HotUpdatePayload } from '../plugins/vite-plugin-rsc-hmr.js';
+import type { RenderRscArgs, GetSsrConfigArgs } from './rsc-renderer.js';
+export type BuildOutput = {
+    rscFiles: string[];
+    htmlFiles: string[];
+};
+export type MessageReq = ({
+    id: number;
+    type: 'render';
+    searchParamsString: string;
+    hasModuleIdCallback: boolean;
+} & Omit<RenderRscArgs, 'searchParams' | 'moduleIdCallback' | 'config'> & {
+    config: Omit<ResolvedConfig, 'middleware'>;
+}) | {
+    id: number;
+    type: 'getSsrConfig';
+    config: Omit<ResolvedConfig, 'middleware'>;
+    pathname: string;
+    searchParamsString: string;
+};
+export type MessageRes = {
+    type: 'hot-update';
+    payload: HotUpdatePayload;
+} | {
+    id: number;
+    type: 'start';
+    context: Record<string, unknown> | undefined;
+    stream: ReadableStream;
+} | {
+    id: number;
+    type: 'err';
+    err: unknown;
+    statusCode?: number;
+} | {
+    id: number;
+    type: 'moduleId';
+    moduleId: string;
+} | {
+    id: number;
+    type: 'ssrConfig';
+    input: string;
+    searchParamsString?: string | undefined;
+    body: ReadableStream;
+} | {
+    id: number;
+    type: 'noSsrConfig';
+};
+export declare function initializeWorker(config: ResolvedConfig): void;
+export declare function registerHotUpdateCallback(fn: (payload: HotUpdatePayload) => void): void;
+export declare function renderRscWithWorker(args: RenderRscArgs): Promise<ReadableStream>;
+export declare function getSsrConfigWithWorker(args: GetSsrConfigArgs): Promise<{
+    input: string;
+    searchParams?: URLSearchParams;
+    body: ReadableStream;
+} | null>;
diff --git a/dist/lib/renderers/dev-worker-api.js b/dist/lib/renderers/dev-worker-api.js
new file mode 100644
index 0000000000000000000000000000000000000000..afc78a1db2c83112d5c60c1b59f2cc5db5a1364d
--- /dev/null
+++ b/dist/lib/renderers/dev-worker-api.js
@@ -0,0 +1,153 @@
+// HACK depending on these constants is not ideal
+import { SRC_ENTRIES } from '../plugins/vite-plugin-rsc-managed.js';
+const messageCallbacks = new Map();
+let workerPromise;
+export function initializeWorker(config) {
+    if (workerPromise) {
+        throw new Error('Worker already initialized');
+    }
+    workerPromise = new Promise((resolve, reject)=>{
+        Promise.all([
+            import('node:worker_threads').catch((e)=>{
+                throw e;
+            }),
+            import('node:module').catch((e)=>{
+                throw e;
+            })
+        ]).then(([{ Worker, setEnvironmentData }, { default: module }])=>{
+            const HAS_MODULE_REGISTER = typeof module.register === 'function';
+            setEnvironmentData('__WAKU_PRIVATE_ENV__', globalThis.__WAKU_PRIVATE_ENV__);
+            setEnvironmentData('CONFIG_BASE_PATH', config.basePath);
+            setEnvironmentData('CONFIG_SRC_DIR', config.srcDir);
+            setEnvironmentData('CONFIG_ENTRIES', SRC_ENTRIES);
+            setEnvironmentData('CONFIG_PRIVATE_DIR', config.privateDir);
+            const worker = new Worker(new URL('dev-worker-impl.js', import.meta.url), {
+                execArgv: [
+                    ...HAS_MODULE_REGISTER ? [] : [
+                        '--experimental-loader',
+                        'waku/node-loader'
+                    ],
+                    '--conditions',
+                    'react-server',
+                    'workerd'
+                ]
+            });
+            worker.on('message', (mesg)=>{
+                if ('id' in mesg) {
+                    messageCallbacks.get(mesg.id)?.(mesg);
+                }
+            });
+            resolve(worker);
+        }).catch(reject);
+    });
+}
+const getWorker = ()=>{
+    if (!workerPromise) {
+        throw new Error('Worker not initialized');
+    }
+    return workerPromise;
+};
+export function registerHotUpdateCallback(fn) {
+    getWorker().then((worker)=>{
+        const listener = (mesg)=>{
+            if (mesg.type === 'hot-update') {
+                fn(mesg.payload);
+            }
+        };
+        worker.on('message', listener);
+    }).catch((e)=>{
+        console.error('Failed to register hot update callback', e);
+    });
+}
+let nextId = 1;
+export async function renderRscWithWorker(args, opts) {
+    const worker = await getWorker();
+    const id = nextId++;
+    let started = false;
+    return new Promise((resolve, reject)=>{
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'start') {
+                if (!started) {
+                    started = true;
+                    const bridge = new TransformStream({
+                        flush () {
+                            messageCallbacks.delete(id);
+                        }
+                    });
+                    Object.entries(mesg.context || {}).forEach(([key, value])=>{
+                        if (args.context) {
+                            args.context[key] = value;
+                        }
+                    });
+                    resolve(mesg.stream.pipeThrough(bridge));
+                } else {
+                    throw new Error('already started');
+                }
+            } else if (mesg.type === 'moduleId') {
+                args.moduleIdCallback?.(mesg.moduleId);
+            } else if (mesg.type === 'err') {
+                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                if (!started) {
+                    reject(err);
+                }
+                messageCallbacks.delete(id);
+            }
+        });
+        const mesg = {
+            id,
+            type: 'render',
+            config: args.config,
+            input: args.input,
+            searchParamsString: args.searchParams.toString(),
+            initialModules: opts.initialModules,
+            method: args.method,
+            context: args.context,
+            body: args.body,
+            contentType: args.contentType,
+            hasModuleIdCallback: !!args.moduleIdCallback
+        };
+        worker.postMessage(mesg, args.body ? [
+            args.body
+        ] : undefined);
+    });
+}
+export async function getSsrConfigWithWorker(args, opts) {
+    const worker = await getWorker();
+    const id = nextId++;
+    return new Promise((resolve, reject)=>{
+        messageCallbacks.set(id, (mesg)=>{
+            if (mesg.type === 'ssrConfig') {
+                resolve({
+                    input: mesg.input,
+                    ...mesg.searchParamsString ? {
+                        searchParams: new URLSearchParams(mesg.searchParamsString)
+                    } : {},
+                    body: mesg.body
+                });
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'noSsrConfig') {
+                resolve(null);
+                messageCallbacks.delete(id);
+            } else if (mesg.type === 'err') {
+                const err = typeof mesg.err === 'string' ? new Error(mesg.err) : mesg.err;
+                if (mesg.statusCode) {
+                    err.statusCode = mesg.statusCode;
+                }
+                reject(err);
+                messageCallbacks.delete(id);
+            }
+        });
+        const mesg = {
+            id,
+            type: 'getSsrConfig',
+            config: args.config,
+            pathname: args.pathname,
+            initialModules: opts.initialModules,
+            searchParamsString: args.searchParams.toString()
+        };
+        worker.postMessage(mesg);
+    });
+}
diff --git a/dist/lib/renderers/dev-worker-impl.d.ts b/dist/lib/renderers/dev-worker-impl.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cb0ff5c3b541f646105198ee23ac0fc3d805023e
--- /dev/null
+++ b/dist/lib/renderers/dev-worker-impl.d.ts
@@ -0,0 +1 @@
+export {};
diff --git a/dist/lib/renderers/dev-worker-impl.js b/dist/lib/renderers/dev-worker-impl.js
new file mode 100644
index 0000000000000000000000000000000000000000..097bf47e8f861f3deb4140625c766981b310c9ea
--- /dev/null
+++ b/dist/lib/renderers/dev-worker-impl.js
@@ -0,0 +1,230 @@
+// This file can depend on Node.js
+import { pathToFileURL } from 'node:url';
+import { parentPort, getEnvironmentData } from 'node:worker_threads';
+import { Server } from 'node:http';
+import { AsyncLocalStorage } from 'node:async_hooks';
+import { createServer as createViteServer } from 'vite';
+import viteReact from '@vitejs/plugin-react';
+import { joinPath, fileURLToFilePath, encodeFilePathToAbsolute, decodeFilePathFromAbsolute } from '../utils/path.js';
+import { deepFreeze, hasStatusCode } from './utils.js';
+import { renderRsc, getSsrConfig } from './rsc-renderer.js';
+import { nonjsResolvePlugin } from '../plugins/vite-plugin-nonjs-resolve.js';
+import { rscTransformPlugin } from '../plugins/vite-plugin-rsc-transform.js';
+import { rscEnvPlugin } from '../plugins/vite-plugin-rsc-env.js';
+import { rscPrivatePlugin } from '../plugins/vite-plugin-rsc-private.js';
+import { rscManagedPlugin } from '../plugins/vite-plugin-rsc-managed.js';
+import { rscDelegatePlugin } from '../plugins/vite-plugin-rsc-delegate.js';
+import { mergeUserViteConfig } from '../utils/merge-vite-config.js';
+import { viteHot } from '../plugins/vite-plugin-rsc-hmr.js';
+// For react-server-dom-webpack/server.edge
+globalThis.AsyncLocalStorage = AsyncLocalStorage;
+const { default: module } = await import('node:module');
+const HAS_MODULE_REGISTER = typeof module.register === 'function';
+if (HAS_MODULE_REGISTER) {
+    module.register('waku/node-loader', pathToFileURL('./'));
+}
+globalThis.__WAKU_PRIVATE_ENV__ = getEnvironmentData('__WAKU_PRIVATE_ENV__');
+const configBasePath = getEnvironmentData('CONFIG_BASE_PATH');
+const configSrcDir = getEnvironmentData('CONFIG_SRC_DIR');
+const configEntries = getEnvironmentData('CONFIG_ENTRIES');
+const configPrivateDir = getEnvironmentData('CONFIG_PRIVATE_DIR');
+const resolveClientEntryForDev = (id, config, initialModules)=>{
+    let file = id.startsWith('file://') ? decodeFilePathFromAbsolute(fileURLToFilePath(id)) : id;
+    for (const moduleNode of initialModules){
+        if (moduleNode.file === file) {
+            return moduleNode.url;
+        }
+    }
+    if (file.startsWith(config.rootDir)) {
+        file = file.slice(config.rootDir.length + 1); // '+ 1' to remove '/'
+    } else {
+        file = '@fs' + encodeFilePathToAbsolute(file);
+    }
+    return config.basePath + file;
+};
+const handleErr = (id, err)=>{
+    const mesg = {
+        id,
+        type: 'err',
+        err: `${err}`
+    };
+    if (hasStatusCode(err)) {
+        mesg.statusCode = err.statusCode;
+    }
+    parentPort.postMessage(mesg);
+};
+const handleRender = async (mesg)=>{
+    const vite = await vitePromise;
+    const { id, type: _removed, hasModuleIdCallback, initialModules, ...rest } = mesg;
+    try {
+        let moduleIdCallback;
+        if (hasModuleIdCallback) {
+            moduleIdCallback = (moduleId)=>{
+                const mesg = {
+                    id,
+                    type: 'moduleId',
+                    moduleId
+                };
+                parentPort.postMessage(mesg);
+            };
+        }
+        const readable = await renderRsc({
+            config: rest.config,
+            input: rest.input,
+            searchParams: new URLSearchParams(rest.searchParamsString),
+            method: rest.method,
+            context: rest.context,
+            body: rest.body,
+            contentType: rest.contentType,
+            moduleIdCallback,
+            onError: (err)=>{
+                handleErr(id, err);
+            }
+        }, {
+            isDev: true,
+            loadServerFile,
+            resolveClientEntry: (id)=>resolveClientEntryForDev(id, {
+                    rootDir: vite.config.root,
+                    basePath: rest.config.basePath
+                }, initialModules),
+            entries: await loadEntries(rest.config)
+        });
+        const mesg = {
+            id,
+            type: 'start',
+            context: rest.context,
+            stream: readable
+        };
+        parentPort.postMessage(mesg, [
+            readable
+        ]);
+        deepFreeze(rest.context);
+    } catch (err) {
+        handleErr(id, err);
+    }
+};
+const handleGetSsrConfig = async (mesg)=>{
+    const vite = await vitePromise;
+    const { id, config, pathname, searchParamsString, initialModules } = mesg;
+    const searchParams = new URLSearchParams(searchParamsString);
+    try {
+        const ssrConfig = await getSsrConfig({
+            config,
+            pathname,
+            searchParams
+        }, {
+            isDev: true,
+            resolveClientEntry: (id)=>resolveClientEntryForDev(id, {
+                    rootDir: vite.config.root,
+                    basePath: config.basePath
+                }, initialModules),
+            entries: await loadEntries(config)
+        });
+        const mesg = ssrConfig ? {
+            id,
+            type: 'ssrConfig',
+            ...ssrConfig
+        } : {
+            id,
+            type: 'noSsrConfig'
+        };
+        parentPort.postMessage(mesg, ssrConfig ? [
+            ssrConfig.body
+        ] : undefined);
+    } catch (err) {
+        handleErr(id, err);
+    }
+};
+const dummyServer = new Server(); // FIXME we hope to avoid this hack
+const hotUpdateCallback = (payload)=>{
+    const mesg = {
+        type: 'hot-update',
+        payload
+    };
+    parentPort.postMessage(mesg);
+};
+const mergedViteConfig = await mergeUserViteConfig({
+    // Since we have multiple instances of vite, different ones might overwrite the others' cache.
+    cacheDir: 'node_modules/.vite/waku-dev-worker',
+    plugins: [
+        viteReact(),
+        nonjsResolvePlugin(),
+        rscEnvPlugin({}),
+        rscPrivatePlugin({
+            privateDir: configPrivateDir,
+            hotUpdateCallback
+        }),
+        rscManagedPlugin({
+            basePath: configBasePath,
+            srcDir: configSrcDir
+        }),
+        rscTransformPlugin({
+            isClient: false,
+            isBuild: false
+        }),
+        rscDelegatePlugin(hotUpdateCallback)
+    ],
+    optimizeDeps: {
+        include: [
+            'react-server-dom-webpack/client',
+            'react-dom'
+        ],
+        exclude: [
+            'waku'
+        ],
+        entries: [
+            `${configSrcDir}/${configEntries}.*`,
+            // HACK hard-coded "pages"
+            `${configSrcDir}/pages/**/*.*`
+        ]
+    },
+    ssr: {
+        resolve: {
+            conditions: [
+                'react-server',
+                'workerd'
+            ],
+            externalConditions: [
+                'react-server',
+                'workerd'
+            ]
+        },
+        external: [
+            'waku'
+        ]
+    },
+    appType: 'custom',
+    server: {
+        middlewareMode: true,
+        hmr: {
+            server: dummyServer
+        }
+    }
+});
+const vitePromise = createViteServer(mergedViteConfig).then(async (vite)=>{
+    const hot = viteHot(vite);
+    await hot.close();
+    return vite;
+});
+const loadServerFile = async (fileURL)=>{
+    const vite = await vitePromise;
+    return vite.ssrLoadModule(fileURLToFilePath(fileURL));
+};
+const loadEntries = async (config)=>{
+    const vite = await vitePromise;
+    const filePath = joinPath(vite.config.root, config.srcDir, configEntries);
+    return vite.ssrLoadModule(filePath);
+};
+// load entries eagerly
+loadEntries({
+    srcDir: configSrcDir
+}).catch(()=>{
+// ignore
+});
+parentPort.on('message', async (mesg)=>{
+    if (mesg.type === 'render') {
+        await handleRender(mesg);
+    } else if (mesg.type === 'getSsrConfig') {
+        await handleGetSsrConfig(mesg);
+    }
+});
diff --git a/dist/lib/renderers/html-renderer.d.ts b/dist/lib/renderers/html-renderer.d.ts
index d333262fb3c8a548600cb6ec8b9fbeb4d3a923bb..f6a0c2e6af54150b7b00f1fdc9bece316837c3f5 100644
--- a/dist/lib/renderers/html-renderer.d.ts
+++ b/dist/lib/renderers/html-renderer.d.ts
@@ -1,27 +1,23 @@
 import type { EntriesPrd } from '../../server.js';
 import type { ResolvedConfig } from '../config.js';
-export declare const CLIENT_MODULE_MAP: {
-    readonly 'rd-server': "react-dom/server.edge";
-    readonly 'rsdw-client': "react-server-dom-webpack/client.edge";
-    readonly 'waku-client': "waku/client";
-};
-export declare const CLIENT_PREFIX = "client/";
+import type { CLIENT_MODULE_KEY } from '../handlers/handler-dev.js';
 export declare const renderHtml: (opts: {
-    config: Omit<ResolvedConfig, "middleware">;
+    config: Omit<ResolvedConfig, 'middleware'>;
     pathname: string;
     searchParams: URLSearchParams;
     htmlHead: string;
-    renderRscForHtml: (input: string, params?: unknown) => Promise<ReadableStream>;
+    renderRscForHtml: (input: string, searchParams: URLSearchParams) => Promise<ReadableStream>;
     getSsrConfigForHtml: (pathname: string, searchParams: URLSearchParams) => Promise<{
         input: string;
-        params?: unknown;
-        html: ReadableStream;
+        searchParams?: URLSearchParams;
+        body: ReadableStream;
     } | null>;
+    loadClientModule: (key: CLIENT_MODULE_KEY) => Promise<unknown>;
 } & ({
     isDev: false;
-    loadModule: EntriesPrd["loadModule"];
+    loadModule: EntriesPrd['loadModule'];
 } | {
     isDev: true;
     rootDir: string;
-    loadServerModuleMain: (idOrFileURL: string) => Promise<unknown>;
+    loadServerFile: (fileURL: string) => Promise<unknown>;
 })) => Promise<ReadableStream | null>;
diff --git a/dist/lib/renderers/html-renderer.js b/dist/lib/renderers/html-renderer.js
index 8b60abbb4760e5a691dba8257b81bc2cd7aa9a44..858e3e5f138eaa262833bb50050a15c26885446f 100644
--- a/dist/lib/renderers/html-renderer.js
+++ b/dist/lib/renderers/html-renderer.js
@@ -1,10 +1,10 @@
 import { createElement } from 'react';
 import { injectRSCPayload } from 'rsc-html-stream/server';
+import { SRC_MAIN } from '../constants.js';
 import { concatUint8Arrays } from '../utils/stream.js';
 import { joinPath, filePathToFileURL, fileURLToFilePath, encodeFilePathToAbsolute } from '../utils/path.js';
 import { encodeInput, hasStatusCode } from './utils.js';
 // HACK depending on these constants is not ideal
-import { SRC_MAIN } from '../plugins/vite-plugin-rsc-managed.js';
 import { DEFAULT_HTML_HEAD } from '../plugins/vite-plugin-rsc-index.js';
 export const CLIENT_MODULE_MAP = {
     'rd-server': 'react-dom/server.edge',
diff --git a/dist/lib/renderers/rsc-renderer.d.ts b/dist/lib/renderers/rsc-renderer.d.ts
index 93940dd084111c92f9c90c69f954a3a77b92fd89..bd503f66c4d20e3d5082a04b9795dbddcd4ab320 100644
--- a/dist/lib/renderers/rsc-renderer.d.ts
+++ b/dist/lib/renderers/rsc-renderer.d.ts
@@ -1,19 +1,16 @@
 import type { EntriesDev, EntriesPrd } from '../../server.js';
 import type { ResolvedConfig } from '../config.js';
-export declare const SERVER_MODULE_MAP: {
-    readonly 'rsdw-server': "react-server-dom-webpack/server.edge";
-    readonly 'waku-server': "waku/server";
-};
+export declare const RSDW_SERVER_MODULE = "rsdw-server";
+export declare const RSDW_SERVER_MODULE_VALUE = "react-server-dom-webpack/server.edge";
 export type RenderRscArgs = {
-    env: Record<string, string>;
     config: Omit<ResolvedConfig, 'middleware'>;
     input: string;
+    searchParams: URLSearchParams;
+    method: 'GET' | 'POST';
     context: Record<string, unknown> | undefined;
-    decodedBody?: unknown;
     body?: ReadableStream | undefined;
     contentType?: string | undefined;
     moduleIdCallback?: ((id: string) => void) | undefined;
-    onError?: (err: unknown) => void;
 };
 type RenderRscOpts = {
     isDev: false;
@@ -21,20 +18,25 @@ type RenderRscOpts = {
 } | {
     isDev: true;
     entries: EntriesDev;
-    loadServerModuleRsc: (idOrFileURL: string) => Promise<unknown>;
+    customImport: (fileURL: string) => Promise<unknown>;
     resolveClientEntry: (id: string) => string;
 };
 export declare function renderRsc(args: RenderRscArgs, opts: RenderRscOpts): Promise<ReadableStream>;
-type GetBuildConfigArgs = {
-    env: Record<string, string>;
-    config: Omit<ResolvedConfig, 'middleware'>;
-};
-type GetBuildConfigOpts = {
+export declare function getBuildConfig(opts: {
+    config: ResolvedConfig;
     entries: EntriesPrd;
-};
-export declare function getBuildConfig(args: GetBuildConfigArgs, opts: GetBuildConfigOpts): Promise<import("../../server.js").BuildConfig>;
+}): Promise<Iterable<{
+    pathname: string | import("../utils/path.js").PathSpec;
+    isStatic?: boolean;
+    entries?: Iterable<{
+        input: string;
+        skipPrefetch?: boolean;
+        isStatic?: boolean;
+    }>;
+    customCode?: string;
+    context?: Record<string, unknown>;
+}>>;
 export type GetSsrConfigArgs = {
-    env: Record<string, string>;
     config: Omit<ResolvedConfig, 'middleware'>;
     pathname: string;
     searchParams: URLSearchParams;
@@ -45,12 +47,11 @@ type GetSsrConfigOpts = {
 } | {
     isDev: true;
     entries: EntriesDev;
-    loadServerModuleRsc: (id: string) => Promise<unknown>;
     resolveClientEntry: (id: string) => string;
 };
 export declare function getSsrConfig(args: GetSsrConfigArgs, opts: GetSsrConfigOpts): Promise<{
-    html: ReadableStream<any>;
+    body: any;
     input: string;
-    params?: unknown;
+    searchParams?: URLSearchParams;
 } | null>;
 export {};
diff --git a/dist/lib/renderers/utils.d.ts b/dist/lib/renderers/utils.d.ts
index 71881d05799912a2bbdee24000298d84f1ea8116..9f391ef3ec6a63701436686c5d9209877e85da72 100644
--- a/dist/lib/renderers/utils.d.ts
+++ b/dist/lib/renderers/utils.d.ts
@@ -1,9 +1,10 @@
 export declare const encodeInput: (input: string) => string;
 export declare const decodeInput: (encodedInput: string) => string;
 export declare const encodeActionId: (actionId: string) => string;
-export declare const decodeActionId: (encoded: string) => string | null;
+export declare const decodeActionId: (encoded: string) => string;
 export declare const hasStatusCode: (x: unknown) => x is {
     statusCode: number;
 };
+export declare const codeToInject = "\nglobalThis.__waku_module_cache__ = new Map();\nglobalThis.__webpack_chunk_load__ = (id) => import(id).then((m) => globalThis.__waku_module_cache__.set(id, m));\nglobalThis.__webpack_require__ = (id) => globalThis.__waku_module_cache__.get(id);";
 export declare const generatePrefetchCode: (basePrefix: string, inputs: Iterable<string>, moduleIds: Iterable<string>) => string;
 export declare const deepFreeze: (x: unknown) => void;
diff --git a/dist/lib/utils/buffer.d.ts b/dist/lib/utils/buffer.d.ts
deleted file mode 100644
index ce7e80a400504544b83140fb770e7ecae91b5bb2..0000000000000000000000000000000000000000
diff --git a/dist/lib/utils/form.d.ts b/dist/lib/utils/form.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..fcd8fbdda25656157a71a4163bb7fb42ecb38cbd
--- /dev/null
+++ b/dist/lib/utils/form.d.ts
@@ -0,0 +1 @@
+export declare const parseFormData: (body: string, contentType: string) => FormData;
diff --git a/dist/lib/utils/form.js b/dist/lib/utils/form.js
new file mode 100644
index 0000000000000000000000000000000000000000..b5d007c59b61c6c5b72ee00e52add9323953dcfc
--- /dev/null
+++ b/dist/lib/utils/form.js
@@ -0,0 +1,34 @@
+// TODO is this correct? better to use a library?
+export const parseFormData = (body, contentType)=>{
+    const boundary = contentType.split('boundary=')[1];
+    const parts = body.split(`--${boundary}`);
+    const formData = new FormData();
+    for (const part of parts){
+        if (part.trim() === '' || part === '--') continue;
+        const [rawHeaders, content] = part.split('\r\n\r\n', 2);
+        const headers = rawHeaders.split('\r\n').reduce((acc, currentHeader)=>{
+            const [key, value] = currentHeader.split(': ');
+            acc[key.toLowerCase()] = value;
+            return acc;
+        }, {});
+        const contentDisposition = headers['content-disposition'];
+        const nameMatch = /name="([^"]+)"/.exec(contentDisposition);
+        const filenameMatch = /filename="([^"]+)"/.exec(contentDisposition);
+        if (nameMatch) {
+            const name = nameMatch[1];
+            if (filenameMatch) {
+                const filename = filenameMatch[1];
+                const type = headers['content-type'] || 'application/octet-stream';
+                const blob = new Blob([
+                    content
+                ], {
+                    type
+                });
+                formData.append(name, blob, filename);
+            } else {
+                formData.append(name, content.trim());
+            }
+        }
+    }
+    return formData;
+};
diff --git a/dist/lib/utils/node-fs.d.ts b/dist/lib/utils/node-fs.d.ts
index 3311cbb8afa012c51820f11ab8190a603415eef2..873a1f108668a2865644cbfe9904c9a62b3baca8 100644
--- a/dist/lib/utils/node-fs.d.ts
+++ b/dist/lib/utils/node-fs.d.ts
@@ -1,3 +1,4 @@
+/// <reference types="node" resolution-mode="require"/>
 import fs from 'node:fs';
 export declare const createReadStream: (filePath: string) => fs.ReadStream;
 export declare const createWriteStream: (filePath: string) => fs.WriteStream;
@@ -8,13 +9,13 @@ export declare const mkdir: (filePath: string, options?: {
     recursive?: boolean | undefined;
 }) => Promise<string | undefined>;
 export declare const readFile: (filePath: string, options: {
-    encoding: "utf8";
+    encoding: 'utf8';
 }) => Promise<string>;
 export declare const writeFile: (filePath: string, content: string) => Promise<void>;
 export declare const appendFile: (filePath: string, content: string) => Promise<void>;
 export declare const stat: (filePath: string) => Promise<fs.Stats>;
 export declare const unlink: (filePath: string) => Promise<void>;
 export declare const readdir: (filePath: string, options?: {
-    encoding: "utf8";
+    encoding: 'utf8';
     recursive: boolean;
 }) => Promise<string[]>;
diff --git a/dist/lib/utils/path.d.ts b/dist/lib/utils/path.d.ts
index cedadb96a0203cf4e79368fb1a3a6ccaa98439d7..c29f66b91eb79545d71406a1fd0144fca01c3e65 100644
--- a/dist/lib/utils/path.d.ts
+++ b/dist/lib/utils/path.d.ts
@@ -16,23 +16,4 @@ export type PathSpecItem = {
 };
 export type PathSpec = readonly PathSpecItem[];
 export declare const parsePathWithSlug: (path: string) => PathSpec;
-/**
- * Transform a path spec to a regular expression.
- */
-export declare const path2regexp: (path: PathSpec) => string;
-/**
- * Helper function to get the path mapping from the path spec and the pathname.
- *
- * @param pathSpec
- * @param pathname - route as a string
- * @example
- * getPathMapping(
- *   [
- *     { type: 'literal', name: 'foo' },
- *     { type: 'group', name: 'a' },
- *   ],
- *   '/foo/bar',
- * );
- * // => { a: 'bar' }
- */
 export declare const getPathMapping: (pathSpec: PathSpec, pathname: string) => Record<string, string | string[]> | null;
diff --git a/dist/lib/utils/stream.d.ts b/dist/lib/utils/stream.d.ts
index 7bcb354a79be20b174180329775210a659129f20..12793e3f6a877285f8a46f904d5e18c7f6fa3ad8 100644
--- a/dist/lib/utils/stream.d.ts
+++ b/dist/lib/utils/stream.d.ts
@@ -1,4 +1,4 @@
+export declare const endStream: (stream: WritableStream, message?: string) => Promise<void>;
 export declare const concatUint8Arrays: (arrs: Uint8Array[]) => Uint8Array;
-export declare const streamToArrayBuffer: (stream: ReadableStream) => Promise<ArrayBufferLike>;
 export declare const streamToString: (stream: ReadableStream) => Promise<string>;
 export declare const stringToStream: (str: string) => ReadableStream;
diff --git a/dist/lib/utils/swc.d.ts b/dist/lib/utils/swc.d.ts
deleted file mode 100644
index 17e02e67ba32647b08b3b89b46a600f4663e5aab..0000000000000000000000000000000000000000
diff --git a/dist/lib/utils/vite-loader.d.ts b/dist/lib/utils/vite-loader.d.ts
deleted file mode 100644
index 65935276b06e9c06466eb5b86389f6c912ceaff4..0000000000000000000000000000000000000000
diff --git a/dist/lib/vite-plugin/nonjs-resolve-plugin.d.ts b/dist/lib/vite-plugin/nonjs-resolve-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e6abbc93c3958627bd9f96788ed42067d8631662
--- /dev/null
+++ b/dist/lib/vite-plugin/nonjs-resolve-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function nonjsResolvePlugin(): Plugin;
diff --git a/dist/lib/vite-plugin/nonjs-resolve-plugin.js b/dist/lib/vite-plugin/nonjs-resolve-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..fcad621638d010d0d64b1c8ccb2cf3d1a65a3ca0
--- /dev/null
+++ b/dist/lib/vite-plugin/nonjs-resolve-plugin.js
@@ -0,0 +1,25 @@
+import path from 'node:path';
+export function nonjsResolvePlugin() {
+    return {
+        name: 'nonjs-resolve-plugin',
+        async resolveId (id, importer, options) {
+            if (!id.endsWith('.js')) {
+                return id;
+            }
+            for (const ext of [
+                '.js',
+                '.ts',
+                '.tsx',
+                '.jsx'
+            ]){
+                const resolved = await this.resolve(id.slice(0, -path.extname(id).length) + ext, importer, {
+                    ...options,
+                    skipSelf: true
+                });
+                if (resolved) {
+                    return resolved;
+                }
+            }
+        }
+    };
+}
diff --git a/dist/lib/vite-plugin/patch-react-refresh.d.ts b/dist/lib/vite-plugin/patch-react-refresh.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2e3090d165db0d9cc3215e0b9a42154decae7c8a
--- /dev/null
+++ b/dist/lib/vite-plugin/patch-react-refresh.d.ts
@@ -0,0 +1,2 @@
+import type { PluginOption } from 'vite';
+export declare const patchReactRefresh: <T extends PluginOption[]>(options: T) => T;
diff --git a/dist/lib/vite-plugin/patch-react-refresh.js b/dist/lib/vite-plugin/patch-react-refresh.js
new file mode 100644
index 0000000000000000000000000000000000000000..8254104c2da7f8872c8e276a592784d4d4df3bc9
--- /dev/null
+++ b/dist/lib/vite-plugin/patch-react-refresh.js
@@ -0,0 +1,23 @@
+export const patchReactRefresh = (options)=>options.map((option)=>{
+        const plugin = option;
+        const origTransformIndexHtml = plugin?.transformIndexHtml;
+        if (plugin?.name === 'vite:react-refresh' && typeof origTransformIndexHtml === 'function') {
+            return {
+                ...option,
+                transformIndexHtml (...args) {
+                    const result = origTransformIndexHtml(...args);
+                    if (Array.isArray(result)) {
+                        return result.map((item)=>({
+                                ...item,
+                                attrs: {
+                                    ...item.attrs,
+                                    async: true
+                                }
+                            }));
+                    }
+                    return result;
+                }
+            };
+        }
+        return option;
+    });
diff --git a/dist/lib/vite-plugin/rsc-analyze-plugin.d.ts b/dist/lib/vite-plugin/rsc-analyze-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..80b3a0979425363125877235967cbcdb66deed86
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-analyze-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscAnalyzePlugin(commonFileSet: Set<string>, clientFileSet: Set<string>, serverFileSet: Set<string>): Plugin;
diff --git a/dist/lib/vite-plugin/rsc-analyze-plugin.js b/dist/lib/vite-plugin/rsc-analyze-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..9653948c9e60d538b28c2c561cf32f860ebfe283
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-analyze-plugin.js
@@ -0,0 +1,102 @@
+import path from 'node:path';
+import { existsSync } from 'node:fs';
+import * as swc from '@swc/core';
+export function rscAnalyzePlugin(commonFileSet, clientFileSet, serverFileSet) {
+    const dependencyMap = new Map();
+    const clientEntryCallback = (id)=>clientFileSet.add(id);
+    const serverEntryCallback = (id)=>serverFileSet.add(id);
+    const dependencyCallback = (id, depId)=>{
+        let depSet = dependencyMap.get(id);
+        if (!depSet) {
+            depSet = new Set();
+            dependencyMap.set(id, depSet);
+        }
+        depSet.add(depId);
+    };
+    return {
+        name: 'rsc-analyze-plugin',
+        async transform (code, id) {
+            const ext = path.extname(id);
+            if ([
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx',
+                '.mjs'
+            ].includes(ext)) {
+                const mod = swc.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral') {
+                        if (item.expression.value === 'use client') {
+                            clientEntryCallback(id);
+                        } else if (item.expression.value === 'use server') {
+                            serverEntryCallback(id);
+                        }
+                    }
+                    if (item.type === 'ImportDeclaration') {
+                        const resolvedId = await this.resolve(item.source.value, id);
+                        if (resolvedId) {
+                            dependencyCallback(id, resolvedId.id);
+                        }
+                    }
+                }
+            }
+            return code;
+        },
+        generateBundle (_options, bundle) {
+            // TODO the logic in this function should probably be redesigned.
+            const outputIds = Object.values(bundle).flatMap((item)=>'facadeModuleId' in item && item.facadeModuleId ? [
+                    item.facadeModuleId
+                ] : []);
+            const possibleCommonFileMap = new Map();
+            const seen = new Set();
+            const loop = (id, isClient)=>{
+                if (seen.has(id)) {
+                    return;
+                }
+                seen.add(id);
+                isClient = isClient || clientFileSet.has(id);
+                for (const depId of dependencyMap.get(id) ?? []){
+                    if (!existsSync(depId)) {
+                        // HACK is there a better way?
+                        return;
+                    }
+                    let value = possibleCommonFileMap.get(depId);
+                    if (!value) {
+                        value = {};
+                        possibleCommonFileMap.set(depId, value);
+                    }
+                    if (isClient) {
+                        value.fromClient = true;
+                    } else {
+                        value.notFromClient = true;
+                    }
+                    loop(depId, isClient);
+                }
+            };
+            for (const id of outputIds){
+                loop(id, false);
+            }
+            for (const id of clientFileSet){
+                loop(id, true);
+            }
+            for (const id of serverFileSet){
+                loop(id, false);
+            }
+            for (const [id, val] of possibleCommonFileMap){
+                if (val.fromClient && val.notFromClient) {
+                    commonFileSet.add(id);
+                }
+            }
+            for (const id of clientFileSet){
+                commonFileSet.delete(id);
+            }
+            for (const id of serverFileSet){
+                commonFileSet.delete(id);
+            }
+        }
+    };
+}
diff --git a/dist/lib/vite-plugin/rsc-delegate-plugin.d.ts b/dist/lib/vite-plugin/rsc-delegate-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..25bc42929ce87bcc386d644db397c03c11919e9c
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-delegate-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscDelegatePlugin(importCallback: (source: string) => void): Plugin;
diff --git a/dist/lib/vite-plugin/rsc-delegate-plugin.js b/dist/lib/vite-plugin/rsc-delegate-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..13b4bad7721afe3a5868fd926601d6681d616e61
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-delegate-plugin.js
@@ -0,0 +1,44 @@
+import path from 'node:path';
+import * as swc from '@swc/core';
+// import { CSS_LANGS_RE } from "vite/dist/node/constants.js";
+const CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
+export function rscDelegatePlugin(importCallback) {
+    let mode = 'development';
+    let base = '/';
+    return {
+        name: 'rsc-delegate-plugin',
+        configResolved (config) {
+            mode = config.mode;
+            base = config.base;
+        },
+        transform (code, id) {
+            const ext = path.extname(id);
+            if (mode === 'development' && [
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx'
+            ].includes(ext)) {
+                const mod = swc.parseSync(code, {
+                    syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                    tsx: ext === '.tsx'
+                });
+                for (const item of mod.body){
+                    if (item.type === 'ImportDeclaration') {
+                        if (item.source.value.startsWith('virtual:')) {
+                            // HACK this relies on Vite's internal implementation detail.
+                            const source = base + '@id/__x00__' + item.source.value;
+                            importCallback(source);
+                        } else if (CSS_LANGS_RE.test(item.source.value)) {
+                            const filePath = path.join(path.dirname(id), item.source.value);
+                            // HACK this relies on Vite's internal implementation detail.
+                            const source = base + '@fs/' + filePath.replace(/^\//, '');
+                            importCallback(source);
+                        }
+                    }
+                }
+            }
+            return code;
+        }
+    };
+}
diff --git a/dist/lib/vite-plugin/rsc-hmr-plugin.d.ts b/dist/lib/vite-plugin/rsc-hmr-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4312a79ac9b41ec4cd806a85ce5955dee54d20c3
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-hmr-plugin.d.ts
@@ -0,0 +1,3 @@
+import type { Plugin, ViteDevServer } from 'vite';
+export declare function rscHmrPlugin(): Plugin;
+export declare function hotImport(vite: ViteDevServer, source: string): void;
diff --git a/dist/lib/vite-plugin/rsc-hmr-plugin.js b/dist/lib/vite-plugin/rsc-hmr-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..a2a4e6bf8de104e3ccbd6c94e817c6c468a03367
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-hmr-plugin.js
@@ -0,0 +1,47 @@
+import path from 'node:path';
+const customCode = `
+if (import.meta.hot && !globalThis.__WAKU_HMR_CONFIGURED__) {
+  globalThis.__WAKU_HMR_CONFIGURED__ = true;
+  import.meta.hot.on('hot-import', (data) => import(/* @vite-ignore */ data));
+}
+`;
+export function rscHmrPlugin() {
+    return {
+        name: 'rsc-hmr-plugin',
+        async transform (code, id) {
+            const ext = path.extname(id);
+            if ([
+                '.ts',
+                '.tsx',
+                '.js',
+                '.jsx'
+            ].includes(ext)) {
+                return code + customCode;
+            }
+            return code;
+        }
+    };
+}
+const pendingMap = new WeakMap();
+export function hotImport(vite, source) {
+    let sourceSet = pendingMap.get(vite);
+    if (!sourceSet) {
+        sourceSet = new Set();
+        pendingMap.set(vite, sourceSet);
+        vite.ws.on('connection', ()=>{
+            for (const source of sourceSet){
+                vite.ws.send({
+                    type: 'custom',
+                    event: 'hot-import',
+                    data: source
+                });
+            }
+        });
+    }
+    sourceSet.add(source);
+    vite.ws.send({
+        type: 'custom',
+        event: 'hot-import',
+        data: source
+    });
+}
diff --git a/dist/lib/vite-plugin/rsc-index-plugin.d.ts b/dist/lib/vite-plugin/rsc-index-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..364c01c22e2b5bf6d7c18a66a4a12ea87187bb96
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-index-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscIndexPlugin(cssAssets: string[]): Plugin;
diff --git a/dist/lib/vite-plugin/rsc-index-plugin.js b/dist/lib/vite-plugin/rsc-index-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..cdba738ba8007b778212d3b1248e02903ef2e31d
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-index-plugin.js
@@ -0,0 +1,28 @@
+// FIXME we should avoid external dependencies out of this file.
+import { codeToInject } from '../middleware/rsc/utils.js';
+export function rscIndexPlugin(cssAssets) {
+    return {
+        name: 'rsc-index-plugin',
+        async transformIndexHtml () {
+            return [
+                {
+                    tag: 'script',
+                    attrs: {
+                        type: 'module',
+                        async: true
+                    },
+                    children: codeToInject,
+                    injectTo: 'head-prepend'
+                },
+                ...cssAssets.map((href)=>({
+                        tag: 'link',
+                        attrs: {
+                            rel: 'stylesheet',
+                            href
+                        },
+                        injectTo: 'head'
+                    }))
+            ];
+        }
+    };
+}
diff --git a/dist/lib/vite-plugin/rsc-reload-plugin.d.ts b/dist/lib/vite-plugin/rsc-reload-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..0de946e47d0f9c9324f5f423dce699874006fe1e
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-reload-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscReloadPlugin(fn: (type: 'full-reload') => void): Plugin;
diff --git a/dist/lib/vite-plugin/rsc-reload-plugin.js b/dist/lib/vite-plugin/rsc-reload-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..e7c42e46b4d76530cba6e5d120114b26e8034a0b
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-reload-plugin.js
@@ -0,0 +1,43 @@
+import path from 'node:path';
+import * as swc from '@swc/core';
+export function rscReloadPlugin(fn) {
+    let enabled = false;
+    const isClientEntry = (id, code)=>{
+        const ext = path.extname(id);
+        if ([
+            '.ts',
+            '.tsx',
+            '.js',
+            '.jsx'
+        ].includes(ext)) {
+            const mod = swc.parseSync(code, {
+                syntax: ext === '.ts' || ext === '.tsx' ? 'typescript' : 'ecmascript',
+                tsx: ext === '.tsx'
+            });
+            for (const item of mod.body){
+                if (item.type === 'ExpressionStatement' && item.expression.type === 'StringLiteral' && item.expression.value === 'use client') {
+                    return true;
+                }
+            }
+        }
+        return false;
+    };
+    return {
+        name: 'rsc-reload-plugin',
+        configResolved (config) {
+            if (config.mode === 'development') {
+                enabled = true;
+            }
+        },
+        async handleHotUpdate (ctx) {
+            if (!enabled) {
+                return [];
+            }
+            if (ctx.modules.length && !isClientEntry(ctx.file, await ctx.read())) {
+                fn('full-reload');
+            } else {
+                return [];
+            }
+        }
+    };
+}
diff --git a/dist/lib/vite-plugin/rsc-transform-plugin.d.ts b/dist/lib/vite-plugin/rsc-transform-plugin.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..138e10e98edd356992a8c64855b7bd655a23a2a3
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-transform-plugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from 'vite';
+export declare function rscTransformPlugin(): Plugin;
diff --git a/dist/lib/vite-plugin/rsc-transform-plugin.js b/dist/lib/vite-plugin/rsc-transform-plugin.js
new file mode 100644
index 0000000000000000000000000000000000000000..f57dd77271d26e7fcb13cd72f83e67befb4cac83
--- /dev/null
+++ b/dist/lib/vite-plugin/rsc-transform-plugin.js
@@ -0,0 +1,74 @@
+import path from 'node:path';
+import * as RSDWNodeLoader from 'react-server-dom-webpack/node-loader';
+export function rscTransformPlugin(isBuild) {
+    return {
+        name: 'rsc-transform-plugin',
+        async resolveId (id, importer, options) {
+            if (!id.endsWith('.js')) {
+                return id;
+            }
+            // FIXME This isn't necessary in production mode
+            // (But, waku/router may depend on this.)
+            for (const ext of [
+                '.js',
+                '.ts',
+                '.tsx',
+                '.jsx'
+            ]){
+                const resolved = await this.resolve(id.slice(0, -path.extname(id).length) + ext, importer, {
+                    ...options,
+                    skipSelf: true
+                });
+                if (resolved) {
+                    return resolved;
+                }
+            }
+        },
+        async transform (code, id) {
+            const resolve = async (specifier, { parentURL })=>{
+                if (!specifier) {
+                    return {
+                        url: ''
+                    };
+                }
+                const url = (await this.resolve(specifier, parentURL, {
+                    skipSelf: true
+                })).id;
+                return {
+                    url
+                };
+            };
+            const load = async (url)=>{
+                let source = url === id ? code : (await this.load({
+                    id: url
+                })).code;
+                // HACK move directives before import statements.
+                source = source.replace(/^(import {.*?} from ".*?";)\s*"use (client|server)";/, '"use $2";$1');
+                return {
+                    format: 'module',
+                    source
+                };
+            };
+            RSDWNodeLoader.resolve('', {
+                conditions: [
+                    'react-server',
+                    'workerd'
+                ],
+                parentURL: ''
+            }, resolve);
+            let { source } = await RSDWNodeLoader.load(id, null, load);
+            if (isBuild) {
+                // TODO we should parse the source code by ourselves with SWC
+                if (/^import {registerClientReference} from "react-server-dom-webpack\/server";/.test(source)) {
+                    // HACK tweak registerClientReference for production
+                    source = source.replace(/ registerClientReference\(function\(\) {throw new Error\("([^"]*)"\);},"[^"]*","([^"]*)"\);/gs, ' registerClientReference(function() {return "$1";}, import.meta.url, "$2");');
+                }
+                if (/;import {registerServerReference} from "react-server-dom-webpack\/server";/.test(source)) {
+                    // HACK tweak registerServerReference for production
+                    source = source.replace(/ registerServerReference\(([^,]*),"[^"]*","([^"]*)"\);/gs, ' registerServerReference($1, import.meta.url, "$2");');
+                }
+            }
+            return source;
+        }
+    };
+}
diff --git a/dist/main.d.ts b/dist/main.d.ts
index 015ff9690964152fd9b757a2d389da1c44a37bf4..2e014e71c876c05820610821d38e9d2fa5e72199 100644
--- a/dist/main.d.ts
+++ b/dist/main.d.ts
@@ -1,4 +1,3 @@
-export { Link, useRouter_UNSTABLE } from 'waku/router/client';
-import type { createPages as createPagesType, getEnv as getEnvType } from './main.react-server.js';
-export declare const createPages: typeof createPagesType;
-export declare const getEnv: typeof getEnvType;
+export { Link } from 'waku/router/client';
+export { createPages } from 'waku/router/server';
+export { getEnv } from 'waku/server';
diff --git a/dist/main.react-server.d.ts b/dist/main.react-server.d.ts
deleted file mode 100644
index 27ae23790270681bc13a63ee18f697d062300aa7..0000000000000000000000000000000000000000
diff --git a/dist/middleware/headers.d.ts b/dist/middleware/headers.d.ts
deleted file mode 100644
index 6aeae397a8c426ee8719ad4ce30e0c7326c3b1a9..0000000000000000000000000000000000000000
diff --git a/dist/node-loader.d.ts b/dist/node-loader.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..192ea516ed3c413b7b377e9c88147cfa550c92f8
--- /dev/null
+++ b/dist/node-loader.d.ts
@@ -0,0 +1,11 @@
+/// <reference types="node" resolution-mode="require"/>
+/**
+ * We manually call the hooks on react-server-dom-webpack/node-loader.
+ * 1. `react-server-dom-webpack/node-loader` uses Node.js 18 deprecated API.
+ * 2. `conditions` will not be read in ESM,
+ *      which will lead to a React warning on Node.js 20.
+ *      Refs: https://github.com/nodejs/node/issues/50885
+ */
+import type { LoadHook, ResolveHook } from 'node:module';
+export declare const load: LoadHook;
+export declare const resolve: ResolveHook;
diff --git a/dist/node-loader.js b/dist/node-loader.js
new file mode 100644
index 0000000000000000000000000000000000000000..49218c6bb5fb7880698cd1d7908c3587cc9c52be
--- /dev/null
+++ b/dist/node-loader.js
@@ -0,0 +1,32 @@
+/**
+ * We manually call the hooks on react-server-dom-webpack/node-loader.
+ * 1. `react-server-dom-webpack/node-loader` uses Node.js 18 deprecated API.
+ * 2. `conditions` will not be read in ESM,
+ *      which will lead to a React warning on Node.js 20.
+ *      Refs: https://github.com/nodejs/node/issues/50885
+ */ import * as RSDWNodeLoader from 'react-server-dom-webpack/node-loader';
+export const load = async (url, context, nextLoad)=>{
+    return RSDWNodeLoader.load(url, context, async (reqUrl, context)=>{
+        const result = await nextLoad(reqUrl, context);
+        if (result.format === 'module') {
+            let { source } = result;
+            if (source && typeof source !== 'string') {
+                source = source.toString();
+                return {
+                    ...result,
+                    source
+                };
+            }
+        }
+        return result;
+    });
+};
+export const resolve = async (specifier, context, nextResolve)=>{
+    return RSDWNodeLoader.resolve(specifier, {
+        ...context,
+        conditions: [
+            ...context.conditions,
+            'react-server'
+        ]
+    }, nextResolve);
+};
diff --git a/dist/prd.d.ts b/dist/prd.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..2c430f6636cc3d4f97bac670c377d641b1f0324e
--- /dev/null
+++ b/dist/prd.d.ts
@@ -0,0 +1,2 @@
+export { honoMiddleware as unstable_honoMiddleware } from './lib/old-wrappers/hono-prd.js';
+export { connectMiddleware as unstable_connectMiddleware } from './lib/old-wrappers/connect-prd.js';
diff --git a/dist/prd.js b/dist/prd.js
new file mode 100644
index 0000000000000000000000000000000000000000..2c430f6636cc3d4f97bac670c377d641b1f0324e
--- /dev/null
+++ b/dist/prd.js
@@ -0,0 +1,2 @@
+export { honoMiddleware as unstable_honoMiddleware } from './lib/old-wrappers/hono-prd.js';
+export { connectMiddleware as unstable_connectMiddleware } from './lib/old-wrappers/connect-prd.js';
diff --git a/dist/router/base-types.js b/dist/router/base-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..41e4649e8b98a7dd9aa1e3bed3dc7b74fbe4ecab
--- /dev/null
+++ b/dist/router/base-types.js
@@ -0,0 +1,2 @@
+// eslint-disable-next-line @typescript-eslint/no-empty-object-type
+export { };
diff --git a/dist/router/client.d.ts b/dist/router/client.d.ts
index 824b9bf2ff6edec803d12c59702d76f49ef19708..8be5ca264543d3ca6964910344ded7b7056ce39d 100644
--- a/dist/router/client.d.ts
+++ b/dist/router/client.d.ts
@@ -1,61 +1,36 @@
-import { Component } from 'react';
 import type { ReactNode, AnchorHTMLAttributes, ReactElement } from 'react';
-import type { RouteProps, ShouldSkip } from './common.js';
+import type { RouteProps } from './common.js';
 declare global {
     interface ImportMeta {
         readonly env: Record<string, string>;
     }
 }
-export declare function useRouter_UNSTABLE(): {
-    push: (to: string) => void;
-    replace: (to: string) => void;
-    reload: () => void;
-    back: () => void;
-    forward: () => void;
-    prefetch: (to: string) => void;
-    path: string;
-    query: string;
-    hash: string;
-};
+declare const parseLocation: () => RouteProps;
+type ChangeLocation = (path?: string, searchParams?: URLSearchParams, hash?: string, method?: 'pushState' | 'replaceState' | false, scrollTo?: ScrollToOptions | false) => void;
+export declare function useChangeLocation(): ChangeLocation;
+export declare function useLocation(): RouteProps;
 export type LinkProps = {
     to: string;
     pending?: ReactNode;
     notPending?: ReactNode;
     children: ReactNode;
     unstable_prefetchOnEnter?: boolean;
-    unstable_prefetchOnView?: boolean;
 } & Omit<AnchorHTMLAttributes<HTMLAnchorElement>, 'href'>;
-export declare function Link({ to, children, pending, notPending, unstable_prefetchOnEnter, unstable_prefetchOnView, ...props }: LinkProps): ReactElement;
-type RouterData = [
-    shouldSkip?: ShouldSkip,
-    locationListners?: Set<(path: string, query: string) => void>
-];
-export declare function Router({ routerData }: {
-    routerData?: RouterData | undefined;
-}): import("react").CElement<{
+export declare function Link({ to, children, pending, notPending, unstable_prefetchOnEnter, ...props }: LinkProps): ReactElement;
+export declare function Router(): import("react").FunctionComponentElement<Omit<{
+    initialInput?: string;
+    initialSearchParamsString?: string;
+    cache?: [[input: string, searchParamsString: string, setElements: (updater: Promise<Record<string, ReactNode>> | ((prev: Promise<Record<string, ReactNode>>) => Promise<Record<string, ReactNode>>)) => void, elements: Promise<Record<string, ReactNode>>]?];
     children: ReactNode;
-}, ErrorBoundary>;
+}, "children">>;
 /**
  * ServerRouter for SSR
  * This is not a public API.
  */
-export declare function ServerRouter({ children, route, }: {
+export declare function ServerRouter({ children, loc, }: {
     children: ReactNode;
-    route: RouteProps;
+    loc: ReturnType<typeof parseLocation>;
 }): import("react").FunctionComponentElement<{
-    children?: ReactNode | undefined;
+    children?: ReactNode;
 }>;
-declare class ErrorBoundary extends Component<{
-    children: ReactNode;
-}, {
-    error?: unknown;
-}> {
-    constructor(props: {
-        children: ReactNode;
-    });
-    static getDerivedStateFromError(error: unknown): {
-        error: unknown;
-    };
-    render(): ReactNode;
-}
 export {};
diff --git a/dist/router/client.js b/dist/router/client.js
index 78ee52642ef4dbc67cf1a1f0c53d4b7d6f51dc1c..c512e1f87a19644d7b675f1337459ab4f7f2e328 100644
--- a/dist/router/client.js
+++ b/dist/router/client.js
@@ -401,6 +401,9 @@ const notAvailableInServer = (name)=>()=>{
         }
     }, children));
 }
+function renderError(message) {
+    return createElement('html', null, createElement('body', null, createElement('h1', null, message)));
+}
 class ErrorBoundary extends Component {
     constructor(props){
         super(props);
@@ -414,9 +417,9 @@ class ErrorBoundary extends Component {
     render() {
         if ('error' in this.state) {
             if (this.state.error instanceof Error && this.state.error.statusCode === 404) {
-                return createElement('h1', null, 'Not Found');
+                return renderError('Not Found');
             }
-            return createElement('h1', null, String(this.state.error));
+            return renderError(String(this.state.error));
         }
         return this.props.children;
     }
diff --git a/dist/router/common.d.ts b/dist/router/common.d.ts
index 2c020908f736df2c2853ba3172b4b76bfc6d726b..78ac3d3d270a3a4fc5762f67a79372097150afd5 100644
--- a/dist/router/common.d.ts
+++ b/dist/router/common.d.ts
@@ -1,17 +1,13 @@
 export type RouteProps = {
     path: string;
-    query: string;
-    hash: string;
+    searchParams: URLSearchParams;
 };
 export declare function getComponentIds(path: string): readonly string[];
 export declare function getInputString(path: string): string;
 export declare function parseInputString(input: string): string;
+export declare const PARAM_KEY_SKIP = "waku_router_skip";
 export declare const SHOULD_SKIP_ID = "/SHOULD_SKIP";
-export declare const LOCATION_ID = "/LOCATION";
-export type ShouldSkip = (readonly [
-    componentId: string,
-    readonly [
-        path?: boolean,
-        query?: boolean
-    ]
-])[];
+export type ShouldSkip = Record<string, {
+    path?: boolean;
+    keys?: string[];
+}>;
diff --git a/dist/router/create-pages-utils/inferred-path-types.js b/dist/router/create-pages-utils/inferred-path-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..e3e55b2032b1a877bca7ff2d796e74f7a47cb823
--- /dev/null
+++ b/dist/router/create-pages-utils/inferred-path-types.js
@@ -0,0 +1,20 @@
+/**
+ * PathsForPages will take the response of createPages and return the paths for all user defined pages.
+ *
+ * @example
+ * const pages = createPages(async ({ createPage }) => [
+ *   createPage({
+ *     render: 'static',
+ *     path: '/foo',
+ *     component: Foo,
+ *   }),
+ *   createPage({
+ *     render: 'static',
+ *     path: '/bar',
+ *     component: Bar,
+ *   }),
+ * ]);
+ *
+ * type MyPaths = PathsForPages<typeof pages>;
+ * // type MyPaths = '/foo' | '/bar';
+ */ export { };
diff --git a/dist/router/create-pages.d.ts b/dist/router/create-pages.d.ts
deleted file mode 100644
index 399d3f887dcc011417e3f04a13fe4c334c4c8511..0000000000000000000000000000000000000000
diff --git a/dist/router/create-pages.js b/dist/router/create-pages.js
index 697304790d12c34320b93ae07d73189014b63fce..4f7a13b98d89ea9eb4d5bebc17b6308da3727123 100644
--- a/dist/router/create-pages.js
+++ b/dist/router/create-pages.js
@@ -117,6 +117,7 @@ export function createPages(fn) {
         } else {
             throw new Error('Invalid page configuration');
         }
+        return page;
     };
     const createLayout = (layout)=>{
         if (configured) {
@@ -150,7 +151,7 @@ export function createPages(fn) {
         }
         await ready;
     };
-    return unstable_defineRouter(async ()=>{
+    const definedRouter = unstable_defineRouter(async ()=>{
         await configure();
         const paths = [];
         for (const [path, pathSpec] of staticPathSet){
@@ -253,4 +254,5 @@ export function createPages(fn) {
         unstable_setShouldSkip([]); // negative cache
         return null; // not found
     });
+    return definedRouter;
 }
diff --git a/dist/router/createPages.d.ts b/dist/router/createPages.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..88d2b38bb67e0d58cddeb028138bf686d5dbc059
--- /dev/null
+++ b/dist/router/createPages.d.ts
@@ -0,0 +1,41 @@
+import type { FunctionComponent, ReactNode } from 'react';
+import type { RouteProps } from './common.js';
+type IsValidPathItem<T> = T extends `/${infer _}` ? false : T extends '[]' | '' ? false : true;
+type IsValidPath<T> = T extends `/${infer L}/${infer R}` ? IsValidPathItem<L> extends true ? IsValidPath<`/${R}`> : false : T extends `/${infer U}` ? IsValidPathItem<U> : false;
+type HasSlugInPath<T, K extends string> = T extends `/[${K}]/${infer _}` ? true : T extends `/${infer _}/${infer U}` ? HasSlugInPath<`/${U}`, K> : T extends `/[${K}]` ? true : false;
+type PathWithSlug<T, K extends string> = IsValidPath<T> extends true ? HasSlugInPath<T, K> extends true ? T : never : never;
+type PathWithoutSlug<T> = T extends '/' ? T : IsValidPath<T> extends true ? HasSlugInPath<T, string> extends true ? never : T : never;
+type CreatePage = <Path extends string, SlugKey extends string, WildSlugKey extends string>(page: {
+    render: 'static';
+    path: PathWithoutSlug<Path>;
+    component: FunctionComponent<RouteProps>;
+} | {
+    render: 'static';
+    path: PathWithSlug<Path, SlugKey>;
+    staticPaths: string[] | string[][];
+    component: FunctionComponent<RouteProps & Record<SlugKey, string>>;
+} | {
+    render: 'dynamic';
+    path: PathWithoutSlug<Path>;
+    component: FunctionComponent<RouteProps>;
+} | {
+    render: 'dynamic';
+    path: PathWithSlug<Path, SlugKey | `...${WildSlugKey}`>;
+    component: FunctionComponent<RouteProps & Record<SlugKey, string> & Record<WildSlugKey, string[]>>;
+}) => void;
+type CreateLayout = <T extends string>(layout: {
+    render: 'static';
+    path: PathWithoutSlug<T>;
+    component: FunctionComponent<RouteProps & {
+        children: ReactNode;
+    }>;
+}) => void;
+export declare function createPages(fn: (fns: {
+    createPage: CreatePage;
+    createLayout: CreateLayout;
+}) => Promise<void>): {
+    renderEntries: import("../server.js").RenderEntries;
+    getBuildConfig: import("../server.js").GetBuildConfig | undefined;
+    getSsrConfig: import("../server.js").GetSsrConfig | undefined;
+};
+export {};
diff --git a/dist/router/createPages.js b/dist/router/createPages.js
new file mode 100644
index 0000000000000000000000000000000000000000..ca4162db32d12dd67178fb4a6e5c6287395195d4
--- /dev/null
+++ b/dist/router/createPages.js
@@ -0,0 +1,161 @@
+import { createElement } from 'react';
+import { defineRouter } from './defineRouter.js';
+import { joinPath, parsePathWithSlug, getPathMapping } from '../lib/utils/path.js';
+export function createPages(fn) {
+    let configured = false;
+    const staticPathSet = new Set();
+    const dynamicPathMap = new Map();
+    const wildcardPathMap = new Map();
+    const staticComponentMap = new Map();
+    const registerStaticComponent = (id, component)=>{
+        if (staticComponentMap.has(id) && staticComponentMap.get(id) !== component) {
+            throw new Error(`Duplicated component for: ${id}`);
+        }
+        staticComponentMap.set(id, component);
+    };
+    const createPage = (page)=>{
+        if (configured) {
+            throw new Error('no longer available');
+        }
+        const pathSpec = parsePathWithSlug(page.path);
+        const numSlugs = pathSpec.filter(({ type })=>type !== 'literal').length;
+        const numWildcards = pathSpec.filter(({ type })=>type === 'wildcard').length;
+        if (page.render === 'static' && numSlugs === 0) {
+            staticPathSet.add(pathSpec);
+            const id = joinPath(page.path, 'page').replace(/^\//, '');
+            registerStaticComponent(id, page.component);
+        } else if (page.render === 'static' && numSlugs > 0 && numWildcards === 0) {
+            const staticPaths = page.staticPaths.map((item)=>Array.isArray(item) ? item : [
+                    item
+                ]);
+            for (const staticPath of staticPaths){
+                if (staticPath.length !== numSlugs) {
+                    throw new Error('staticPaths does not match with slug pattern');
+                }
+                const mapping = {};
+                let slugIndex = 0;
+                const pathItems = pathSpec.map(({ type, name })=>{
+                    if (type !== 'literal') {
+                        const actualName = staticPath[slugIndex++];
+                        if (name) {
+                            mapping[name] = actualName;
+                        }
+                        return actualName;
+                    }
+                    return name;
+                });
+                staticPathSet.add(pathItems.map((name)=>({
+                        type: 'literal',
+                        name
+                    })));
+                const id = joinPath(...pathItems, 'page');
+                const WrappedComponent = (props)=>createElement(page.component, {
+                        ...props,
+                        ...mapping
+                    });
+                registerStaticComponent(id, WrappedComponent);
+            }
+        } else if (page.render === 'dynamic' && numWildcards === 0) {
+            if (dynamicPathMap.has(page.path)) {
+                throw new Error(`Duplicated dynamic path: ${page.path}`);
+            }
+            dynamicPathMap.set(page.path, [
+                pathSpec,
+                page.component
+            ]);
+        } else if (page.render === 'dynamic' && numWildcards === 1) {
+            if (wildcardPathMap.has(page.path)) {
+                throw new Error(`Duplicated dynamic path: ${page.path}`);
+            }
+            wildcardPathMap.set(page.path, [
+                pathSpec,
+                page.component
+            ]);
+        } else {
+            throw new Error('Invalid page configuration');
+        }
+    };
+    const createLayout = (layout)=>{
+        if (configured) {
+            throw new Error('no longer available');
+        }
+        const id = joinPath(layout.path, 'layout').replace(/^\//, '');
+        registerStaticComponent(id, layout.component);
+    };
+    const ready = fn({
+        createPage,
+        createLayout
+    }).then(()=>{
+        configured = true;
+    });
+    return defineRouter(async ()=>{
+        await ready;
+        const paths = [];
+        for (const pathSpec of staticPathSet){
+            paths.push({
+                path: pathSpec,
+                isStatic: true
+            });
+        }
+        for (const [pathSpec] of dynamicPathMap.values()){
+            paths.push({
+                path: pathSpec,
+                isStatic: false
+            });
+        }
+        for (const [pathSpec] of wildcardPathMap.values()){
+            paths.push({
+                path: pathSpec,
+                isStatic: false
+            });
+        }
+        return paths;
+    }, async (id, unstable_setShouldSkip)=>{
+        await ready;
+        const staticComponent = staticComponentMap.get(id);
+        if (staticComponent) {
+            unstable_setShouldSkip({});
+            return staticComponent;
+        }
+        for (const [pathSpec, Component] of dynamicPathMap.values()){
+            const mapping = getPathMapping([
+                ...pathSpec,
+                {
+                    type: 'literal',
+                    name: 'page'
+                }
+            ], id);
+            if (mapping) {
+                if (Object.keys(mapping).length === 0) {
+                    unstable_setShouldSkip();
+                    return Component;
+                }
+                const WrappedComponent = (props)=>createElement(Component, {
+                        ...props,
+                        ...mapping
+                    });
+                unstable_setShouldSkip();
+                return WrappedComponent;
+            }
+        }
+        for (const [pathSpec, Component] of wildcardPathMap.values()){
+            const mapping = getPathMapping([
+                ...pathSpec,
+                {
+                    type: 'literal',
+                    name: 'page'
+                }
+            ], id);
+            if (mapping) {
+                const WrappedComponent = (props)=>createElement(Component, {
+                        ...props,
+                        ...mapping
+                    });
+                unstable_setShouldSkip();
+                return WrappedComponent;
+            }
+        }
+        unstable_setShouldSkip({}); // negative cache
+        return null; // not found
+    });
+}
diff --git a/dist/router/define-router.d.ts b/dist/router/define-router.d.ts
deleted file mode 100644
index 2bb976375e5de805a20a969abbf6e5f543f5ac1e..0000000000000000000000000000000000000000
diff --git a/dist/router/defineRouter.d.ts b/dist/router/defineRouter.d.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8c45ebeee97eba03759587cc3fbf59d9f83c46f5
--- /dev/null
+++ b/dist/router/defineRouter.d.ts
@@ -0,0 +1,17 @@
+import type { FunctionComponent, ReactNode } from 'react';
+import { defineEntries } from '../server.js';
+import type { RouteProps, ShouldSkip } from './common.js';
+import type { PathSpec } from '../lib/utils/path.js';
+export declare function defineRouter(getPathConfig: () => Promise<Iterable<{
+    path: PathSpec;
+    isStatic?: boolean;
+}>>, getComponent: (componentId: string, // "**/layout" or "**/page"
+unstable_setShouldSkip: (val?: ShouldSkip[string]) => void) => Promise<FunctionComponent<RouteProps> | FunctionComponent<RouteProps & {
+    children: ReactNode;
+}> | {
+    default: FunctionComponent<RouteProps>;
+} | {
+    default: FunctionComponent<RouteProps & {
+        children: ReactNode;
+    }>;
+} | null>): ReturnType<typeof defineEntries>;
diff --git a/dist/router/defineRouter.js b/dist/router/defineRouter.js
new file mode 100644
index 0000000000000000000000000000000000000000..11fade999101eb8107a37dac926f0accbdd16a50
--- /dev/null
+++ b/dist/router/defineRouter.js
@@ -0,0 +1,136 @@
+import { createElement } from 'react';
+import { Children, Slot } from '../client.js';
+import { getComponentIds, getInputString, parseInputString, PARAM_KEY_SKIP, SHOULD_SKIP_ID } from './common.js';
+import { getPathMapping } from '../lib/utils/path.js';
+import { ServerRouter } from './client.js';
+const ShoudSkipComponent = ({ shouldSkip })=>createElement('meta', {
+        name: 'waku-should-skip',
+        content: JSON.stringify(shouldSkip)
+    });
+export function defineRouter(getPathConfig, getComponent) {
+    const pathConfigPromise = getPathConfig().then((pathConfig)=>Array.from(pathConfig).map((item)=>{
+            const is404 = item.path.length === 1 && item.path[0].type === 'literal' && item.path[0].name === '404';
+            return {
+                ...item,
+                is404
+            };
+        }));
+    const has404Promise = pathConfigPromise.then((pathConfig)=>pathConfig.some(({ is404 })=>is404));
+    const existsPath = async (pathname)=>{
+        const pathConfig = await pathConfigPromise;
+        return pathConfig.some(({ path: pathSpec })=>getPathMapping(pathSpec, pathname));
+    };
+    const shouldSkip = {};
+    const renderEntries = async (input, searchParams)=>{
+        const pathname = parseInputString(input);
+        if (!existsPath(pathname)) {
+            return null;
+        }
+        const skip = searchParams.getAll(PARAM_KEY_SKIP) || [];
+        const componentIds = getComponentIds(pathname);
+        const props = {
+            path: pathname,
+            searchParams
+        };
+        const entries = (await Promise.all(componentIds.map(async (id)=>{
+            if (skip?.includes(id)) {
+                return [];
+            }
+            const mod = await getComponent(id, (val)=>{
+                if (val) {
+                    shouldSkip[id] = val;
+                } else {
+                    delete shouldSkip[id];
+                }
+            });
+            const component = mod && 'default' in mod ? mod.default : mod;
+            if (!component) {
+                return [];
+            }
+            const element = createElement(component, props, createElement(Children));
+            return [
+                [
+                    id,
+                    element
+                ]
+            ];
+        }))).flat();
+        entries.push([
+            SHOULD_SKIP_ID,
+            createElement(ShoudSkipComponent, {
+                shouldSkip
+            })
+        ]);
+        return Object.fromEntries(entries);
+    };
+    const getBuildConfig = async (unstable_collectClientModules)=>{
+        const pathConfig = await pathConfigPromise;
+        const path2moduleIds = {};
+        for (const { path: pathSpec } of pathConfig){
+            if (pathSpec.some(({ type })=>type !== 'literal')) {
+                continue;
+            }
+            const pathname = '/' + pathSpec.map(({ name })=>name).join('/');
+            const input = getInputString(pathname);
+            const moduleIds = await unstable_collectClientModules(input);
+            path2moduleIds[pathname] = moduleIds;
+        }
+        const customCode = `
+globalThis.__WAKU_ROUTER_PREFETCH__ = (path) => {
+  const path2ids = ${JSON.stringify(path2moduleIds)};
+  for (const id of path2ids[path] || []) {
+    import(id);
+  }
+};`;
+        const buildConfig = [];
+        for (const { path: pathSpec, isStatic = false, is404 } of pathConfig){
+            const entries = [];
+            if (pathSpec.every(({ type })=>type === 'literal')) {
+                const pathname = '/' + pathSpec.map(({ name })=>name).join('/');
+                const input = getInputString(pathname);
+                entries.push({
+                    input,
+                    isStatic
+                });
+            }
+            buildConfig.push({
+                pathname: pathSpec,
+                isStatic,
+                entries,
+                customCode: customCode + (is404 ? 'globalThis.__WAKU_ROUTER_404__ = true;' : '')
+            });
+        }
+        return buildConfig;
+    };
+    const getSsrConfig = async (pathname, { searchParams })=>{
+        if (!await existsPath(pathname)) {
+            if (await has404Promise) {
+                pathname = '/404';
+            } else {
+                return null;
+            }
+        }
+        const componentIds = getComponentIds(pathname);
+        const input = getInputString(pathname);
+        const body = createElement(ServerRouter, {
+            loc: {
+                path: pathname,
+                searchParams
+            }
+        }, createElement(Slot, {
+            id: SHOULD_SKIP_ID
+        }), componentIds.reduceRight((acc, id)=>createElement(Slot, {
+                id,
+                fallback: acc
+            }, acc), null));
+        return {
+            input,
+            body
+        };
+    };
+    return {
+        renderEntries,
+        getBuildConfig,
+        getSsrConfig
+    };
+}
diff --git a/dist/router/fs-router.d.ts b/dist/router/fs-router.d.ts
deleted file mode 100644
index a9fdb920818be175f8e41eb8613f88c28505eb02..0000000000000000000000000000000000000000
diff --git a/dist/router/fs-router.js b/dist/router/fs-router.js
index 594a68dce4674f31733c90721402519437cf6e7d..ba4f87ea6105aece2ebc902100c56c870c6c3f55 100644
--- a/dist/router/fs-router.js
+++ b/dist/router/fs-router.js
@@ -1,6 +1,6 @@
 import { unstable_getPlatformObject } from '../server.js';
 import { createPages } from './create-pages.js';
-import { EXTENSIONS } from '../lib/config.js';
+import { EXTENSIONS } from '../lib/constants.js';
 const DO_NOT_BUNDLE = '';
 export function fsRouter(importMetaUrl, loadPage, pages = 'pages') {
     const platformObject = unstable_getPlatformObject();
@@ -71,5 +71,6 @@ export function fsRouter(importMetaUrl, loadPage, pages = 'pages') {
                 });
             }
         }
+        return []; // TODO this type support for fsRouter pages
     });
 }
diff --git a/dist/router/server.d.ts b/dist/router/server.d.ts
index 38ccf827bd4010eb652fc8d3b689c5f16ea1737b..6ede41d00c0fda5a40f638e72f5897c8d00ecf4e 100644
--- a/dist/router/server.d.ts
+++ b/dist/router/server.d.ts
@@ -1,3 +1,2 @@
-export { unstable_defineRouter, unstable_redirect } from './define-router.js';
-export { createPages } from './create-pages.js';
-export { fsRouter } from './fs-router.js';
+export { defineRouter as unstable_defineRouter } from './defineRouter.js';
+export { createPages } from './createPages.js';
diff --git a/dist/router/util-types.js b/dist/router/util-types.js
new file mode 100644
index 0000000000000000000000000000000000000000..2acfac1b4c13405d22ba52b3cb4c60efdb103371
--- /dev/null
+++ b/dist/router/util-types.js
@@ -0,0 +1,13 @@
+/**
+ * Type version of `String.prototype.split()`. Splits the first string argument by the second string argument
+ * @example
+ * ```ts
+ * // ['a', 'b', 'c']
+ * type Case1 = Split<'abc', ''>
+ * // ['a', 'b', 'c']
+ * type Case2 = Split<'a,b,c', ','>
+ * ```
+ */ /**
+ * This helper makes types more readable
+ * @see https://www.totaltypescript.com/concepts/the-prettify-helper
+ */ export { };
diff --git a/dist/server.d.ts b/dist/server.d.ts
index 26bcf75cfa13355eeb9e27c12e0626ec468bdf4c..7cb232381a9323240ac7e9cd3cea367216ae1e92 100644
--- a/dist/server.d.ts
+++ b/dist/server.d.ts
@@ -2,27 +2,28 @@ import type { ReactNode } from 'react';
 import type { Config } from './config.js';
 import type { PathSpec } from './lib/utils/path.js';
 type Elements = Record<string, ReactNode>;
-export type BuildConfig = {
+export interface RenderContext<T extends Record<string, unknown> = Record<string, unknown>> {
+    rerender: (input: string, searchParams?: URLSearchParams) => void;
+    context: T;
+}
+export type RenderEntries = (this: RenderContext, input: string, searchParams: URLSearchParams) => Promise<Elements | null>;
+export type GetBuildConfig = (unstable_collectClientModules: (input: string) => Promise<string[]>) => Promise<Iterable<{
     pathname: string | PathSpec;
-    isStatic?: boolean | undefined;
-    entries?: {
+    isStatic?: boolean;
+    entries?: Iterable<{
         input: string;
-        skipPrefetch?: boolean | undefined;
-        isStatic?: boolean | undefined;
-    }[];
-    context?: Record<string, unknown>;
+        skipPrefetch?: boolean;
+        isStatic?: boolean;
+    }>;
     customCode?: string;
-}[];
-export type RenderEntries = (input: string, options: {
-    params: unknown | undefined;
-}) => Promise<Elements | null>;
-export type GetBuildConfig = (unstable_collectClientModules: (input: string) => Promise<string[]>) => Promise<BuildConfig>;
+    context?: Record<string, unknown>;
+}>>;
 export type GetSsrConfig = (pathname: string, options: {
     searchParams: URLSearchParams;
 }) => Promise<{
     input: string;
-    params?: unknown;
-    html: ReactNode;
+    searchParams?: URLSearchParams;
+    body: ReactNode;
 } | null>;
 export declare function defineEntries(renderEntries: RenderEntries, getBuildConfig?: GetBuildConfig, getSsrConfig?: GetSsrConfig): {
     renderEntries: RenderEntries;
@@ -33,35 +34,10 @@ export type EntriesDev = {
     default: ReturnType<typeof defineEntries>;
 };
 export type EntriesPrd = EntriesDev & {
-    loadConfig: () => Promise<Config>;
+    configPromise: Promise<Config>;
     loadModule: (id: string) => Promise<unknown>;
     dynamicHtmlPaths: [pathSpec: PathSpec, htmlHead: string][];
     publicIndexHtml: string;
-    buildData?: Record<string, unknown>;
 };
-declare let serverEnv: Readonly<Record<string, string>>;
-/**
- * This is an internal function and not for public use.
- */
-export declare function setAllEnvInternal(newEnv: typeof serverEnv): void;
 export declare function getEnv(key: string): string | undefined;
-type RenderStore = {
-    rerender: (input: string, params?: unknown) => void;
-    context: Record<string, unknown>;
-};
-/**
- * This is an internal function and not for public use.
- */
-export declare const runWithRenderStoreInternal: <T>(renderStore: RenderStore, fn: () => T) => T;
-export declare function rerender(input: string, params?: unknown): void;
-export declare function unstable_getCustomContext<CustomContext extends Record<string, unknown> = Record<string, unknown>>(): CustomContext;
-export declare function unstable_getHeaders(): Record<string, string>;
-type PlatformObject = {
-    buildData?: Record<string, unknown>;
-    buildOptions?: {
-        deploy?: 'vercel-static' | 'vercel-serverless' | 'netlify-static' | 'netlify-functions' | 'cloudflare' | 'partykit' | 'deno' | 'aws-lambda' | undefined;
-        unstable_phase?: 'analyzeEntries' | 'buildServerBundle' | 'buildSsrBundle' | 'buildClientBundle' | 'buildDeploy';
-    };
-} & Record<string, unknown>;
-export declare function unstable_getPlatformObject(): PlatformObject;
 export {};
diff --git a/dist/unstable_hono.js b/dist/unstable_hono.js
new file mode 100644
index 0000000000000000000000000000000000000000..9352df6ac5e6c74eb71d3b4d361fd98a9523fdd8
--- /dev/null
+++ b/dist/unstable_hono.js
@@ -0,0 +1,5 @@
+// These exports are for internal use only and subject to change without notice.
+export { runner } from './lib/hono/runner.js';
+export const importHono = ()=>import('hono');
+export const importHonoNodeServer = ()=>import('@hono/node-server');
+export const importHonoNodeServerServeStatic = ()=>import('@hono/node-server/serve-static');
diff --git a/dist/unstable_internals.js b/dist/unstable_internals.js
new file mode 100644
index 0000000000000000000000000000000000000000..279ee781d3d03df5161baa24fadadad432b01051
--- /dev/null
+++ b/dist/unstable_internals.js
@@ -0,0 +1,20 @@
+// These exports are for internal use only and subject to change without notice.
+export { build } from './lib/builder/build.js';
+export { deployAwsLambdaPlugin } from './lib/plugins/vite-plugin-deploy-aws-lambda.js';
+export { deployCloudflarePlugin } from './lib/plugins/vite-plugin-deploy-cloudflare.js';
+export { deployDenoPlugin } from './lib/plugins/vite-plugin-deploy-deno.js';
+export { deployNetlifyPlugin } from './lib/plugins/vite-plugin-deploy-netlify.js';
+export { deployPartykitPlugin } from './lib/plugins/vite-plugin-deploy-partykit.js';
+export { deployVercelPlugin } from './lib/plugins/vite-plugin-deploy-vercel.js';
+export { devCommonJsPlugin } from './lib/plugins/vite-plugin-dev-commonjs.js';
+export { nonjsResolvePlugin } from './lib/plugins/vite-plugin-nonjs-resolve.js';
+export { rscAnalyzePlugin } from './lib/plugins/vite-plugin-rsc-analyze.js';
+export { rscDelegatePlugin } from './lib/plugins/vite-plugin-rsc-delegate.js';
+export { rscEntriesPlugin } from './lib/plugins/vite-plugin-rsc-entries.js';
+export { rscEnvPlugin } from './lib/plugins/vite-plugin-rsc-env.js';
+export { rscHmrPlugin } from './lib/plugins/vite-plugin-rsc-hmr.js';
+export { rscIndexPlugin } from './lib/plugins/vite-plugin-rsc-index.js';
+export { rscManagedPlugin } from './lib/plugins/vite-plugin-rsc-managed.js';
+export { rscPrivatePlugin } from './lib/plugins/vite-plugin-rsc-private.js';
+export { rscRsdwPlugin } from './lib/plugins/vite-plugin-rsc-rsdw.js';
+export { rscTransformPlugin } from './lib/plugins/vite-plugin-rsc-transform.js';
